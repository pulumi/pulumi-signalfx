# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AlertMutingRuleFilterArgs',
    'DashboardChartArgs',
    'DashboardColumnArgs',
    'DashboardEventOverlayArgs',
    'DashboardEventOverlaySourceArgs',
    'DashboardFilterArgs',
    'DashboardGridArgs',
    'DashboardGroupDashboardArgs',
    'DashboardGroupDashboardFilterOverrideArgs',
    'DashboardGroupDashboardVariableOverrideArgs',
    'DashboardGroupImportQualifierArgs',
    'DashboardGroupImportQualifierFilterArgs',
    'DashboardGroupPermissionArgs',
    'DashboardPermissionsArgs',
    'DashboardPermissionsAclArgs',
    'DashboardSelectedEventOverlayArgs',
    'DashboardSelectedEventOverlaySourceArgs',
    'DashboardVariableArgs',
    'DataLinkTargetExternalUrlArgs',
    'DataLinkTargetSignalfxDashboardArgs',
    'DataLinkTargetSplunkArgs',
    'DetectorRuleArgs',
    'DetectorVizOptionArgs',
    'HeatmapChartColorRangeArgs',
    'HeatmapChartColorScaleArgs',
    'ListChartColorScaleArgs',
    'ListChartLegendOptionsFieldArgs',
    'ListChartVizOptionArgs',
    'MetricRulesetAggregationRuleArgs',
    'MetricRulesetAggregationRuleAggregatorArgs',
    'MetricRulesetAggregationRuleMatcherArgs',
    'MetricRulesetAggregationRuleMatcherFilterArgs',
    'MetricRulesetRoutingRuleArgs',
    'OrgTokenDpmLimitsArgs',
    'OrgTokenHostOrUsageLimitsArgs',
    'SingleValueChartColorScaleArgs',
    'SingleValueChartVizOptionArgs',
    'TableChartVizOptionArgs',
    'TimeChartAxisLeftArgs',
    'TimeChartAxisLeftWatermarkArgs',
    'TimeChartAxisRightArgs',
    'TimeChartAxisRightWatermarkArgs',
    'TimeChartEventOptionArgs',
    'TimeChartHistogramOptionArgs',
    'TimeChartLegendOptionsFieldArgs',
    'TimeChartVizOptionArgs',
    'WebhookIntegrationHeaderArgs',
]

@pulumi.input_type
class AlertMutingRuleFilterArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 property_value: pulumi.Input[str],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: the property to filter by
        :param pulumi.Input[str] property_value: the value of the property to filter by
        :param pulumi.Input[bool] negated: (false by default) whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "property_value", property_value)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> pulumi.Input[str]:
        """
        the value of the property to filter by
        """
        return pulumi.get(self, "property_value")

    @property_value.setter
    def property_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "property_value", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        the property to filter by
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardChartArgs:
    def __init__(__self__, *,
                 chart_id: pulumi.Input[str],
                 column: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 row: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] chart_id: ID of the chart to display
        :param pulumi.Input[int] column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
        :param pulumi.Input[int] height: How many rows the chart should take up. (greater than or equal to 1)
        :param pulumi.Input[int] row: The row to show the chart in (zero-based); if height > 1, this value represents the topmost row of the chart. (greater than or equal to 0)
        :param pulumi.Input[int] width: How many columns (out of a total of 12, one-based) the chart should take up. (between 1 and 12)
        """
        pulumi.set(__self__, "chart_id", chart_id)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if row is not None:
            pulumi.set(__self__, "row", row)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartId")
    def chart_id(self) -> pulumi.Input[str]:
        """
        ID of the chart to display
        """
        return pulumi.get(self, "chart_id")

    @chart_id.setter
    def chart_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "chart_id", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[int]]:
        """
        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows the chart should take up. (greater than or equal to 1)
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def row(self) -> Optional[pulumi.Input[int]]:
        """
        The row to show the chart in (zero-based); if height > 1, this value represents the topmost row of the chart. (greater than or equal to 0)
        """
        return pulumi.get(self, "row")

    @row.setter
    def row(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "row", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        How many columns (out of a total of 12, one-based) the chart should take up. (between 1 and 12)
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardColumnArgs:
    def __init__(__self__, *,
                 chart_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 column: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: Charts to use for the column
        :param pulumi.Input[int] column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
        :param pulumi.Input[int] height: How many rows each chart should take up. (greater than or equal to 1)
        :param pulumi.Input[int] width: Number of columns (out of a total of 12) each chart should take up. (between 1 and 12)
        """
        pulumi.set(__self__, "chart_ids", chart_ids)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartIds")
    def chart_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Charts to use for the column
        """
        return pulumi.get(self, "chart_ids")

    @chart_ids.setter
    def chart_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "chart_ids", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[int]]:
        """
        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows each chart should take up. (greater than or equal to 1)
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        Number of columns (out of a total of 12) each chart should take up. (between 1 and 12)
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardEventOverlayArgs:
    def __init__(__self__, *,
                 signal: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 line: Optional[pulumi.Input[bool]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] signal: Search term used to define events
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] label: The text displaying in the dropdown menu used to select this event overlay as an active overlay for the dashboard.
        :param pulumi.Input[bool] line: (false by default) Whether a vertical line should be displayed in the plot at the time the event occurs
        :param pulumi.Input[str] type: Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
        """
        pulumi.set(__self__, "signal", signal)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if line is not None:
            pulumi.set(__self__, "line", line)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def signal(self) -> pulumi.Input[str]:
        """
        Search term used to define events
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: pulumi.Input[str]):
        pulumi.set(self, "signal", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The text displaying in the dropdown menu used to select this event overlay as an active overlay for the dashboard.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def line(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether a vertical line should be displayed in the plot at the time the event occurs
        """
        return pulumi.get(self, "line")

    @line.setter
    def line(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "line", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]]:
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DashboardEventOverlaySourceArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardFilterArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 apply_if_exist: Optional[pulumi.Input[bool]] = None,
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] apply_if_exist: If true, this filter will also match data that does not have the specified property
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if apply_if_exist is not None:
            pulumi.set(__self__, "apply_if_exist", apply_if_exist)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="applyIfExist")
    def apply_if_exist(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this filter will also match data that does not have the specified property
        """
        return pulumi.get(self, "apply_if_exist")

    @apply_if_exist.setter
    def apply_if_exist(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_if_exist", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGridArgs:
    def __init__(__self__, *,
                 chart_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 height: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: Charts to use for the grid
        :param pulumi.Input[int] height: How many rows each chart should take up. (greater than or equal to 1)
        :param pulumi.Input[int] width: Number of columns (out of a total of 12, one-based) each chart should take up. (between 1 and 12)
        """
        pulumi.set(__self__, "chart_ids", chart_ids)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartIds")
    def chart_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Charts to use for the grid
        """
        return pulumi.get(self, "chart_ids")

    @chart_ids.setter
    def chart_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "chart_ids", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows each chart should take up. (greater than or equal to 1)
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        Number of columns (out of a total of 12, one-based) each chart should take up. (between 1 and 12)
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardGroupDashboardArgs:
    def __init__(__self__, *,
                 dashboard_id: pulumi.Input[str],
                 config_id: Optional[pulumi.Input[str]] = None,
                 description_override: Optional[pulumi.Input[str]] = None,
                 filter_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]] = None,
                 name_override: Optional[pulumi.Input[str]] = None,
                 variable_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]] = None):
        """
        :param pulumi.Input[str] dashboard_id: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] config_id: Unique identifier of an association between a dashboard group and a dashboard
        :param pulumi.Input[str] description_override: String that provides a description override for a mirrored dashboard
        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]] filter_overrides: Filter to apply to each chart in the dashboard
        :param pulumi.Input[str] name_override: String that provides a name override for a mirrored dashboard
        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]] variable_overrides: Dashboard variable to apply to each chart in the dashboard
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if config_id is not None:
            pulumi.set(__self__, "config_id", config_id)
        if description_override is not None:
            pulumi.set(__self__, "description_override", description_override)
        if filter_overrides is not None:
            pulumi.set(__self__, "filter_overrides", filter_overrides)
        if name_override is not None:
            pulumi.set(__self__, "name_override", name_override)
        if variable_overrides is not None:
            pulumi.set(__self__, "variable_overrides", variable_overrides)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of an association between a dashboard group and a dashboard
        """
        return pulumi.get(self, "config_id")

    @config_id.setter
    def config_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_id", value)

    @property
    @pulumi.getter(name="descriptionOverride")
    def description_override(self) -> Optional[pulumi.Input[str]]:
        """
        String that provides a description override for a mirrored dashboard
        """
        return pulumi.get(self, "description_override")

    @description_override.setter
    def description_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description_override", value)

    @property
    @pulumi.getter(name="filterOverrides")
    def filter_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]]:
        """
        Filter to apply to each chart in the dashboard
        """
        return pulumi.get(self, "filter_overrides")

    @filter_overrides.setter
    def filter_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]]):
        pulumi.set(self, "filter_overrides", value)

    @property
    @pulumi.getter(name="nameOverride")
    def name_override(self) -> Optional[pulumi.Input[str]]:
        """
        String that provides a name override for a mirrored dashboard
        """
        return pulumi.get(self, "name_override")

    @name_override.setter
    def name_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_override", value)

    @property
    @pulumi.getter(name="variableOverrides")
    def variable_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]]:
        """
        Dashboard variable to apply to each chart in the dashboard
        """
        return pulumi.get(self, "variable_overrides")

    @variable_overrides.setter
    def variable_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]]):
        pulumi.set(self, "variable_overrides", value)


@pulumi.input_type
class DashboardGroupDashboardFilterOverrideArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGroupDashboardVariableOverrideArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values_suggesteds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        pulumi.set(__self__, "property", property)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if values_suggesteds is not None:
            pulumi.set(__self__, "values_suggesteds", values_suggesteds)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="valuesSuggesteds")
    def values_suggesteds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        return pulumi.get(self, "values_suggesteds")

    @values_suggesteds.setter
    def values_suggesteds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values_suggesteds", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGroupImportQualifierArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]] filters: Filter to apply to each chart in the dashboard
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]]]:
        """
        Filter to apply to each chart in the dashboard
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardGroupImportQualifierFilterArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGroupPermissionArgs:
    def __init__(__self__, *,
                 principal_id: pulumi.Input[str],
                 principal_type: pulumi.Input[str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] principal_id: ID of the principal with access
        :param pulumi.Input[str] principal_type: Type of principal, possible values: ORG, TEAM, USER
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Actions level, possible values: READ, WRITE
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "principal_type", principal_type)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> pulumi.Input[str]:
        """
        ID of the principal with access
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> pulumi.Input[str]:
        """
        Type of principal, possible values: ORG, TEAM, USER
        """
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_type", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Actions level, possible values: READ, WRITE
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class DashboardPermissionsArgs:
    def __init__(__self__, *,
                 acls: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]] = None,
                 parent: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]] acls: The custom access control list for this dashboard
        :param pulumi.Input[str] parent: The ID of the dashboard group that this dashboard inherits permissions from
        """
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if parent is not None:
            pulumi.set(__self__, "parent", parent)

    @property
    @pulumi.getter
    def acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]]:
        """
        The custom access control list for this dashboard
        """
        return pulumi.get(self, "acls")

    @acls.setter
    def acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]]):
        pulumi.set(self, "acls", value)

    @property
    @pulumi.getter
    def parent(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the dashboard group that this dashboard inherits permissions from
        """
        return pulumi.get(self, "parent")

    @parent.setter
    def parent(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent", value)


@pulumi.input_type
class DashboardPermissionsAclArgs:
    def __init__(__self__, *,
                 principal_id: pulumi.Input[str],
                 principal_type: pulumi.Input[str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] principal_id: ID of the principal with access
        :param pulumi.Input[str] principal_type: Type of principal, possible values: ORG, TEAM, USER
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Actions level, possible values: READ, WRITE
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "principal_type", principal_type)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> pulumi.Input[str]:
        """
        ID of the principal with access
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> pulumi.Input[str]:
        """
        Type of principal, possible values: ORG, TEAM, USER
        """
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_type", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Actions level, possible values: READ, WRITE
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class DashboardSelectedEventOverlayArgs:
    def __init__(__self__, *,
                 signal: pulumi.Input[str],
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] signal: Search term used to define events
        :param pulumi.Input[str] type: Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
        """
        pulumi.set(__self__, "signal", signal)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def signal(self) -> pulumi.Input[str]:
        """
        Search term used to define events
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: pulumi.Input[str]):
        pulumi.set(self, "signal", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]]:
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DashboardSelectedEventOverlaySourceArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardVariableArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[str],
                 property: pulumi.Input[str],
                 apply_if_exist: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 replace_only: Optional[pulumi.Input[bool]] = None,
                 restricted_suggestions: Optional[pulumi.Input[bool]] = None,
                 value_required: Optional[pulumi.Input[bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values_suggesteds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] alias: An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[bool] apply_if_exist: If true, this variable will also match data that does not have the specified property
        :param pulumi.Input[str] description: Variable description
        :param pulumi.Input[bool] replace_only: If true, this variable will only apply to charts with a filter on the named property.
        :param pulumi.Input[bool] restricted_suggestions: If true, this variable may only be set to the values listed in preferredSuggestions. and only these values will appear in autosuggestion menus. false by default
        :param pulumi.Input[bool] value_required: Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). false by default
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "property", property)
        if apply_if_exist is not None:
            pulumi.set(__self__, "apply_if_exist", apply_if_exist)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if replace_only is not None:
            pulumi.set(__self__, "replace_only", replace_only)
        if restricted_suggestions is not None:
            pulumi.set(__self__, "restricted_suggestions", restricted_suggestions)
        if value_required is not None:
            pulumi.set(__self__, "value_required", value_required)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if values_suggesteds is not None:
            pulumi.set(__self__, "values_suggesteds", values_suggesteds)

    @property
    @pulumi.getter
    def alias(self) -> pulumi.Input[str]:
        """
        An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[str]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="applyIfExist")
    def apply_if_exist(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this variable will also match data that does not have the specified property
        """
        return pulumi.get(self, "apply_if_exist")

    @apply_if_exist.setter
    def apply_if_exist(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_if_exist", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Variable description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="replaceOnly")
    def replace_only(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this variable will only apply to charts with a filter on the named property.
        """
        return pulumi.get(self, "replace_only")

    @replace_only.setter
    def replace_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "replace_only", value)

    @property
    @pulumi.getter(name="restrictedSuggestions")
    def restricted_suggestions(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this variable may only be set to the values listed in preferredSuggestions. and only these values will appear in autosuggestion menus. false by default
        """
        return pulumi.get(self, "restricted_suggestions")

    @restricted_suggestions.setter
    def restricted_suggestions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restricted_suggestions", value)

    @property
    @pulumi.getter(name="valueRequired")
    def value_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). false by default
        """
        return pulumi.get(self, "value_required")

    @value_required.setter
    def value_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "value_required", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="valuesSuggesteds")
    def values_suggesteds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        return pulumi.get(self, "values_suggesteds")

    @values_suggesteds.setter
    def values_suggesteds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values_suggesteds", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DataLinkTargetExternalUrlArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 minimum_time_window: Optional[pulumi.Input[str]] = None,
                 property_key_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param pulumi.Input[str] url: URL string for a Splunk instance or external system data link target.
        :param pulumi.Input[str] minimum_time_window: The minimum time window for a search sent to an external site. Depends on the value set for `time_format`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
        :param pulumi.Input[str] time_format: Designates the format of minimumTimeWindow in the same data link target object.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if minimum_time_window is not None:
            pulumi.set(__self__, "minimum_time_window", minimum_time_window)
        if property_key_mapping is not None:
            pulumi.set(__self__, "property_key_mapping", property_key_mapping)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL string for a Splunk instance or external system data link target.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="minimumTimeWindow")
    def minimum_time_window(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum time window for a search sent to an external site. Depends on the value set for `time_format`.
        """
        return pulumi.get(self, "minimum_time_window")

    @minimum_time_window.setter
    def minimum_time_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_time_window", value)

    @property
    @pulumi.getter(name="propertyKeyMapping")
    def property_key_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
        """
        return pulumi.get(self, "property_key_mapping")

    @property_key_mapping.setter
    def property_key_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "property_key_mapping", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        Designates the format of minimumTimeWindow in the same data link target object.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)


@pulumi.input_type
class DataLinkTargetSignalfxDashboardArgs:
    def __init__(__self__, *,
                 dashboard_group_id: pulumi.Input[str],
                 dashboard_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 is_default: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] dashboard_group_id: SignalFx-assigned ID of the dashboard link target's dashboard group
        :param pulumi.Input[str] dashboard_id: SignalFx-assigned ID of the dashboard link target
        :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param pulumi.Input[bool] is_default: Flag that designates a target as the default for a data link object.
        """
        pulumi.set(__self__, "dashboard_group_id", dashboard_group_id)
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        pulumi.set(__self__, "name", name)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)

    @property
    @pulumi.getter(name="dashboardGroupId")
    def dashboard_group_id(self) -> pulumi.Input[str]:
        """
        SignalFx-assigned ID of the dashboard link target's dashboard group
        """
        return pulumi.get(self, "dashboard_group_id")

    @dashboard_group_id.setter
    def dashboard_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_group_id", value)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> pulumi.Input[str]:
        """
        SignalFx-assigned ID of the dashboard link target
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that designates a target as the default for a data link object.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)


@pulumi.input_type
class DataLinkTargetSplunkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 property_key_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
        """
        pulumi.set(__self__, "name", name)
        if property_key_mapping is not None:
            pulumi.set(__self__, "property_key_mapping", property_key_mapping)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="propertyKeyMapping")
    def property_key_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
        """
        return pulumi.get(self, "property_key_mapping")

    @property_key_mapping.setter
    def property_key_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "property_key_mapping", value)


@pulumi.input_type
class DetectorRuleArgs:
    def __init__(__self__, *,
                 detect_label: pulumi.Input[str],
                 severity: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parameterized_body: Optional[pulumi.Input[str]] = None,
                 parameterized_subject: Optional[pulumi.Input[str]] = None,
                 runbook_url: Optional[pulumi.Input[str]] = None,
                 tip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] detect_label: A detect label which matches a detect label within the program text
        :param pulumi.Input[str] severity: The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
        :param pulumi.Input[str] description: Description of the rule
        :param pulumi.Input[bool] disabled: (default: false) When true, notifications and events will not be generated for the detect label
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
        :param pulumi.Input[str] parameterized_body: Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        :param pulumi.Input[str] parameterized_subject: Custom notification message subject when an alert is triggered. See https://d    evelopers.signalfx.com/v2/reference#detector-model for more info
        :param pulumi.Input[str] runbook_url: URL of page to consult when an alert is triggered
        :param pulumi.Input[str] tip: Plain text suggested first course of action, such as a command to execute.
        """
        pulumi.set(__self__, "detect_label", detect_label)
        pulumi.set(__self__, "severity", severity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if parameterized_body is not None:
            pulumi.set(__self__, "parameterized_body", parameterized_body)
        if parameterized_subject is not None:
            pulumi.set(__self__, "parameterized_subject", parameterized_subject)
        if runbook_url is not None:
            pulumi.set(__self__, "runbook_url", runbook_url)
        if tip is not None:
            pulumi.set(__self__, "tip", tip)

    @property
    @pulumi.getter(name="detectLabel")
    def detect_label(self) -> pulumi.Input[str]:
        """
        A detect label which matches a detect label within the program text
        """
        return pulumi.get(self, "detect_label")

    @detect_label.setter
    def detect_label(self, value: pulumi.Input[str]):
        pulumi.set(self, "detect_label", value)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[str]:
        """
        The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[str]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (default: false) When true, notifications and events will not be generated for the detect label
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notifications", value)

    @property
    @pulumi.getter(name="parameterizedBody")
    def parameterized_body(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        """
        return pulumi.get(self, "parameterized_body")

    @parameterized_body.setter
    def parameterized_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_body", value)

    @property
    @pulumi.getter(name="parameterizedSubject")
    def parameterized_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message subject when an alert is triggered. See https://d    evelopers.signalfx.com/v2/reference#detector-model for more info
        """
        return pulumi.get(self, "parameterized_subject")

    @parameterized_subject.setter
    def parameterized_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_subject", value)

    @property
    @pulumi.getter(name="runbookUrl")
    def runbook_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of page to consult when an alert is triggered
        """
        return pulumi.get(self, "runbook_url")

    @runbook_url.setter
    def runbook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runbook_url", value)

    @property
    @pulumi.getter
    def tip(self) -> Optional[pulumi.Input[str]]:
        """
        Plain text suggested first course of action, such as a command to execute.
        """
        return pulumi.get(self, "tip")

    @tip.setter
    def tip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tip", value)


@pulumi.input_type
class DetectorVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class HeatmapChartColorRangeArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 max_value: Optional[pulumi.Input[float]] = None,
                 min_value: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
        :param pulumi.Input[float] max_value: The maximum value within the coloring range
        :param pulumi.Input[float] min_value: The minimum value within the coloring range
        """
        pulumi.set(__self__, "color", color)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum value within the coloring range
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum value within the coloring range
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_value", value)


@pulumi.input_type
class HeatmapChartColorScaleArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 gt: Optional[pulumi.Input[float]] = None,
                 gte: Optional[pulumi.Input[float]] = None,
                 lt: Optional[pulumi.Input[float]] = None,
                 lte: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range
        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range
        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range
        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def gt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold non-inclusive value for this range
        """
        return pulumi.get(self, "gt")

    @gt.setter
    def gt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gt", value)

    @property
    @pulumi.getter
    def gte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold inclusive value for this range
        """
        return pulumi.get(self, "gte")

    @gte.setter
    def gte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gte", value)

    @property
    @pulumi.getter
    def lt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold non-inculsive value for this range
        """
        return pulumi.get(self, "lt")

    @lt.setter
    def lt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt", value)

    @property
    @pulumi.getter
    def lte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold inclusive value for this range
        """
        return pulumi.get(self, "lte")

    @lte.setter
    def lte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lte", value)


@pulumi.input_type
class ListChartColorScaleArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 gt: Optional[pulumi.Input[float]] = None,
                 gte: Optional[pulumi.Input[float]] = None,
                 lt: Optional[pulumi.Input[float]] = None,
                 lte: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range
        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range
        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range
        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def gt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold non-inclusive value for this range
        """
        return pulumi.get(self, "gt")

    @gt.setter
    def gt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gt", value)

    @property
    @pulumi.getter
    def gte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold inclusive value for this range
        """
        return pulumi.get(self, "gte")

    @gte.setter
    def gte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gte", value)

    @property
    @pulumi.getter
    def lt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold non-inculsive value for this range
        """
        return pulumi.get(self, "lt")

    @lt.setter
    def lt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt", value)

    @property
    @pulumi.getter
    def lte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold inclusive value for this range
        """
        return pulumi.get(self, "lte")

    @lte.setter
    def lte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lte", value)


@pulumi.input_type
class ListChartLegendOptionsFieldArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: The name of a property to hide or show in the data table.
        :param pulumi.Input[bool] enabled: (true by default) Determines if this property is displayed in the data table.
        """
        pulumi.set(__self__, "property", property)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (true by default) Determines if this property is displayed in the data table.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The name of a property to hide or show in the data table.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class ListChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class MetricRulesetAggregationRuleArgs:
    def __init__(__self__, *,
                 aggregators: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]],
                 enabled: pulumi.Input[bool],
                 matchers: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]] aggregators: The aggregator for this rule
        :param pulumi.Input[bool] enabled: Status of this aggregation rule
        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]] matchers: The matcher for this rule
        :param pulumi.Input[str] name: Name of this aggregation rule
        """
        pulumi.set(__self__, "aggregators", aggregators)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "matchers", matchers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def aggregators(self) -> pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]]:
        """
        The aggregator for this rule
        """
        return pulumi.get(self, "aggregators")

    @aggregators.setter
    def aggregators(self, value: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]]):
        pulumi.set(self, "aggregators", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Status of this aggregation rule
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def matchers(self) -> pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]]:
        """
        The matcher for this rule
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of this aggregation rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class MetricRulesetAggregationRuleAggregatorArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 drop_dimensions: pulumi.Input[bool],
                 output_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dimensions: List of dimensions to keep or drop in aggregated metric
        :param pulumi.Input[bool] drop_dimensions: Flag specifying to keep or drop given dimensions
        :param pulumi.Input[str] output_name: The aggregated metric name
        :param pulumi.Input[str] type: The type of the aggregator
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "drop_dimensions", drop_dimensions)
        pulumi.set(__self__, "output_name", output_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of dimensions to keep or drop in aggregated metric
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="dropDimensions")
    def drop_dimensions(self) -> pulumi.Input[bool]:
        """
        Flag specifying to keep or drop given dimensions
        """
        return pulumi.get(self, "drop_dimensions")

    @drop_dimensions.setter
    def drop_dimensions(self, value: pulumi.Input[bool]):
        pulumi.set(self, "drop_dimensions", value)

    @property
    @pulumi.getter(name="outputName")
    def output_name(self) -> pulumi.Input[str]:
        """
        The aggregated metric name
        """
        return pulumi.get(self, "output_name")

    @output_name.setter
    def output_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the aggregator
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MetricRulesetAggregationRuleMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The type of the matcher
        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]] filters: List of filters to match on
        """
        pulumi.set(__self__, "type", type)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the matcher
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]]:
        """
        List of filters to match on
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class MetricRulesetAggregationRuleMatcherFilterArgs:
    def __init__(__self__, *,
                 not_: pulumi.Input[bool],
                 property: pulumi.Input[str],
                 property_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[bool] not_: Flag specifying equals or not equals
        :param pulumi.Input[str] property: Name of dimension to match
        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_values: List of property values to match
        """
        pulumi.set(__self__, "not_", not_)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "property_values", property_values)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> pulumi.Input[bool]:
        """
        Flag specifying equals or not equals
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: pulumi.Input[bool]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of property values to match
        """
        return pulumi.get(self, "property_values")

    @property_values.setter
    def property_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "property_values", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        Name of dimension to match
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class MetricRulesetRoutingRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: Destination to send the input metric
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Destination to send the input metric
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class OrgTokenDpmLimitsArgs:
    def __init__(__self__, *,
                 dpm_limit: pulumi.Input[int],
                 dpm_notification_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] dpm_limit: The datapoints per minute (dpm) limit for this token. If you exceed this limit, Splunk Observability Cloud sends out an alert.
        :param pulumi.Input[int] dpm_notification_threshold: DPM level at which Splunk Observability Cloud sends the notification for this token. If you don't specify a notification, Splunk Observability Cloud sends the generic notification.
        """
        pulumi.set(__self__, "dpm_limit", dpm_limit)
        if dpm_notification_threshold is not None:
            pulumi.set(__self__, "dpm_notification_threshold", dpm_notification_threshold)

    @property
    @pulumi.getter(name="dpmLimit")
    def dpm_limit(self) -> pulumi.Input[int]:
        """
        The datapoints per minute (dpm) limit for this token. If you exceed this limit, Splunk Observability Cloud sends out an alert.
        """
        return pulumi.get(self, "dpm_limit")

    @dpm_limit.setter
    def dpm_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "dpm_limit", value)

    @property
    @pulumi.getter(name="dpmNotificationThreshold")
    def dpm_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        DPM level at which Splunk Observability Cloud sends the notification for this token. If you don't specify a notification, Splunk Observability Cloud sends the generic notification.
        """
        return pulumi.get(self, "dpm_notification_threshold")

    @dpm_notification_threshold.setter
    def dpm_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dpm_notification_threshold", value)


@pulumi.input_type
class OrgTokenHostOrUsageLimitsArgs:
    def __init__(__self__, *,
                 container_limit: Optional[pulumi.Input[int]] = None,
                 container_notification_threshold: Optional[pulumi.Input[int]] = None,
                 custom_metrics_limit: Optional[pulumi.Input[int]] = None,
                 custom_metrics_notification_threshold: Optional[pulumi.Input[int]] = None,
                 high_res_metrics_limit: Optional[pulumi.Input[int]] = None,
                 high_res_metrics_notification_threshold: Optional[pulumi.Input[int]] = None,
                 host_limit: Optional[pulumi.Input[int]] = None,
                 host_notification_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] container_limit: Max number of containers that can use this token
        :param pulumi.Input[int] container_notification_threshold: Notification threshold for containers
        :param pulumi.Input[int] custom_metrics_limit: Max number of custom metrics that can be sent with this token
        :param pulumi.Input[int] custom_metrics_notification_threshold: Notification threshold for custom metrics
        :param pulumi.Input[int] high_res_metrics_limit: Max number of high-res metrics that can be sent with this token
        :param pulumi.Input[int] high_res_metrics_notification_threshold: Notification threshold for high-res metrics
        :param pulumi.Input[int] host_limit: Max number of hosts that can use this token
        :param pulumi.Input[int] host_notification_threshold: Notification threshold for hosts
        """
        if container_limit is not None:
            pulumi.set(__self__, "container_limit", container_limit)
        if container_notification_threshold is not None:
            pulumi.set(__self__, "container_notification_threshold", container_notification_threshold)
        if custom_metrics_limit is not None:
            pulumi.set(__self__, "custom_metrics_limit", custom_metrics_limit)
        if custom_metrics_notification_threshold is not None:
            pulumi.set(__self__, "custom_metrics_notification_threshold", custom_metrics_notification_threshold)
        if high_res_metrics_limit is not None:
            pulumi.set(__self__, "high_res_metrics_limit", high_res_metrics_limit)
        if high_res_metrics_notification_threshold is not None:
            pulumi.set(__self__, "high_res_metrics_notification_threshold", high_res_metrics_notification_threshold)
        if host_limit is not None:
            pulumi.set(__self__, "host_limit", host_limit)
        if host_notification_threshold is not None:
            pulumi.set(__self__, "host_notification_threshold", host_notification_threshold)

    @property
    @pulumi.getter(name="containerLimit")
    def container_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of containers that can use this token
        """
        return pulumi.get(self, "container_limit")

    @container_limit.setter
    def container_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_limit", value)

    @property
    @pulumi.getter(name="containerNotificationThreshold")
    def container_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for containers
        """
        return pulumi.get(self, "container_notification_threshold")

    @container_notification_threshold.setter
    def container_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_notification_threshold", value)

    @property
    @pulumi.getter(name="customMetricsLimit")
    def custom_metrics_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of custom metrics that can be sent with this token
        """
        return pulumi.get(self, "custom_metrics_limit")

    @custom_metrics_limit.setter
    def custom_metrics_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_metrics_limit", value)

    @property
    @pulumi.getter(name="customMetricsNotificationThreshold")
    def custom_metrics_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for custom metrics
        """
        return pulumi.get(self, "custom_metrics_notification_threshold")

    @custom_metrics_notification_threshold.setter
    def custom_metrics_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_metrics_notification_threshold", value)

    @property
    @pulumi.getter(name="highResMetricsLimit")
    def high_res_metrics_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of high-res metrics that can be sent with this token
        """
        return pulumi.get(self, "high_res_metrics_limit")

    @high_res_metrics_limit.setter
    def high_res_metrics_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "high_res_metrics_limit", value)

    @property
    @pulumi.getter(name="highResMetricsNotificationThreshold")
    def high_res_metrics_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for high-res metrics
        """
        return pulumi.get(self, "high_res_metrics_notification_threshold")

    @high_res_metrics_notification_threshold.setter
    def high_res_metrics_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "high_res_metrics_notification_threshold", value)

    @property
    @pulumi.getter(name="hostLimit")
    def host_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of hosts that can use this token
        """
        return pulumi.get(self, "host_limit")

    @host_limit.setter
    def host_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "host_limit", value)

    @property
    @pulumi.getter(name="hostNotificationThreshold")
    def host_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for hosts
        """
        return pulumi.get(self, "host_notification_threshold")

    @host_notification_threshold.setter
    def host_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "host_notification_threshold", value)


@pulumi.input_type
class SingleValueChartColorScaleArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 gt: Optional[pulumi.Input[float]] = None,
                 gte: Optional[pulumi.Input[float]] = None,
                 lt: Optional[pulumi.Input[float]] = None,
                 lte: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range
        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range
        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range
        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def gt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold non-inclusive value for this range
        """
        return pulumi.get(self, "gt")

    @gt.setter
    def gt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gt", value)

    @property
    @pulumi.getter
    def gte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold inclusive value for this range
        """
        return pulumi.get(self, "gte")

    @gte.setter
    def gte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gte", value)

    @property
    @pulumi.getter
    def lt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold non-inculsive value for this range
        """
        return pulumi.get(self, "lt")

    @lt.setter
    def lt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt", value)

    @property
    @pulumi.getter
    def lte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold inclusive value for this range
        """
        return pulumi.get(self, "lte")

    @lte.setter
    def lte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lte", value)


@pulumi.input_type
class SingleValueChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class TableChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class TimeChartAxisLeftArgs:
    def __init__(__self__, *,
                 high_watermark: Optional[pulumi.Input[float]] = None,
                 high_watermark_label: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 low_watermark: Optional[pulumi.Input[float]] = None,
                 low_watermark_label: Optional[pulumi.Input[str]] = None,
                 max_value: Optional[pulumi.Input[float]] = None,
                 min_value: Optional[pulumi.Input[float]] = None,
                 watermarks: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]] = None):
        """
        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark
        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line
        :param pulumi.Input[str] label: Label of the left axis
        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark
        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line
        :param pulumi.Input[float] max_value: The maximum value for the left axis
        :param pulumi.Input[float] min_value: The minimum value for the left axis
        """
        if high_watermark is not None:
            pulumi.set(__self__, "high_watermark", high_watermark)
        if high_watermark_label is not None:
            pulumi.set(__self__, "high_watermark_label", high_watermark_label)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if low_watermark is not None:
            pulumi.set(__self__, "low_watermark", low_watermark)
        if low_watermark_label is not None:
            pulumi.set(__self__, "low_watermark_label", low_watermark_label)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if watermarks is not None:
            pulumi.set(__self__, "watermarks", watermarks)

    @property
    @pulumi.getter(name="highWatermark")
    def high_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a high watermark
        """
        return pulumi.get(self, "high_watermark")

    @high_watermark.setter
    def high_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "high_watermark", value)

    @property
    @pulumi.getter(name="highWatermarkLabel")
    def high_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the high watermark line
        """
        return pulumi.get(self, "high_watermark_label")

    @high_watermark_label.setter
    def high_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high_watermark_label", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label of the left axis
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="lowWatermark")
    def low_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a low watermark
        """
        return pulumi.get(self, "low_watermark")

    @low_watermark.setter
    def low_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "low_watermark", value)

    @property
    @pulumi.getter(name="lowWatermarkLabel")
    def low_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the low watermark line
        """
        return pulumi.get(self, "low_watermark_label")

    @low_watermark_label.setter
    def low_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "low_watermark_label", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum value for the left axis
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum value for the left axis
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter
    def watermarks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]]:
        return pulumi.get(self, "watermarks")

    @watermarks.setter
    def watermarks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]]):
        pulumi.set(self, "watermarks", value)


@pulumi.input_type
class TimeChartAxisLeftWatermarkArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float],
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] value: Axis value where the watermark line will be displayed
        :param pulumi.Input[str] label: Label to display associated with the watermark line
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Axis value where the watermark line will be displayed
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label to display associated with the watermark line
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class TimeChartAxisRightArgs:
    def __init__(__self__, *,
                 high_watermark: Optional[pulumi.Input[float]] = None,
                 high_watermark_label: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 low_watermark: Optional[pulumi.Input[float]] = None,
                 low_watermark_label: Optional[pulumi.Input[str]] = None,
                 max_value: Optional[pulumi.Input[float]] = None,
                 min_value: Optional[pulumi.Input[float]] = None,
                 watermarks: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]] = None):
        """
        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark
        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line
        :param pulumi.Input[str] label: Label of the right axis
        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark
        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line
        :param pulumi.Input[float] max_value: The maximum value for the right axis
        :param pulumi.Input[float] min_value: The minimum value for the right axis
        """
        if high_watermark is not None:
            pulumi.set(__self__, "high_watermark", high_watermark)
        if high_watermark_label is not None:
            pulumi.set(__self__, "high_watermark_label", high_watermark_label)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if low_watermark is not None:
            pulumi.set(__self__, "low_watermark", low_watermark)
        if low_watermark_label is not None:
            pulumi.set(__self__, "low_watermark_label", low_watermark_label)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if watermarks is not None:
            pulumi.set(__self__, "watermarks", watermarks)

    @property
    @pulumi.getter(name="highWatermark")
    def high_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a high watermark
        """
        return pulumi.get(self, "high_watermark")

    @high_watermark.setter
    def high_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "high_watermark", value)

    @property
    @pulumi.getter(name="highWatermarkLabel")
    def high_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the high watermark line
        """
        return pulumi.get(self, "high_watermark_label")

    @high_watermark_label.setter
    def high_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high_watermark_label", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label of the right axis
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="lowWatermark")
    def low_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a low watermark
        """
        return pulumi.get(self, "low_watermark")

    @low_watermark.setter
    def low_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "low_watermark", value)

    @property
    @pulumi.getter(name="lowWatermarkLabel")
    def low_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the low watermark line
        """
        return pulumi.get(self, "low_watermark_label")

    @low_watermark_label.setter
    def low_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "low_watermark_label", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum value for the right axis
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum value for the right axis
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter
    def watermarks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]]:
        return pulumi.get(self, "watermarks")

    @watermarks.setter
    def watermarks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]]):
        pulumi.set(self, "watermarks", value)


@pulumi.input_type
class TimeChartAxisRightWatermarkArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float],
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] value: Axis value where the watermark line will be displayed
        :param pulumi.Input[str] label: Label to display associated with the watermark line
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Axis value where the watermark line will be displayed
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label to display associated with the watermark line
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class TimeChartEventOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the events you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the events you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class TimeChartHistogramOptionArgs:
    def __init__(__self__, *,
                 color_theme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] color_theme: Base color theme to use for the graph.
        """
        if color_theme is not None:
            pulumi.set(__self__, "color_theme", color_theme)

    @property
    @pulumi.getter(name="colorTheme")
    def color_theme(self) -> Optional[pulumi.Input[str]]:
        """
        Base color theme to use for the graph.
        """
        return pulumi.get(self, "color_theme")

    @color_theme.setter
    def color_theme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_theme", value)


@pulumi.input_type
class TimeChartLegendOptionsFieldArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: The name of a property to hide or show in the data table.
        :param pulumi.Input[bool] enabled: (true by default) Determines if this property is displayed in the data table.
        """
        pulumi.set(__self__, "property", property)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (true by default) Determines if this property is displayed in the data table.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The name of a property to hide or show in the data table.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class TimeChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 axis: Optional[pulumi.Input[str]] = None,
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 plot_type: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] axis: The Y-axis associated with values for this plot. Must be either "right" or "left". Defaults to "left".
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] plot_type: (Chart plot_type by default) The visualization style to use. Must be "LineChart", "AreaChart", "ColumnChart", or "Histogram"
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if axis is not None:
            pulumi.set(__self__, "axis", axis)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if plot_type is not None:
            pulumi.set(__self__, "plot_type", plot_type)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def axis(self) -> Optional[pulumi.Input[str]]:
        """
        The Y-axis associated with values for this plot. Must be either "right" or "left". Defaults to "left".
        """
        return pulumi.get(self, "axis")

    @axis.setter
    def axis(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "axis", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="plotType")
    def plot_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Chart plot_type by default) The visualization style to use. Must be "LineChart", "AreaChart", "ColumnChart", or "Histogram"
        """
        return pulumi.get(self, "plot_type")

    @plot_type.setter
    def plot_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plot_type", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class WebhookIntegrationHeaderArgs:
    def __init__(__self__, *,
                 header_key: pulumi.Input[str],
                 header_value: pulumi.Input[str]):
        pulumi.set(__self__, "header_key", header_key)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerKey")
    def header_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_key")

    @header_key.setter
    def header_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_key", value)

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_value", value)


