# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AlertMutingRuleFilterArgs',
    'DashboardChartArgs',
    'DashboardColumnArgs',
    'DashboardEventOverlayArgs',
    'DashboardEventOverlaySourceArgs',
    'DashboardFilterArgs',
    'DashboardGridArgs',
    'DashboardGroupDashboardArgs',
    'DashboardGroupDashboardFilterOverrideArgs',
    'DashboardGroupDashboardVariableOverrideArgs',
    'DashboardGroupImportQualifierArgs',
    'DashboardGroupImportQualifierFilterArgs',
    'DashboardGroupPermissionArgs',
    'DashboardPermissionsArgs',
    'DashboardPermissionsAclArgs',
    'DashboardSelectedEventOverlayArgs',
    'DashboardSelectedEventOverlaySourceArgs',
    'DashboardVariableArgs',
    'DataLinkTargetExternalUrlArgs',
    'DataLinkTargetSignalfxDashboardArgs',
    'DataLinkTargetSplunkArgs',
    'DetectorRuleArgs',
    'DetectorVizOptionArgs',
    'HeatmapChartColorRangeArgs',
    'HeatmapChartColorScaleArgs',
    'ListChartColorScaleArgs',
    'ListChartLegendOptionsFieldArgs',
    'ListChartVizOptionArgs',
    'MetricRulesetAggregationRuleArgs',
    'MetricRulesetAggregationRuleAggregatorArgs',
    'MetricRulesetAggregationRuleMatcherArgs',
    'MetricRulesetAggregationRuleMatcherFilterArgs',
    'MetricRulesetRoutingRuleArgs',
    'OrgTokenDpmLimitsArgs',
    'OrgTokenHostOrUsageLimitsArgs',
    'SingleValueChartColorScaleArgs',
    'SingleValueChartVizOptionArgs',
    'SloInputArgs',
    'SloTargetArgs',
    'SloTargetAlertRuleArgs',
    'SloTargetAlertRuleRuleArgs',
    'SloTargetAlertRuleRuleParametersArgs',
    'TableChartVizOptionArgs',
    'TimeChartAxisLeftArgs',
    'TimeChartAxisLeftWatermarkArgs',
    'TimeChartAxisRightArgs',
    'TimeChartAxisRightWatermarkArgs',
    'TimeChartEventOptionArgs',
    'TimeChartHistogramOptionArgs',
    'TimeChartLegendOptionsFieldArgs',
    'TimeChartVizOptionArgs',
    'WebhookIntegrationHeaderArgs',
]

@pulumi.input_type
class AlertMutingRuleFilterArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 property_value: pulumi.Input[str],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: the property to filter by
        :param pulumi.Input[str] property_value: the value of the property to filter by
        :param pulumi.Input[bool] negated: (false by default) whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "property_value", property_value)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> pulumi.Input[str]:
        """
        the value of the property to filter by
        """
        return pulumi.get(self, "property_value")

    @property_value.setter
    def property_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "property_value", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        the property to filter by
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardChartArgs:
    def __init__(__self__, *,
                 chart_id: pulumi.Input[str],
                 column: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 row: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] chart_id: ID of the chart to display
        :param pulumi.Input[int] column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
        :param pulumi.Input[int] height: How many rows the chart should take up. (greater than or equal to 1)
        :param pulumi.Input[int] row: The row to show the chart in (zero-based); if height > 1, this value represents the topmost row of the chart. (greater than or equal to 0)
        :param pulumi.Input[int] width: How many columns (out of a total of 12, one-based) the chart should take up. (between 1 and 12)
        """
        pulumi.set(__self__, "chart_id", chart_id)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if row is not None:
            pulumi.set(__self__, "row", row)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartId")
    def chart_id(self) -> pulumi.Input[str]:
        """
        ID of the chart to display
        """
        return pulumi.get(self, "chart_id")

    @chart_id.setter
    def chart_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "chart_id", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[int]]:
        """
        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows the chart should take up. (greater than or equal to 1)
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def row(self) -> Optional[pulumi.Input[int]]:
        """
        The row to show the chart in (zero-based); if height > 1, this value represents the topmost row of the chart. (greater than or equal to 0)
        """
        return pulumi.get(self, "row")

    @row.setter
    def row(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "row", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        How many columns (out of a total of 12, one-based) the chart should take up. (between 1 and 12)
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardColumnArgs:
    def __init__(__self__, *,
                 chart_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 column: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: Charts to use for the column
        :param pulumi.Input[int] column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
        :param pulumi.Input[int] height: How many rows each chart should take up. (greater than or equal to 1)
        :param pulumi.Input[int] width: Number of columns (out of a total of 12) each chart should take up. (between 1 and 12)
        """
        pulumi.set(__self__, "chart_ids", chart_ids)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartIds")
    def chart_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Charts to use for the column
        """
        return pulumi.get(self, "chart_ids")

    @chart_ids.setter
    def chart_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "chart_ids", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[int]]:
        """
        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows each chart should take up. (greater than or equal to 1)
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        Number of columns (out of a total of 12) each chart should take up. (between 1 and 12)
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardEventOverlayArgs:
    def __init__(__self__, *,
                 signal: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 line: Optional[pulumi.Input[bool]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] signal: Search term used to define events
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] label: The text displaying in the dropdown menu used to select this event overlay as an active overlay for the dashboard.
        :param pulumi.Input[bool] line: (false by default) Whether a vertical line should be displayed in the plot at the time the event occurs
        :param pulumi.Input[str] type: Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
        """
        pulumi.set(__self__, "signal", signal)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if line is not None:
            pulumi.set(__self__, "line", line)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def signal(self) -> pulumi.Input[str]:
        """
        Search term used to define events
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: pulumi.Input[str]):
        pulumi.set(self, "signal", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The text displaying in the dropdown menu used to select this event overlay as an active overlay for the dashboard.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def line(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether a vertical line should be displayed in the plot at the time the event occurs
        """
        return pulumi.get(self, "line")

    @line.setter
    def line(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "line", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]]:
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DashboardEventOverlaySourceArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardFilterArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 apply_if_exist: Optional[pulumi.Input[bool]] = None,
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] apply_if_exist: If true, this filter will also match data that does not have the specified property
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if apply_if_exist is not None:
            pulumi.set(__self__, "apply_if_exist", apply_if_exist)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="applyIfExist")
    def apply_if_exist(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this filter will also match data that does not have the specified property
        """
        return pulumi.get(self, "apply_if_exist")

    @apply_if_exist.setter
    def apply_if_exist(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_if_exist", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGridArgs:
    def __init__(__self__, *,
                 chart_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 height: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: Charts to use for the grid
        :param pulumi.Input[int] height: How many rows each chart should take up. (greater than or equal to 1)
        :param pulumi.Input[int] width: Number of columns (out of a total of 12, one-based) each chart should take up. (between 1 and 12)
        """
        pulumi.set(__self__, "chart_ids", chart_ids)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartIds")
    def chart_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Charts to use for the grid
        """
        return pulumi.get(self, "chart_ids")

    @chart_ids.setter
    def chart_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "chart_ids", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows each chart should take up. (greater than or equal to 1)
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        Number of columns (out of a total of 12, one-based) each chart should take up. (between 1 and 12)
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardGroupDashboardArgs:
    def __init__(__self__, *,
                 dashboard_id: pulumi.Input[str],
                 config_id: Optional[pulumi.Input[str]] = None,
                 description_override: Optional[pulumi.Input[str]] = None,
                 filter_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]] = None,
                 name_override: Optional[pulumi.Input[str]] = None,
                 variable_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]] = None):
        """
        :param pulumi.Input[str] dashboard_id: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] config_id: Unique identifier of an association between a dashboard group and a dashboard
        :param pulumi.Input[str] description_override: String that provides a description override for a mirrored dashboard
        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]] filter_overrides: Filter to apply to each chart in the dashboard
        :param pulumi.Input[str] name_override: String that provides a name override for a mirrored dashboard
        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]] variable_overrides: Dashboard variable to apply to each chart in the dashboard
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if config_id is not None:
            pulumi.set(__self__, "config_id", config_id)
        if description_override is not None:
            pulumi.set(__self__, "description_override", description_override)
        if filter_overrides is not None:
            pulumi.set(__self__, "filter_overrides", filter_overrides)
        if name_override is not None:
            pulumi.set(__self__, "name_override", name_override)
        if variable_overrides is not None:
            pulumi.set(__self__, "variable_overrides", variable_overrides)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of an association between a dashboard group and a dashboard
        """
        return pulumi.get(self, "config_id")

    @config_id.setter
    def config_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_id", value)

    @property
    @pulumi.getter(name="descriptionOverride")
    def description_override(self) -> Optional[pulumi.Input[str]]:
        """
        String that provides a description override for a mirrored dashboard
        """
        return pulumi.get(self, "description_override")

    @description_override.setter
    def description_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description_override", value)

    @property
    @pulumi.getter(name="filterOverrides")
    def filter_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]]:
        """
        Filter to apply to each chart in the dashboard
        """
        return pulumi.get(self, "filter_overrides")

    @filter_overrides.setter
    def filter_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]]):
        pulumi.set(self, "filter_overrides", value)

    @property
    @pulumi.getter(name="nameOverride")
    def name_override(self) -> Optional[pulumi.Input[str]]:
        """
        String that provides a name override for a mirrored dashboard
        """
        return pulumi.get(self, "name_override")

    @name_override.setter
    def name_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_override", value)

    @property
    @pulumi.getter(name="variableOverrides")
    def variable_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]]:
        """
        Dashboard variable to apply to each chart in the dashboard
        """
        return pulumi.get(self, "variable_overrides")

    @variable_overrides.setter
    def variable_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]]):
        pulumi.set(self, "variable_overrides", value)


@pulumi.input_type
class DashboardGroupDashboardFilterOverrideArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGroupDashboardVariableOverrideArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values_suggesteds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        pulumi.set(__self__, "property", property)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if values_suggesteds is not None:
            pulumi.set(__self__, "values_suggesteds", values_suggesteds)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="valuesSuggesteds")
    def values_suggesteds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        return pulumi.get(self, "values_suggesteds")

    @values_suggesteds.setter
    def values_suggesteds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values_suggesteds", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGroupImportQualifierArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]] filters: Filter to apply to each chart in the dashboard
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]]]:
        """
        Filter to apply to each chart in the dashboard
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardGroupImportQualifierFilterArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGroupPermissionArgs:
    def __init__(__self__, *,
                 principal_id: pulumi.Input[str],
                 principal_type: pulumi.Input[str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] principal_id: ID of the principal with access
        :param pulumi.Input[str] principal_type: Type of principal, possible values: ORG, TEAM, USER
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Actions level, possible values: READ, WRITE
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "principal_type", principal_type)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> pulumi.Input[str]:
        """
        ID of the principal with access
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> pulumi.Input[str]:
        """
        Type of principal, possible values: ORG, TEAM, USER
        """
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_type", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Actions level, possible values: READ, WRITE
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class DashboardPermissionsArgs:
    def __init__(__self__, *,
                 acls: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]] = None,
                 parent: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]] acls: The custom access control list for this dashboard
        :param pulumi.Input[str] parent: The ID of the dashboard group that this dashboard inherits permissions from
        """
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if parent is not None:
            pulumi.set(__self__, "parent", parent)

    @property
    @pulumi.getter
    def acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]]:
        """
        The custom access control list for this dashboard
        """
        return pulumi.get(self, "acls")

    @acls.setter
    def acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]]):
        pulumi.set(self, "acls", value)

    @property
    @pulumi.getter
    def parent(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the dashboard group that this dashboard inherits permissions from
        """
        return pulumi.get(self, "parent")

    @parent.setter
    def parent(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent", value)


@pulumi.input_type
class DashboardPermissionsAclArgs:
    def __init__(__self__, *,
                 principal_id: pulumi.Input[str],
                 principal_type: pulumi.Input[str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] principal_id: ID of the principal with access
        :param pulumi.Input[str] principal_type: Type of principal, possible values: ORG, TEAM, USER
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Actions level, possible values: READ, WRITE
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "principal_type", principal_type)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> pulumi.Input[str]:
        """
        ID of the principal with access
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> pulumi.Input[str]:
        """
        Type of principal, possible values: ORG, TEAM, USER
        """
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_type", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Actions level, possible values: READ, WRITE
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class DashboardSelectedEventOverlayArgs:
    def __init__(__self__, *,
                 signal: pulumi.Input[str],
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] signal: Search term used to define events
        :param pulumi.Input[str] type: Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
        """
        pulumi.set(__self__, "signal", signal)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def signal(self) -> pulumi.Input[str]:
        """
        Search term used to define events
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: pulumi.Input[str]):
        pulumi.set(self, "signal", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]]:
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DashboardSelectedEventOverlaySourceArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardVariableArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[str],
                 property: pulumi.Input[str],
                 apply_if_exist: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 replace_only: Optional[pulumi.Input[bool]] = None,
                 restricted_suggestions: Optional[pulumi.Input[bool]] = None,
                 value_required: Optional[pulumi.Input[bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values_suggesteds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] alias: An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[bool] apply_if_exist: If true, this variable will also match data that does not have the specified property
        :param pulumi.Input[str] description: Variable description
        :param pulumi.Input[bool] replace_only: If true, this variable will only apply to charts with a filter on the named property.
        :param pulumi.Input[bool] restricted_suggestions: If true, this variable may only be set to the values listed in preferredSuggestions. and only these values will appear in autosuggestion menus. false by default
        :param pulumi.Input[bool] value_required: Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). false by default
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "property", property)
        if apply_if_exist is not None:
            pulumi.set(__self__, "apply_if_exist", apply_if_exist)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if replace_only is not None:
            pulumi.set(__self__, "replace_only", replace_only)
        if restricted_suggestions is not None:
            pulumi.set(__self__, "restricted_suggestions", restricted_suggestions)
        if value_required is not None:
            pulumi.set(__self__, "value_required", value_required)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if values_suggesteds is not None:
            pulumi.set(__self__, "values_suggesteds", values_suggesteds)

    @property
    @pulumi.getter
    def alias(self) -> pulumi.Input[str]:
        """
        An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[str]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="applyIfExist")
    def apply_if_exist(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this variable will also match data that does not have the specified property
        """
        return pulumi.get(self, "apply_if_exist")

    @apply_if_exist.setter
    def apply_if_exist(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_if_exist", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Variable description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="replaceOnly")
    def replace_only(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this variable will only apply to charts with a filter on the named property.
        """
        return pulumi.get(self, "replace_only")

    @replace_only.setter
    def replace_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "replace_only", value)

    @property
    @pulumi.getter(name="restrictedSuggestions")
    def restricted_suggestions(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this variable may only be set to the values listed in preferredSuggestions. and only these values will appear in autosuggestion menus. false by default
        """
        return pulumi.get(self, "restricted_suggestions")

    @restricted_suggestions.setter
    def restricted_suggestions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restricted_suggestions", value)

    @property
    @pulumi.getter(name="valueRequired")
    def value_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). false by default
        """
        return pulumi.get(self, "value_required")

    @value_required.setter
    def value_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "value_required", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="valuesSuggesteds")
    def values_suggesteds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        return pulumi.get(self, "values_suggesteds")

    @values_suggesteds.setter
    def values_suggesteds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values_suggesteds", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DataLinkTargetExternalUrlArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 minimum_time_window: Optional[pulumi.Input[str]] = None,
                 property_key_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param pulumi.Input[str] url: URL string for a Splunk instance or external system data link target.
        :param pulumi.Input[str] minimum_time_window: The minimum time window for a search sent to an external site. Depends on the value set for `time_format`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
        :param pulumi.Input[str] time_format: Designates the format of minimumTimeWindow in the same data link target object.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if minimum_time_window is not None:
            pulumi.set(__self__, "minimum_time_window", minimum_time_window)
        if property_key_mapping is not None:
            pulumi.set(__self__, "property_key_mapping", property_key_mapping)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL string for a Splunk instance or external system data link target.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="minimumTimeWindow")
    def minimum_time_window(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum time window for a search sent to an external site. Depends on the value set for `time_format`.
        """
        return pulumi.get(self, "minimum_time_window")

    @minimum_time_window.setter
    def minimum_time_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_time_window", value)

    @property
    @pulumi.getter(name="propertyKeyMapping")
    def property_key_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
        """
        return pulumi.get(self, "property_key_mapping")

    @property_key_mapping.setter
    def property_key_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "property_key_mapping", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        Designates the format of minimumTimeWindow in the same data link target object.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)


@pulumi.input_type
class DataLinkTargetSignalfxDashboardArgs:
    def __init__(__self__, *,
                 dashboard_group_id: pulumi.Input[str],
                 dashboard_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 is_default: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] dashboard_group_id: SignalFx-assigned ID of the dashboard link target's dashboard group
        :param pulumi.Input[str] dashboard_id: SignalFx-assigned ID of the dashboard link target
        :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param pulumi.Input[bool] is_default: Flag that designates a target as the default for a data link object.
        """
        pulumi.set(__self__, "dashboard_group_id", dashboard_group_id)
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        pulumi.set(__self__, "name", name)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)

    @property
    @pulumi.getter(name="dashboardGroupId")
    def dashboard_group_id(self) -> pulumi.Input[str]:
        """
        SignalFx-assigned ID of the dashboard link target's dashboard group
        """
        return pulumi.get(self, "dashboard_group_id")

    @dashboard_group_id.setter
    def dashboard_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_group_id", value)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> pulumi.Input[str]:
        """
        SignalFx-assigned ID of the dashboard link target
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that designates a target as the default for a data link object.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)


@pulumi.input_type
class DataLinkTargetSplunkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 property_key_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
        """
        pulumi.set(__self__, "name", name)
        if property_key_mapping is not None:
            pulumi.set(__self__, "property_key_mapping", property_key_mapping)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="propertyKeyMapping")
    def property_key_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
        """
        return pulumi.get(self, "property_key_mapping")

    @property_key_mapping.setter
    def property_key_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "property_key_mapping", value)


@pulumi.input_type
class DetectorRuleArgs:
    def __init__(__self__, *,
                 detect_label: pulumi.Input[str],
                 severity: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parameterized_body: Optional[pulumi.Input[str]] = None,
                 parameterized_subject: Optional[pulumi.Input[str]] = None,
                 runbook_url: Optional[pulumi.Input[str]] = None,
                 tip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] detect_label: A detect label which matches a detect label within the program text
        :param pulumi.Input[str] severity: The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
        :param pulumi.Input[str] description: Description of the rule
        :param pulumi.Input[bool] disabled: (default: false) When true, notifications and events will not be generated for the detect label
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
        :param pulumi.Input[str] parameterized_body: Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        :param pulumi.Input[str] parameterized_subject: Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        :param pulumi.Input[str] runbook_url: URL of page to consult when an alert is triggered
        :param pulumi.Input[str] tip: Plain text suggested first course of action, such as a command to execute.
        """
        pulumi.set(__self__, "detect_label", detect_label)
        pulumi.set(__self__, "severity", severity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if parameterized_body is not None:
            pulumi.set(__self__, "parameterized_body", parameterized_body)
        if parameterized_subject is not None:
            pulumi.set(__self__, "parameterized_subject", parameterized_subject)
        if runbook_url is not None:
            pulumi.set(__self__, "runbook_url", runbook_url)
        if tip is not None:
            pulumi.set(__self__, "tip", tip)

    @property
    @pulumi.getter(name="detectLabel")
    def detect_label(self) -> pulumi.Input[str]:
        """
        A detect label which matches a detect label within the program text
        """
        return pulumi.get(self, "detect_label")

    @detect_label.setter
    def detect_label(self, value: pulumi.Input[str]):
        pulumi.set(self, "detect_label", value)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[str]:
        """
        The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[str]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (default: false) When true, notifications and events will not be generated for the detect label
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notifications", value)

    @property
    @pulumi.getter(name="parameterizedBody")
    def parameterized_body(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        """
        return pulumi.get(self, "parameterized_body")

    @parameterized_body.setter
    def parameterized_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_body", value)

    @property
    @pulumi.getter(name="parameterizedSubject")
    def parameterized_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        """
        return pulumi.get(self, "parameterized_subject")

    @parameterized_subject.setter
    def parameterized_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_subject", value)

    @property
    @pulumi.getter(name="runbookUrl")
    def runbook_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of page to consult when an alert is triggered
        """
        return pulumi.get(self, "runbook_url")

    @runbook_url.setter
    def runbook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runbook_url", value)

    @property
    @pulumi.getter
    def tip(self) -> Optional[pulumi.Input[str]]:
        """
        Plain text suggested first course of action, such as a command to execute.
        """
        return pulumi.get(self, "tip")

    @tip.setter
    def tip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tip", value)


@pulumi.input_type
class DetectorVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class HeatmapChartColorRangeArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 max_value: Optional[pulumi.Input[float]] = None,
                 min_value: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
        :param pulumi.Input[float] max_value: The maximum value within the coloring range
        :param pulumi.Input[float] min_value: The minimum value within the coloring range
        """
        pulumi.set(__self__, "color", color)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum value within the coloring range
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum value within the coloring range
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_value", value)


@pulumi.input_type
class HeatmapChartColorScaleArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 gt: Optional[pulumi.Input[float]] = None,
                 gte: Optional[pulumi.Input[float]] = None,
                 lt: Optional[pulumi.Input[float]] = None,
                 lte: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range
        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range
        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range
        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def gt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold non-inclusive value for this range
        """
        return pulumi.get(self, "gt")

    @gt.setter
    def gt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gt", value)

    @property
    @pulumi.getter
    def gte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold inclusive value for this range
        """
        return pulumi.get(self, "gte")

    @gte.setter
    def gte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gte", value)

    @property
    @pulumi.getter
    def lt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold non-inculsive value for this range
        """
        return pulumi.get(self, "lt")

    @lt.setter
    def lt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt", value)

    @property
    @pulumi.getter
    def lte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold inclusive value for this range
        """
        return pulumi.get(self, "lte")

    @lte.setter
    def lte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lte", value)


@pulumi.input_type
class ListChartColorScaleArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 gt: Optional[pulumi.Input[float]] = None,
                 gte: Optional[pulumi.Input[float]] = None,
                 lt: Optional[pulumi.Input[float]] = None,
                 lte: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range
        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range
        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range
        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def gt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold non-inclusive value for this range
        """
        return pulumi.get(self, "gt")

    @gt.setter
    def gt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gt", value)

    @property
    @pulumi.getter
    def gte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold inclusive value for this range
        """
        return pulumi.get(self, "gte")

    @gte.setter
    def gte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gte", value)

    @property
    @pulumi.getter
    def lt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold non-inculsive value for this range
        """
        return pulumi.get(self, "lt")

    @lt.setter
    def lt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt", value)

    @property
    @pulumi.getter
    def lte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold inclusive value for this range
        """
        return pulumi.get(self, "lte")

    @lte.setter
    def lte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lte", value)


@pulumi.input_type
class ListChartLegendOptionsFieldArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: The name of a property to hide or show in the data table.
        :param pulumi.Input[bool] enabled: (true by default) Determines if this property is displayed in the data table.
        """
        pulumi.set(__self__, "property", property)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (true by default) Determines if this property is displayed in the data table.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The name of a property to hide or show in the data table.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class ListChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class MetricRulesetAggregationRuleArgs:
    def __init__(__self__, *,
                 aggregators: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]],
                 enabled: pulumi.Input[bool],
                 matchers: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]] aggregators: The aggregator for this rule
        :param pulumi.Input[bool] enabled: Status of this aggregation rule
        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]] matchers: The matcher for this rule
        :param pulumi.Input[str] name: Name of this aggregation rule
        """
        pulumi.set(__self__, "aggregators", aggregators)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "matchers", matchers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def aggregators(self) -> pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]]:
        """
        The aggregator for this rule
        """
        return pulumi.get(self, "aggregators")

    @aggregators.setter
    def aggregators(self, value: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]]):
        pulumi.set(self, "aggregators", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Status of this aggregation rule
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def matchers(self) -> pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]]:
        """
        The matcher for this rule
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of this aggregation rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class MetricRulesetAggregationRuleAggregatorArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 drop_dimensions: pulumi.Input[bool],
                 output_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dimensions: List of dimensions to keep or drop in aggregated metric
        :param pulumi.Input[bool] drop_dimensions: Flag specifying to keep or drop given dimensions
        :param pulumi.Input[str] output_name: The aggregated metric name
        :param pulumi.Input[str] type: The type of the aggregator
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "drop_dimensions", drop_dimensions)
        pulumi.set(__self__, "output_name", output_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of dimensions to keep or drop in aggregated metric
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="dropDimensions")
    def drop_dimensions(self) -> pulumi.Input[bool]:
        """
        Flag specifying to keep or drop given dimensions
        """
        return pulumi.get(self, "drop_dimensions")

    @drop_dimensions.setter
    def drop_dimensions(self, value: pulumi.Input[bool]):
        pulumi.set(self, "drop_dimensions", value)

    @property
    @pulumi.getter(name="outputName")
    def output_name(self) -> pulumi.Input[str]:
        """
        The aggregated metric name
        """
        return pulumi.get(self, "output_name")

    @output_name.setter
    def output_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the aggregator
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MetricRulesetAggregationRuleMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The type of the matcher
        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]] filters: List of filters to match on
        """
        pulumi.set(__self__, "type", type)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the matcher
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]]:
        """
        List of filters to match on
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class MetricRulesetAggregationRuleMatcherFilterArgs:
    def __init__(__self__, *,
                 not_: pulumi.Input[bool],
                 property: pulumi.Input[str],
                 property_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[bool] not_: Flag specifying equals or not equals
        :param pulumi.Input[str] property: Name of dimension to match
        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_values: List of property values to match
        """
        pulumi.set(__self__, "not_", not_)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "property_values", property_values)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> pulumi.Input[bool]:
        """
        Flag specifying equals or not equals
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: pulumi.Input[bool]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of property values to match
        """
        return pulumi.get(self, "property_values")

    @property_values.setter
    def property_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "property_values", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        Name of dimension to match
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class MetricRulesetRoutingRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: Destination to send the input metric
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Destination to send the input metric
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class OrgTokenDpmLimitsArgs:
    def __init__(__self__, *,
                 dpm_limit: pulumi.Input[int],
                 dpm_notification_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] dpm_limit: The datapoints per minute (dpm) limit for this token. If you exceed this limit, Splunk Observability Cloud sends out an alert.
        :param pulumi.Input[int] dpm_notification_threshold: DPM level at which Splunk Observability Cloud sends the notification for this token. If you don't specify a notification, Splunk Observability Cloud sends the generic notification.
        """
        pulumi.set(__self__, "dpm_limit", dpm_limit)
        if dpm_notification_threshold is not None:
            pulumi.set(__self__, "dpm_notification_threshold", dpm_notification_threshold)

    @property
    @pulumi.getter(name="dpmLimit")
    def dpm_limit(self) -> pulumi.Input[int]:
        """
        The datapoints per minute (dpm) limit for this token. If you exceed this limit, Splunk Observability Cloud sends out an alert.
        """
        return pulumi.get(self, "dpm_limit")

    @dpm_limit.setter
    def dpm_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "dpm_limit", value)

    @property
    @pulumi.getter(name="dpmNotificationThreshold")
    def dpm_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        DPM level at which Splunk Observability Cloud sends the notification for this token. If you don't specify a notification, Splunk Observability Cloud sends the generic notification.
        """
        return pulumi.get(self, "dpm_notification_threshold")

    @dpm_notification_threshold.setter
    def dpm_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dpm_notification_threshold", value)


@pulumi.input_type
class OrgTokenHostOrUsageLimitsArgs:
    def __init__(__self__, *,
                 container_limit: Optional[pulumi.Input[int]] = None,
                 container_notification_threshold: Optional[pulumi.Input[int]] = None,
                 custom_metrics_limit: Optional[pulumi.Input[int]] = None,
                 custom_metrics_notification_threshold: Optional[pulumi.Input[int]] = None,
                 high_res_metrics_limit: Optional[pulumi.Input[int]] = None,
                 high_res_metrics_notification_threshold: Optional[pulumi.Input[int]] = None,
                 host_limit: Optional[pulumi.Input[int]] = None,
                 host_notification_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] container_limit: Max number of containers that can use this token
        :param pulumi.Input[int] container_notification_threshold: Notification threshold for containers
        :param pulumi.Input[int] custom_metrics_limit: Max number of custom metrics that can be sent with this token
        :param pulumi.Input[int] custom_metrics_notification_threshold: Notification threshold for custom metrics
        :param pulumi.Input[int] high_res_metrics_limit: Max number of high-res metrics that can be sent with this token
        :param pulumi.Input[int] high_res_metrics_notification_threshold: Notification threshold for high-res metrics
        :param pulumi.Input[int] host_limit: Max number of hosts that can use this token
        :param pulumi.Input[int] host_notification_threshold: Notification threshold for hosts
        """
        if container_limit is not None:
            pulumi.set(__self__, "container_limit", container_limit)
        if container_notification_threshold is not None:
            pulumi.set(__self__, "container_notification_threshold", container_notification_threshold)
        if custom_metrics_limit is not None:
            pulumi.set(__self__, "custom_metrics_limit", custom_metrics_limit)
        if custom_metrics_notification_threshold is not None:
            pulumi.set(__self__, "custom_metrics_notification_threshold", custom_metrics_notification_threshold)
        if high_res_metrics_limit is not None:
            pulumi.set(__self__, "high_res_metrics_limit", high_res_metrics_limit)
        if high_res_metrics_notification_threshold is not None:
            pulumi.set(__self__, "high_res_metrics_notification_threshold", high_res_metrics_notification_threshold)
        if host_limit is not None:
            pulumi.set(__self__, "host_limit", host_limit)
        if host_notification_threshold is not None:
            pulumi.set(__self__, "host_notification_threshold", host_notification_threshold)

    @property
    @pulumi.getter(name="containerLimit")
    def container_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of containers that can use this token
        """
        return pulumi.get(self, "container_limit")

    @container_limit.setter
    def container_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_limit", value)

    @property
    @pulumi.getter(name="containerNotificationThreshold")
    def container_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for containers
        """
        return pulumi.get(self, "container_notification_threshold")

    @container_notification_threshold.setter
    def container_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_notification_threshold", value)

    @property
    @pulumi.getter(name="customMetricsLimit")
    def custom_metrics_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of custom metrics that can be sent with this token
        """
        return pulumi.get(self, "custom_metrics_limit")

    @custom_metrics_limit.setter
    def custom_metrics_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_metrics_limit", value)

    @property
    @pulumi.getter(name="customMetricsNotificationThreshold")
    def custom_metrics_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for custom metrics
        """
        return pulumi.get(self, "custom_metrics_notification_threshold")

    @custom_metrics_notification_threshold.setter
    def custom_metrics_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_metrics_notification_threshold", value)

    @property
    @pulumi.getter(name="highResMetricsLimit")
    def high_res_metrics_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of high-res metrics that can be sent with this token
        """
        return pulumi.get(self, "high_res_metrics_limit")

    @high_res_metrics_limit.setter
    def high_res_metrics_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "high_res_metrics_limit", value)

    @property
    @pulumi.getter(name="highResMetricsNotificationThreshold")
    def high_res_metrics_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for high-res metrics
        """
        return pulumi.get(self, "high_res_metrics_notification_threshold")

    @high_res_metrics_notification_threshold.setter
    def high_res_metrics_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "high_res_metrics_notification_threshold", value)

    @property
    @pulumi.getter(name="hostLimit")
    def host_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of hosts that can use this token
        """
        return pulumi.get(self, "host_limit")

    @host_limit.setter
    def host_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "host_limit", value)

    @property
    @pulumi.getter(name="hostNotificationThreshold")
    def host_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for hosts
        """
        return pulumi.get(self, "host_notification_threshold")

    @host_notification_threshold.setter
    def host_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "host_notification_threshold", value)


@pulumi.input_type
class SingleValueChartColorScaleArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 gt: Optional[pulumi.Input[float]] = None,
                 gte: Optional[pulumi.Input[float]] = None,
                 lt: Optional[pulumi.Input[float]] = None,
                 lte: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range
        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range
        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range
        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def gt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold non-inclusive value for this range
        """
        return pulumi.get(self, "gt")

    @gt.setter
    def gt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gt", value)

    @property
    @pulumi.getter
    def gte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold inclusive value for this range
        """
        return pulumi.get(self, "gte")

    @gte.setter
    def gte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gte", value)

    @property
    @pulumi.getter
    def lt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold non-inculsive value for this range
        """
        return pulumi.get(self, "lt")

    @lt.setter
    def lt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt", value)

    @property
    @pulumi.getter
    def lte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold inclusive value for this range
        """
        return pulumi.get(self, "lte")

    @lte.setter
    def lte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lte", value)


@pulumi.input_type
class SingleValueChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class SloInputArgs:
    def __init__(__self__, *,
                 program_text: pulumi.Input[str],
                 good_events_label: Optional[pulumi.Input[str]] = None,
                 total_events_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] program_text: Signalflow program text for the SLO. More info at "https://dev.splunk.com/observability/docs/signalflow". We require this Signalflow program text to contain at least 2 data blocks - one for the total stream and one for the good stream, whose labels are specified by goodEventsLabel and totalEventsLabel
        :param pulumi.Input[str] good_events_label: Label used in `program_text` that refers to the data block which contains the stream of successful events
        :param pulumi.Input[str] total_events_label: Label used in `program_text` that refers to the data block which contains the stream of total events
        """
        pulumi.set(__self__, "program_text", program_text)
        if good_events_label is not None:
            pulumi.set(__self__, "good_events_label", good_events_label)
        if total_events_label is not None:
            pulumi.set(__self__, "total_events_label", total_events_label)

    @property
    @pulumi.getter(name="programText")
    def program_text(self) -> pulumi.Input[str]:
        """
        Signalflow program text for the SLO. More info at "https://dev.splunk.com/observability/docs/signalflow". We require this Signalflow program text to contain at least 2 data blocks - one for the total stream and one for the good stream, whose labels are specified by goodEventsLabel and totalEventsLabel
        """
        return pulumi.get(self, "program_text")

    @program_text.setter
    def program_text(self, value: pulumi.Input[str]):
        pulumi.set(self, "program_text", value)

    @property
    @pulumi.getter(name="goodEventsLabel")
    def good_events_label(self) -> Optional[pulumi.Input[str]]:
        """
        Label used in `program_text` that refers to the data block which contains the stream of successful events
        """
        return pulumi.get(self, "good_events_label")

    @good_events_label.setter
    def good_events_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "good_events_label", value)

    @property
    @pulumi.getter(name="totalEventsLabel")
    def total_events_label(self) -> Optional[pulumi.Input[str]]:
        """
        Label used in `program_text` that refers to the data block which contains the stream of total events
        """
        return pulumi.get(self, "total_events_label")

    @total_events_label.setter
    def total_events_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "total_events_label", value)


@pulumi.input_type
class SloTargetArgs:
    def __init__(__self__, *,
                 alert_rules: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]],
                 slo: pulumi.Input[float],
                 type: pulumi.Input[str],
                 compliance_period: Optional[pulumi.Input[str]] = None,
                 cycle_start: Optional[pulumi.Input[str]] = None,
                 cycle_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]] alert_rules: SLO alert rules
        :param pulumi.Input[float] slo: Target value in the form of a percentage
        :param pulumi.Input[str] type: SLO target type can be the following type: `RollingWindow`
        :param pulumi.Input[str] compliance_period: (Required for `RollingWindow` type) Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
        :param pulumi.Input[str] cycle_start: (Optional for `CalendarWindow` type)  It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
        :param pulumi.Input[str] cycle_type: (Required for `CalendarWindow` type) The cycle type of the calendar window, e.g. week, month.
        """
        pulumi.set(__self__, "alert_rules", alert_rules)
        pulumi.set(__self__, "slo", slo)
        pulumi.set(__self__, "type", type)
        if compliance_period is not None:
            pulumi.set(__self__, "compliance_period", compliance_period)
        if cycle_start is not None:
            pulumi.set(__self__, "cycle_start", cycle_start)
        if cycle_type is not None:
            pulumi.set(__self__, "cycle_type", cycle_type)

    @property
    @pulumi.getter(name="alertRules")
    def alert_rules(self) -> pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]]:
        """
        SLO alert rules
        """
        return pulumi.get(self, "alert_rules")

    @alert_rules.setter
    def alert_rules(self, value: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]]):
        pulumi.set(self, "alert_rules", value)

    @property
    @pulumi.getter
    def slo(self) -> pulumi.Input[float]:
        """
        Target value in the form of a percentage
        """
        return pulumi.get(self, "slo")

    @slo.setter
    def slo(self, value: pulumi.Input[float]):
        pulumi.set(self, "slo", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        SLO target type can be the following type: `RollingWindow`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="compliancePeriod")
    def compliance_period(self) -> Optional[pulumi.Input[str]]:
        """
        (Required for `RollingWindow` type) Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
        """
        return pulumi.get(self, "compliance_period")

    @compliance_period.setter
    def compliance_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compliance_period", value)

    @property
    @pulumi.getter(name="cycleStart")
    def cycle_start(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional for `CalendarWindow` type)  It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
        """
        return pulumi.get(self, "cycle_start")

    @cycle_start.setter
    def cycle_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cycle_start", value)

    @property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Required for `CalendarWindow` type) The cycle type of the calendar window, e.g. week, month.
        """
        return pulumi.get(self, "cycle_type")

    @cycle_type.setter
    def cycle_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cycle_type", value)


@pulumi.input_type
class SloTargetAlertRuleArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]] rules: Set of rules used for alerting
        :param pulumi.Input[str] type: SLO alert rule type
        """
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]]:
        """
        Set of rules used for alerting
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        SLO alert rule type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SloTargetAlertRuleRuleArgs:
    def __init__(__self__, *,
                 severity: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parameterized_body: Optional[pulumi.Input[str]] = None,
                 parameterized_subject: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input['SloTargetAlertRuleRuleParametersArgs']] = None,
                 runbook_url: Optional[pulumi.Input[str]] = None,
                 tip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] severity: The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
        :param pulumi.Input[str] description: Description of the rule
        :param pulumi.Input[bool] disabled: (default: false) When true, notifications and events will not be generated for the detect label
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
        :param pulumi.Input[str] parameterized_body: Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        :param pulumi.Input[str] parameterized_subject: Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        :param pulumi.Input['SloTargetAlertRuleRuleParametersArgs'] parameters: Parameters for the SLO alert rule. Each SLO alert rule type accepts different parameters. If not specified, default parameters are used.
        :param pulumi.Input[str] runbook_url: URL of page to consult when an alert is triggered
        :param pulumi.Input[str] tip: Plain text suggested first course of action, such as a command to execute.
        """
        pulumi.set(__self__, "severity", severity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if parameterized_body is not None:
            pulumi.set(__self__, "parameterized_body", parameterized_body)
        if parameterized_subject is not None:
            pulumi.set(__self__, "parameterized_subject", parameterized_subject)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if runbook_url is not None:
            pulumi.set(__self__, "runbook_url", runbook_url)
        if tip is not None:
            pulumi.set(__self__, "tip", tip)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[str]:
        """
        The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[str]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (default: false) When true, notifications and events will not be generated for the detect label
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notifications", value)

    @property
    @pulumi.getter(name="parameterizedBody")
    def parameterized_body(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        """
        return pulumi.get(self, "parameterized_body")

    @parameterized_body.setter
    def parameterized_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_body", value)

    @property
    @pulumi.getter(name="parameterizedSubject")
    def parameterized_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
        """
        return pulumi.get(self, "parameterized_subject")

    @parameterized_subject.setter
    def parameterized_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_subject", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['SloTargetAlertRuleRuleParametersArgs']]:
        """
        Parameters for the SLO alert rule. Each SLO alert rule type accepts different parameters. If not specified, default parameters are used.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['SloTargetAlertRuleRuleParametersArgs']]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="runbookUrl")
    def runbook_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of page to consult when an alert is triggered
        """
        return pulumi.get(self, "runbook_url")

    @runbook_url.setter
    def runbook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runbook_url", value)

    @property
    @pulumi.getter
    def tip(self) -> Optional[pulumi.Input[str]]:
        """
        Plain text suggested first course of action, such as a command to execute.
        """
        return pulumi.get(self, "tip")

    @tip.setter
    def tip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tip", value)


@pulumi.input_type
class SloTargetAlertRuleRuleParametersArgs:
    def __init__(__self__, *,
                 burn_rate_threshold1: Optional[pulumi.Input[float]] = None,
                 burn_rate_threshold2: Optional[pulumi.Input[float]] = None,
                 fire_lasting: Optional[pulumi.Input[str]] = None,
                 long_window1: Optional[pulumi.Input[str]] = None,
                 long_window2: Optional[pulumi.Input[str]] = None,
                 percent_error_budget_left: Optional[pulumi.Input[float]] = None,
                 percent_of_lasting: Optional[pulumi.Input[float]] = None,
                 short_window1: Optional[pulumi.Input[str]] = None,
                 short_window2: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] burn_rate_threshold1: Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_1 parameter.
        :param pulumi.Input[float] burn_rate_threshold2: Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_2 parameter.
        :param pulumi.Input[str] fire_lasting: Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the fire_lasting parameter
        :param pulumi.Input[str] long_window1: Long window 1 used in burn rate alert calculation. This value must be longer than short_window_1` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_1 parameter.
        :param pulumi.Input[str] long_window2: Long window 2 used in burn rate alert calculation. This value must be longer than short_window_2` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_2 parameter.
        :param pulumi.Input[float] percent_error_budget_left: Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: ERROR_BUDGET_LEFT alert rules use the percent_error_budget_left parameter.
        :param pulumi.Input[float] percent_of_lasting: Percentage of the fire_lasting duration that the alert condition is met before the alert is triggered. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the percent_of_lasting parameter
        :param pulumi.Input[str] short_window1: Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_1. Note: BURN_RATE alert rules use the short_window_1 parameter.
        :param pulumi.Input[str] short_window2: Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_2. Note: BURN_RATE alert rules use the short_window_2 parameter.
        """
        if burn_rate_threshold1 is not None:
            pulumi.set(__self__, "burn_rate_threshold1", burn_rate_threshold1)
        if burn_rate_threshold2 is not None:
            pulumi.set(__self__, "burn_rate_threshold2", burn_rate_threshold2)
        if fire_lasting is not None:
            pulumi.set(__self__, "fire_lasting", fire_lasting)
        if long_window1 is not None:
            pulumi.set(__self__, "long_window1", long_window1)
        if long_window2 is not None:
            pulumi.set(__self__, "long_window2", long_window2)
        if percent_error_budget_left is not None:
            pulumi.set(__self__, "percent_error_budget_left", percent_error_budget_left)
        if percent_of_lasting is not None:
            pulumi.set(__self__, "percent_of_lasting", percent_of_lasting)
        if short_window1 is not None:
            pulumi.set(__self__, "short_window1", short_window1)
        if short_window2 is not None:
            pulumi.set(__self__, "short_window2", short_window2)

    @property
    @pulumi.getter(name="burnRateThreshold1")
    def burn_rate_threshold1(self) -> Optional[pulumi.Input[float]]:
        """
        Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_1 parameter.
        """
        return pulumi.get(self, "burn_rate_threshold1")

    @burn_rate_threshold1.setter
    def burn_rate_threshold1(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "burn_rate_threshold1", value)

    @property
    @pulumi.getter(name="burnRateThreshold2")
    def burn_rate_threshold2(self) -> Optional[pulumi.Input[float]]:
        """
        Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_2 parameter.
        """
        return pulumi.get(self, "burn_rate_threshold2")

    @burn_rate_threshold2.setter
    def burn_rate_threshold2(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "burn_rate_threshold2", value)

    @property
    @pulumi.getter(name="fireLasting")
    def fire_lasting(self) -> Optional[pulumi.Input[str]]:
        """
        Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the fire_lasting parameter
        """
        return pulumi.get(self, "fire_lasting")

    @fire_lasting.setter
    def fire_lasting(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fire_lasting", value)

    @property
    @pulumi.getter(name="longWindow1")
    def long_window1(self) -> Optional[pulumi.Input[str]]:
        """
        Long window 1 used in burn rate alert calculation. This value must be longer than short_window_1` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_1 parameter.
        """
        return pulumi.get(self, "long_window1")

    @long_window1.setter
    def long_window1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "long_window1", value)

    @property
    @pulumi.getter(name="longWindow2")
    def long_window2(self) -> Optional[pulumi.Input[str]]:
        """
        Long window 2 used in burn rate alert calculation. This value must be longer than short_window_2` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_2 parameter.
        """
        return pulumi.get(self, "long_window2")

    @long_window2.setter
    def long_window2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "long_window2", value)

    @property
    @pulumi.getter(name="percentErrorBudgetLeft")
    def percent_error_budget_left(self) -> Optional[pulumi.Input[float]]:
        """
        Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: ERROR_BUDGET_LEFT alert rules use the percent_error_budget_left parameter.
        """
        return pulumi.get(self, "percent_error_budget_left")

    @percent_error_budget_left.setter
    def percent_error_budget_left(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent_error_budget_left", value)

    @property
    @pulumi.getter(name="percentOfLasting")
    def percent_of_lasting(self) -> Optional[pulumi.Input[float]]:
        """
        Percentage of the fire_lasting duration that the alert condition is met before the alert is triggered. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the percent_of_lasting parameter
        """
        return pulumi.get(self, "percent_of_lasting")

    @percent_of_lasting.setter
    def percent_of_lasting(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent_of_lasting", value)

    @property
    @pulumi.getter(name="shortWindow1")
    def short_window1(self) -> Optional[pulumi.Input[str]]:
        """
        Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_1. Note: BURN_RATE alert rules use the short_window_1 parameter.
        """
        return pulumi.get(self, "short_window1")

    @short_window1.setter
    def short_window1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_window1", value)

    @property
    @pulumi.getter(name="shortWindow2")
    def short_window2(self) -> Optional[pulumi.Input[str]]:
        """
        Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_2. Note: BURN_RATE alert rules use the short_window_2 parameter.
        """
        return pulumi.get(self, "short_window2")

    @short_window2.setter
    def short_window2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_window2", value)


@pulumi.input_type
class TableChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class TimeChartAxisLeftArgs:
    def __init__(__self__, *,
                 high_watermark: Optional[pulumi.Input[float]] = None,
                 high_watermark_label: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 low_watermark: Optional[pulumi.Input[float]] = None,
                 low_watermark_label: Optional[pulumi.Input[str]] = None,
                 max_value: Optional[pulumi.Input[float]] = None,
                 min_value: Optional[pulumi.Input[float]] = None,
                 watermarks: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]] = None):
        """
        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark
        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line
        :param pulumi.Input[str] label: Label of the left axis
        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark
        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line
        :param pulumi.Input[float] max_value: The maximum value for the left axis
        :param pulumi.Input[float] min_value: The minimum value for the left axis
        """
        if high_watermark is not None:
            pulumi.set(__self__, "high_watermark", high_watermark)
        if high_watermark_label is not None:
            pulumi.set(__self__, "high_watermark_label", high_watermark_label)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if low_watermark is not None:
            pulumi.set(__self__, "low_watermark", low_watermark)
        if low_watermark_label is not None:
            pulumi.set(__self__, "low_watermark_label", low_watermark_label)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if watermarks is not None:
            pulumi.set(__self__, "watermarks", watermarks)

    @property
    @pulumi.getter(name="highWatermark")
    def high_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a high watermark
        """
        return pulumi.get(self, "high_watermark")

    @high_watermark.setter
    def high_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "high_watermark", value)

    @property
    @pulumi.getter(name="highWatermarkLabel")
    def high_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the high watermark line
        """
        return pulumi.get(self, "high_watermark_label")

    @high_watermark_label.setter
    def high_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high_watermark_label", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label of the left axis
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="lowWatermark")
    def low_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a low watermark
        """
        return pulumi.get(self, "low_watermark")

    @low_watermark.setter
    def low_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "low_watermark", value)

    @property
    @pulumi.getter(name="lowWatermarkLabel")
    def low_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the low watermark line
        """
        return pulumi.get(self, "low_watermark_label")

    @low_watermark_label.setter
    def low_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "low_watermark_label", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum value for the left axis
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum value for the left axis
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter
    def watermarks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]]:
        return pulumi.get(self, "watermarks")

    @watermarks.setter
    def watermarks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]]):
        pulumi.set(self, "watermarks", value)


@pulumi.input_type
class TimeChartAxisLeftWatermarkArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float],
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] value: Axis value where the watermark line will be displayed
        :param pulumi.Input[str] label: Label to display associated with the watermark line
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Axis value where the watermark line will be displayed
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label to display associated with the watermark line
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class TimeChartAxisRightArgs:
    def __init__(__self__, *,
                 high_watermark: Optional[pulumi.Input[float]] = None,
                 high_watermark_label: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 low_watermark: Optional[pulumi.Input[float]] = None,
                 low_watermark_label: Optional[pulumi.Input[str]] = None,
                 max_value: Optional[pulumi.Input[float]] = None,
                 min_value: Optional[pulumi.Input[float]] = None,
                 watermarks: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]] = None):
        """
        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark
        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line
        :param pulumi.Input[str] label: Label of the right axis
        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark
        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line
        :param pulumi.Input[float] max_value: The maximum value for the right axis
        :param pulumi.Input[float] min_value: The minimum value for the right axis
        """
        if high_watermark is not None:
            pulumi.set(__self__, "high_watermark", high_watermark)
        if high_watermark_label is not None:
            pulumi.set(__self__, "high_watermark_label", high_watermark_label)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if low_watermark is not None:
            pulumi.set(__self__, "low_watermark", low_watermark)
        if low_watermark_label is not None:
            pulumi.set(__self__, "low_watermark_label", low_watermark_label)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if watermarks is not None:
            pulumi.set(__self__, "watermarks", watermarks)

    @property
    @pulumi.getter(name="highWatermark")
    def high_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a high watermark
        """
        return pulumi.get(self, "high_watermark")

    @high_watermark.setter
    def high_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "high_watermark", value)

    @property
    @pulumi.getter(name="highWatermarkLabel")
    def high_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the high watermark line
        """
        return pulumi.get(self, "high_watermark_label")

    @high_watermark_label.setter
    def high_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high_watermark_label", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label of the right axis
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="lowWatermark")
    def low_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a low watermark
        """
        return pulumi.get(self, "low_watermark")

    @low_watermark.setter
    def low_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "low_watermark", value)

    @property
    @pulumi.getter(name="lowWatermarkLabel")
    def low_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the low watermark line
        """
        return pulumi.get(self, "low_watermark_label")

    @low_watermark_label.setter
    def low_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "low_watermark_label", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum value for the right axis
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum value for the right axis
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter
    def watermarks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]]:
        return pulumi.get(self, "watermarks")

    @watermarks.setter
    def watermarks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]]):
        pulumi.set(self, "watermarks", value)


@pulumi.input_type
class TimeChartAxisRightWatermarkArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float],
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] value: Axis value where the watermark line will be displayed
        :param pulumi.Input[str] label: Label to display associated with the watermark line
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Axis value where the watermark line will be displayed
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label to display associated with the watermark line
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class TimeChartEventOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the events you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the events you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class TimeChartHistogramOptionArgs:
    def __init__(__self__, *,
                 color_theme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] color_theme: Base color theme to use for the graph.
        """
        if color_theme is not None:
            pulumi.set(__self__, "color_theme", color_theme)

    @property
    @pulumi.getter(name="colorTheme")
    def color_theme(self) -> Optional[pulumi.Input[str]]:
        """
        Base color theme to use for the graph.
        """
        return pulumi.get(self, "color_theme")

    @color_theme.setter
    def color_theme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_theme", value)


@pulumi.input_type
class TimeChartLegendOptionsFieldArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: The name of a property to hide or show in the data table.
        :param pulumi.Input[bool] enabled: (true by default) Determines if this property is displayed in the data table.
        """
        pulumi.set(__self__, "property", property)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (true by default) Determines if this property is displayed in the data table.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The name of a property to hide or show in the data table.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class TimeChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 axis: Optional[pulumi.Input[str]] = None,
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 plot_type: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] axis: The Y-axis associated with values for this plot. Must be either "right" or "left". Defaults to "left".
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] plot_type: (Chart plot_type by default) The visualization style to use. Must be "LineChart", "AreaChart", "ColumnChart", or "Histogram"
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if axis is not None:
            pulumi.set(__self__, "axis", axis)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if plot_type is not None:
            pulumi.set(__self__, "plot_type", plot_type)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def axis(self) -> Optional[pulumi.Input[str]]:
        """
        The Y-axis associated with values for this plot. Must be either "right" or "left". Defaults to "left".
        """
        return pulumi.get(self, "axis")

    @axis.setter
    def axis(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "axis", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="plotType")
    def plot_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Chart plot_type by default) The visualization style to use. Must be "LineChart", "AreaChart", "ColumnChart", or "Histogram"
        """
        return pulumi.get(self, "plot_type")

    @plot_type.setter
    def plot_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plot_type", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class WebhookIntegrationHeaderArgs:
    def __init__(__self__, *,
                 header_key: pulumi.Input[str],
                 header_value: pulumi.Input[str]):
        pulumi.set(__self__, "header_key", header_key)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerKey")
    def header_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_key")

    @header_key.setter
    def header_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_key", value)

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_value", value)


