# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AlertMutingRuleFilterArgs',
    'AlertMutingRuleRecurrenceArgs',
    'DashboardChartArgs',
    'DashboardColumnArgs',
    'DashboardEventOverlayArgs',
    'DashboardEventOverlaySourceArgs',
    'DashboardFilterArgs',
    'DashboardGridArgs',
    'DashboardGroupDashboardArgs',
    'DashboardGroupDashboardFilterOverrideArgs',
    'DashboardGroupDashboardVariableOverrideArgs',
    'DashboardGroupImportQualifierArgs',
    'DashboardGroupImportQualifierFilterArgs',
    'DashboardGroupPermissionArgs',
    'DashboardPermissionsArgs',
    'DashboardPermissionsAclArgs',
    'DashboardSelectedEventOverlayArgs',
    'DashboardSelectedEventOverlaySourceArgs',
    'DashboardVariableArgs',
    'DataLinkTargetExternalUrlArgs',
    'DataLinkTargetSignalfxDashboardArgs',
    'DataLinkTargetSplunkArgs',
    'DetectorRuleArgs',
    'DetectorVizOptionArgs',
    'HeatmapChartColorRangeArgs',
    'HeatmapChartColorScaleArgs',
    'ListChartColorScaleArgs',
    'ListChartLegendOptionsFieldArgs',
    'ListChartVizOptionArgs',
    'MetricRulesetAggregationRuleArgs',
    'MetricRulesetAggregationRuleAggregatorArgs',
    'MetricRulesetAggregationRuleMatcherArgs',
    'MetricRulesetAggregationRuleMatcherFilterArgs',
    'MetricRulesetRoutingRuleArgs',
    'OrgTokenDpmLimitsArgs',
    'OrgTokenHostOrUsageLimitsArgs',
    'SingleValueChartColorScaleArgs',
    'SingleValueChartVizOptionArgs',
    'SloInputArgs',
    'SloTargetArgs',
    'SloTargetAlertRuleArgs',
    'SloTargetAlertRuleRuleArgs',
    'SloTargetAlertRuleRuleParametersArgs',
    'TableChartVizOptionArgs',
    'TimeChartAxisLeftArgs',
    'TimeChartAxisLeftWatermarkArgs',
    'TimeChartAxisRightArgs',
    'TimeChartAxisRightWatermarkArgs',
    'TimeChartEventOptionArgs',
    'TimeChartHistogramOptionArgs',
    'TimeChartLegendOptionsFieldArgs',
    'TimeChartVizOptionArgs',
    'WebhookIntegrationHeaderArgs',
]

@pulumi.input_type
class AlertMutingRuleFilterArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 property_value: pulumi.Input[str],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: The property to filter.
        :param pulumi.Input[str] property_value: The property value to filter.
        :param pulumi.Input[bool] negated: Determines if this is a "not" filter. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "property_value", property_value)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> pulumi.Input[str]:
        """
        The property value to filter.
        """
        return pulumi.get(self, "property_value")

    @property_value.setter
    def property_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "property_value", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this is a "not" filter. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The property to filter.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class AlertMutingRuleRecurrenceArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: The unit of the period. Can be days (d) or weeks (w).
        :param pulumi.Input[int] value: The amount of time, expressed as an integer, applicable to the unit specified.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        The unit of the period. Can be days (d) or weeks (w).
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        The amount of time, expressed as an integer, applicable to the unit specified.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DashboardChartArgs:
    def __init__(__self__, *,
                 chart_id: pulumi.Input[str],
                 column: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 row: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] chart_id: ID of the chart to display.
        :param pulumi.Input[int] column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart (between `0` and `11`).
        :param pulumi.Input[int] height: How many rows the chart should take up (greater than or equal to `1`). `1` by default.
        :param pulumi.Input[int] row: The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
        :param pulumi.Input[int] width: How many columns (out of a total of 12) the chart should take up (between `1` and `12`). `12` by default.
        """
        pulumi.set(__self__, "chart_id", chart_id)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if row is not None:
            pulumi.set(__self__, "row", row)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartId")
    def chart_id(self) -> pulumi.Input[str]:
        """
        ID of the chart to display.
        """
        return pulumi.get(self, "chart_id")

    @chart_id.setter
    def chart_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "chart_id", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[int]]:
        """
        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart (between `0` and `11`).
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows the chart should take up (greater than or equal to `1`). `1` by default.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def row(self) -> Optional[pulumi.Input[int]]:
        """
        The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
        """
        return pulumi.get(self, "row")

    @row.setter
    def row(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "row", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        How many columns (out of a total of 12) the chart should take up (between `1` and `12`). `12` by default.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardColumnArgs:
    def __init__(__self__, *,
                 chart_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 column: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: List of IDs of the charts to display.
        :param pulumi.Input[int] column: Column number for the layout.
        :param pulumi.Input[int] height: How many rows every chart should take up (greater than or equal to 1). 1 by default.
        :param pulumi.Input[int] width: How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
        """
        pulumi.set(__self__, "chart_ids", chart_ids)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartIds")
    def chart_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of IDs of the charts to display.
        """
        return pulumi.get(self, "chart_ids")

    @chart_ids.setter
    def chart_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "chart_ids", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[int]]:
        """
        Column number for the layout.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows every chart should take up (greater than or equal to 1). 1 by default.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardEventOverlayArgs:
    def __init__(__self__, *,
                 signal: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 line: Optional[pulumi.Input[bool]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] signal: Search term used to choose the events shown in the overlay.
        :param pulumi.Input[str] color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        :param pulumi.Input[str] label: Text shown in the dropdown when selecting this overlay from the menu.
        :param pulumi.Input[bool] line: Show a vertical line for the event. `false` by default.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]] sources: Each element specifies a filter to use against the signal specified in the `signal`.
        :param pulumi.Input[str] type: Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
        """
        pulumi.set(__self__, "signal", signal)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if line is not None:
            pulumi.set(__self__, "line", line)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def signal(self) -> pulumi.Input[str]:
        """
        Search term used to choose the events shown in the overlay.
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: pulumi.Input[str]):
        pulumi.set(self, "signal", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Text shown in the dropdown when selecting this overlay from the menu.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def line(self) -> Optional[pulumi.Input[bool]]:
        """
        Show a vertical line for the event. `false` by default.
        """
        return pulumi.get(self, "line")

    @line.setter
    def line(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "line", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]]:
        """
        Each element specifies a filter to use against the signal specified in the `signal`.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DashboardEventOverlaySourceArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: The name of a dimension to filter against.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to be used with the `property`, they will be combined via `OR`.
        :param pulumi.Input[bool] negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to be used with the `property`, they will be combined via `OR`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The name of a dimension to filter against.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardFilterArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 apply_if_exist: Optional[pulumi.Input[bool]] = None,
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of of strings (which will be treated as an OR filter on the property).
        :param pulumi.Input[bool] apply_if_exist: If true, this filter will also match data that doesn't have this property at all.
        :param pulumi.Input[bool] negated: Whether this filter should be a not filter. `false` by default.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if apply_if_exist is not None:
            pulumi.set(__self__, "apply_if_exist", apply_if_exist)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of of strings (which will be treated as an OR filter on the property).
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="applyIfExist")
    def apply_if_exist(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this filter will also match data that doesn't have this property at all.
        """
        return pulumi.get(self, "apply_if_exist")

    @apply_if_exist.setter
    def apply_if_exist(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_if_exist", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this filter should be a not filter. `false` by default.
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGridArgs:
    def __init__(__self__, *,
                 chart_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 height: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: List of IDs of the charts to display.
        :param pulumi.Input[int] height: How many rows every chart should take up (greater than or equal to `1`). `1` by default.
        :param pulumi.Input[int] width: How many columns (out of a total of 12) every chart should take up (between `1` and `12`). `12` by default.
        """
        pulumi.set(__self__, "chart_ids", chart_ids)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartIds")
    def chart_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of IDs of the charts to display.
        """
        return pulumi.get(self, "chart_ids")

    @chart_ids.setter
    def chart_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "chart_ids", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows every chart should take up (greater than or equal to `1`). `1` by default.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        How many columns (out of a total of 12) every chart should take up (between `1` and `12`). `12` by default.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardGroupDashboardArgs:
    def __init__(__self__, *,
                 dashboard_id: pulumi.Input[str],
                 config_id: Optional[pulumi.Input[str]] = None,
                 description_override: Optional[pulumi.Input[str]] = None,
                 filter_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]] = None,
                 name_override: Optional[pulumi.Input[str]] = None,
                 variable_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]] = None):
        """
        :param pulumi.Input[str] dashboard_id: The dashboard id to mirror
        :param pulumi.Input[str] config_id: The ID of the association between the dashboard group and the dashboard
        :param pulumi.Input[str] description_override: The description that will override the original dashboards's description.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]] filter_overrides: The description that will override the original dashboards's description.
        :param pulumi.Input[str] name_override: The name that will override the original dashboards's name.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]] variable_overrides: Dashboard variable to apply to each chart in the dashboard
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if config_id is not None:
            pulumi.set(__self__, "config_id", config_id)
        if description_override is not None:
            pulumi.set(__self__, "description_override", description_override)
        if filter_overrides is not None:
            pulumi.set(__self__, "filter_overrides", filter_overrides)
        if name_override is not None:
            pulumi.set(__self__, "name_override", name_override)
        if variable_overrides is not None:
            pulumi.set(__self__, "variable_overrides", variable_overrides)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> pulumi.Input[str]:
        """
        The dashboard id to mirror
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the association between the dashboard group and the dashboard
        """
        return pulumi.get(self, "config_id")

    @config_id.setter
    def config_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_id", value)

    @property
    @pulumi.getter(name="descriptionOverride")
    def description_override(self) -> Optional[pulumi.Input[str]]:
        """
        The description that will override the original dashboards's description.
        """
        return pulumi.get(self, "description_override")

    @description_override.setter
    def description_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description_override", value)

    @property
    @pulumi.getter(name="filterOverrides")
    def filter_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]]:
        """
        The description that will override the original dashboards's description.
        """
        return pulumi.get(self, "filter_overrides")

    @filter_overrides.setter
    def filter_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]]):
        pulumi.set(self, "filter_overrides", value)

    @property
    @pulumi.getter(name="nameOverride")
    def name_override(self) -> Optional[pulumi.Input[str]]:
        """
        The name that will override the original dashboards's name.
        """
        return pulumi.get(self, "name_override")

    @name_override.setter
    def name_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_override", value)

    @property
    @pulumi.getter(name="variableOverrides")
    def variable_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]]:
        """
        Dashboard variable to apply to each chart in the dashboard
        """
        return pulumi.get(self, "variable_overrides")

    @variable_overrides.setter
    def variable_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]]):
        pulumi.set(self, "variable_overrides", value)


@pulumi.input_type
class DashboardGroupDashboardFilterOverrideArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: (Optional) List of of strings (which will be treated as an OR filter on the property).
        :param pulumi.Input[bool] negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Optional) List of of strings (which will be treated as an OR filter on the property).
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGroupDashboardVariableOverrideArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values_suggesteds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        pulumi.set(__self__, "property", property)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if values_suggesteds is not None:
            pulumi.set(__self__, "values_suggesteds", values_suggesteds)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="valuesSuggesteds")
    def values_suggesteds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
        """
        return pulumi.get(self, "values_suggesteds")

    @values_suggesteds.setter
    def values_suggesteds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values_suggesteds", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGroupImportQualifierArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]] filters: Filter to apply to each chart in the dashboard
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]]]:
        """
        Filter to apply to each chart in the dashboard
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardGroupImportQualifierFilterArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: A metric time series dimension or property name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of strings (which will be treated as an OR filter on the property)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        (false by default) Whether this filter should be a "not" filter
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardGroupPermissionArgs:
    def __init__(__self__, *,
                 principal_id: pulumi.Input[str],
                 principal_type: pulumi.Input[str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] principal_id: ID of the user, team, or organization for which you're granting permissions.
        :param pulumi.Input[str] principal_type: Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "principal_type", principal_type)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> pulumi.Input[str]:
        """
        ID of the user, team, or organization for which you're granting permissions.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> pulumi.Input[str]:
        """
        Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
        """
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_type", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class DashboardPermissionsArgs:
    def __init__(__self__, *,
                 acls: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]] = None,
                 parent: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]] acls: List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
        :param pulumi.Input[str] parent: ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
        """
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if parent is not None:
            pulumi.set(__self__, "parent", parent)

    @property
    @pulumi.getter
    def acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]]:
        """
        List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
        """
        return pulumi.get(self, "acls")

    @acls.setter
    def acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]]):
        pulumi.set(self, "acls", value)

    @property
    @pulumi.getter
    def parent(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
        """
        return pulumi.get(self, "parent")

    @parent.setter
    def parent(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent", value)


@pulumi.input_type
class DashboardPermissionsAclArgs:
    def __init__(__self__, *,
                 principal_id: pulumi.Input[str],
                 principal_type: pulumi.Input[str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] principal_id: ID of the user, team, or organization for which you're granting permissions.
        :param pulumi.Input[str] principal_type: Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "principal_type", principal_type)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> pulumi.Input[str]:
        """
        ID of the user, team, or organization for which you're granting permissions.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> pulumi.Input[str]:
        """
        Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
        """
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_type", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class DashboardSelectedEventOverlayArgs:
    def __init__(__self__, *,
                 signal: pulumi.Input[str],
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] signal: Search term used to choose the events shown in the overlay.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]] sources: Each element specifies a filter to use against the signal specified in the `signal`.
        :param pulumi.Input[str] type: Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
        """
        pulumi.set(__self__, "signal", signal)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def signal(self) -> pulumi.Input[str]:
        """
        Search term used to choose the events shown in the overlay.
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: pulumi.Input[str]):
        pulumi.set(self, "signal", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]]:
        """
        Each element specifies a filter to use against the signal specified in the `signal`.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DashboardSelectedEventOverlaySourceArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: The name of a dimension to filter against.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to be used with the `property`, they will be combined via `OR`.
        :param pulumi.Input[bool] negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to be used with the `property`, they will be combined via `OR`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[bool]]:
        """
        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negated", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The name of a dimension to filter against.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DashboardVariableArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[str],
                 property: pulumi.Input[str],
                 apply_if_exist: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 replace_only: Optional[pulumi.Input[bool]] = None,
                 restricted_suggestions: Optional[pulumi.Input[bool]] = None,
                 value_required: Optional[pulumi.Input[bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values_suggesteds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] alias: An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
        :param pulumi.Input[str] property: A metric time series dimension or property name.
        :param pulumi.Input[bool] apply_if_exist: If true, this variable will also match data that doesn't have this property at all.
        :param pulumi.Input[str] description: Variable description.
        :param pulumi.Input[bool] replace_only: If `true`, this variable will only apply to charts that have a filter for the property.
        :param pulumi.Input[bool] restricted_suggestions: If `true`, this variable may only be set to the values listed in `values_suggested` and only these values will appear in autosuggestion menus. `false` by default.
        :param pulumi.Input[bool] value_required: Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of of strings (which will be treated as an OR filter on the property).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "property", property)
        if apply_if_exist is not None:
            pulumi.set(__self__, "apply_if_exist", apply_if_exist)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if replace_only is not None:
            pulumi.set(__self__, "replace_only", replace_only)
        if restricted_suggestions is not None:
            pulumi.set(__self__, "restricted_suggestions", restricted_suggestions)
        if value_required is not None:
            pulumi.set(__self__, "value_required", value_required)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if values_suggesteds is not None:
            pulumi.set(__self__, "values_suggesteds", values_suggesteds)

    @property
    @pulumi.getter
    def alias(self) -> pulumi.Input[str]:
        """
        An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[str]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="applyIfExist")
    def apply_if_exist(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, this variable will also match data that doesn't have this property at all.
        """
        return pulumi.get(self, "apply_if_exist")

    @apply_if_exist.setter
    def apply_if_exist(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_if_exist", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Variable description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="replaceOnly")
    def replace_only(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, this variable will only apply to charts that have a filter for the property.
        """
        return pulumi.get(self, "replace_only")

    @replace_only.setter
    def replace_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "replace_only", value)

    @property
    @pulumi.getter(name="restrictedSuggestions")
    def restricted_suggestions(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, this variable may only be set to the values listed in `values_suggested` and only these values will appear in autosuggestion menus. `false` by default.
        """
        return pulumi.get(self, "restricted_suggestions")

    @restricted_suggestions.setter
    def restricted_suggestions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restricted_suggestions", value)

    @property
    @pulumi.getter(name="valueRequired")
    def value_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
        """
        return pulumi.get(self, "value_required")

    @value_required.setter
    def value_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "value_required", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of of strings (which will be treated as an OR filter on the property).
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="valuesSuggesteds")
    def values_suggesteds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
        """
        return pulumi.get(self, "values_suggesteds")

    @values_suggesteds.setter
    def values_suggesteds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values_suggesteds", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        A metric time series dimension or property name.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class DataLinkTargetExternalUrlArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 minimum_time_window: Optional[pulumi.Input[str]] = None,
                 property_key_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param pulumi.Input[str] url: URL string for a Splunk instance or external system data link target. [See the supported template variables](https://dev.splunk.com/observability/docs/administration/datalinks/).
        :param pulumi.Input[str] minimum_time_window: The [minimum time window](https://dev.splunk.com/observability/docs/administration/datalinks/) for a search sent to an external site. Defaults to `6000`
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
        :param pulumi.Input[str] time_format: [Designates the format](https://dev.splunk.com/observability/docs/administration/datalinks/) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if minimum_time_window is not None:
            pulumi.set(__self__, "minimum_time_window", minimum_time_window)
        if property_key_mapping is not None:
            pulumi.set(__self__, "property_key_mapping", property_key_mapping)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL string for a Splunk instance or external system data link target. [See the supported template variables](https://dev.splunk.com/observability/docs/administration/datalinks/).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="minimumTimeWindow")
    def minimum_time_window(self) -> Optional[pulumi.Input[str]]:
        """
        The [minimum time window](https://dev.splunk.com/observability/docs/administration/datalinks/) for a search sent to an external site. Defaults to `6000`
        """
        return pulumi.get(self, "minimum_time_window")

    @minimum_time_window.setter
    def minimum_time_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_time_window", value)

    @property
    @pulumi.getter(name="propertyKeyMapping")
    def property_key_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
        """
        return pulumi.get(self, "property_key_mapping")

    @property_key_mapping.setter
    def property_key_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "property_key_mapping", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        [Designates the format](https://dev.splunk.com/observability/docs/administration/datalinks/) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)


@pulumi.input_type
class DataLinkTargetSignalfxDashboardArgs:
    def __init__(__self__, *,
                 dashboard_group_id: pulumi.Input[str],
                 dashboard_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 is_default: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] dashboard_group_id: SignalFx-assigned ID of the dashboard link target's dashboard group
        :param pulumi.Input[str] dashboard_id: SignalFx-assigned ID of the dashboard link target
        :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param pulumi.Input[bool] is_default: Flag that designates a target as the default for a data link object. `true` by default
        """
        pulumi.set(__self__, "dashboard_group_id", dashboard_group_id)
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        pulumi.set(__self__, "name", name)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)

    @property
    @pulumi.getter(name="dashboardGroupId")
    def dashboard_group_id(self) -> pulumi.Input[str]:
        """
        SignalFx-assigned ID of the dashboard link target's dashboard group
        """
        return pulumi.get(self, "dashboard_group_id")

    @dashboard_group_id.setter
    def dashboard_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_group_id", value)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> pulumi.Input[str]:
        """
        SignalFx-assigned ID of the dashboard link target
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that designates a target as the default for a data link object. `true` by default
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)


@pulumi.input_type
class DataLinkTargetSplunkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 property_key_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
        """
        pulumi.set(__self__, "name", name)
        if property_key_mapping is not None:
            pulumi.set(__self__, "property_key_mapping", property_key_mapping)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="propertyKeyMapping")
    def property_key_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
        """
        return pulumi.get(self, "property_key_mapping")

    @property_key_mapping.setter
    def property_key_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "property_key_mapping", value)


@pulumi.input_type
class DetectorRuleArgs:
    def __init__(__self__, *,
                 detect_label: pulumi.Input[str],
                 severity: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parameterized_body: Optional[pulumi.Input[str]] = None,
                 parameterized_subject: Optional[pulumi.Input[str]] = None,
                 runbook_url: Optional[pulumi.Input[str]] = None,
                 tip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] detect_label: A detect label which matches a detect label within `program_text`.
        :param pulumi.Input[str] severity: The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
        :param pulumi.Input[str] description: Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
        :param pulumi.Input[bool] disabled: When true, notifications and events will not be generated for the detect label. `false` by default.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
        :param pulumi.Input[str] parameterized_body: Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
        :param pulumi.Input[str] parameterized_subject: Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
        :param pulumi.Input[str] runbook_url: URL of page to consult when an alert is triggered. This can be used with custom notification messages.
        :param pulumi.Input[str] tip: Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
        """
        pulumi.set(__self__, "detect_label", detect_label)
        pulumi.set(__self__, "severity", severity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if parameterized_body is not None:
            pulumi.set(__self__, "parameterized_body", parameterized_body)
        if parameterized_subject is not None:
            pulumi.set(__self__, "parameterized_subject", parameterized_subject)
        if runbook_url is not None:
            pulumi.set(__self__, "runbook_url", runbook_url)
        if tip is not None:
            pulumi.set(__self__, "tip", tip)

    @property
    @pulumi.getter(name="detectLabel")
    def detect_label(self) -> pulumi.Input[str]:
        """
        A detect label which matches a detect label within `program_text`.
        """
        return pulumi.get(self, "detect_label")

    @detect_label.setter
    def detect_label(self, value: pulumi.Input[str]):
        pulumi.set(self, "detect_label", value)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[str]:
        """
        The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[str]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, notifications and events will not be generated for the detect label. `false` by default.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notifications", value)

    @property
    @pulumi.getter(name="parameterizedBody")
    def parameterized_body(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
        """
        return pulumi.get(self, "parameterized_body")

    @parameterized_body.setter
    def parameterized_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_body", value)

    @property
    @pulumi.getter(name="parameterizedSubject")
    def parameterized_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
        """
        return pulumi.get(self, "parameterized_subject")

    @parameterized_subject.setter
    def parameterized_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_subject", value)

    @property
    @pulumi.getter(name="runbookUrl")
    def runbook_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of page to consult when an alert is triggered. This can be used with custom notification messages.
        """
        return pulumi.get(self, "runbook_url")

    @runbook_url.setter
    def runbook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runbook_url", value)

    @property
    @pulumi.getter
    def tip(self) -> Optional[pulumi.Input[str]]:
        """
        Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
        """
        return pulumi.get(self, "tip")

    @tip.setter
    def tip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tip", value)


@pulumi.input_type
class DetectorVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        :param pulumi.Input[str] color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
               
               **Notes**
               
               Use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.

        **Notes**

        Use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class HeatmapChartColorRangeArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 max_value: Optional[pulumi.Input[float]] = None,
                 min_value: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
        :param pulumi.Input[float] max_value: The maximum value within the coloring range.
        :param pulumi.Input[float] min_value: The minimum value within the coloring range.
        """
        pulumi.set(__self__, "color", color)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum value within the coloring range.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum value within the coloring range.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_value", value)


@pulumi.input_type
class HeatmapChartColorScaleArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 gt: Optional[pulumi.Input[float]] = None,
                 gte: Optional[pulumi.Input[float]] = None,
                 lt: Optional[pulumi.Input[float]] = None,
                 lte: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range.
        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range.
        :param pulumi.Input[float] lt: Indicates the upper threshold non-inclusive value for this range.
        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range.
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def gt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold non-inclusive value for this range.
        """
        return pulumi.get(self, "gt")

    @gt.setter
    def gt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gt", value)

    @property
    @pulumi.getter
    def gte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold inclusive value for this range.
        """
        return pulumi.get(self, "gte")

    @gte.setter
    def gte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gte", value)

    @property
    @pulumi.getter
    def lt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold non-inclusive value for this range.
        """
        return pulumi.get(self, "lt")

    @lt.setter
    def lt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt", value)

    @property
    @pulumi.getter
    def lte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold inclusive value for this range.
        """
        return pulumi.get(self, "lte")

    @lte.setter
    def lte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lte", value)


@pulumi.input_type
class ListChartColorScaleArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 gt: Optional[pulumi.Input[float]] = None,
                 gte: Optional[pulumi.Input[float]] = None,
                 lt: Optional[pulumi.Input[float]] = None,
                 lte: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range.
        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range.
        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range.
        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range.
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def gt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold non-inclusive value for this range.
        """
        return pulumi.get(self, "gt")

    @gt.setter
    def gt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gt", value)

    @property
    @pulumi.getter
    def gte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold inclusive value for this range.
        """
        return pulumi.get(self, "gte")

    @gte.setter
    def gte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gte", value)

    @property
    @pulumi.getter
    def lt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold non-inculsive value for this range.
        """
        return pulumi.get(self, "lt")

    @lt.setter
    def lt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt", value)

    @property
    @pulumi.getter
    def lte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold inclusive value for this range.
        """
        return pulumi.get(self, "lte")

    @lte.setter
    def lte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lte", value)


@pulumi.input_type
class ListChartLegendOptionsFieldArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://dev.splunk.com/observability/docs/signalflow/functions/data_function/) for the time series being displayed.
        :param pulumi.Input[bool] enabled: True or False depending on if you want the property to be shown or hidden.
        """
        pulumi.set(__self__, "property", property)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True or False depending on if you want the property to be shown or hidden.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://dev.splunk.com/observability/docs/signalflow/functions/data_function/) for the time series being displayed.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class ListChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class MetricRulesetAggregationRuleArgs:
    def __init__(__self__, *,
                 aggregators: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]],
                 enabled: pulumi.Input[bool],
                 matchers: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]] aggregators: Aggregator object
        :param pulumi.Input[bool] enabled: When false, this rule will not generate aggregated MTSs
        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]] matchers: Matcher object
        :param pulumi.Input[str] name: name of the aggregation rule
        """
        pulumi.set(__self__, "aggregators", aggregators)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "matchers", matchers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def aggregators(self) -> pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]]:
        """
        Aggregator object
        """
        return pulumi.get(self, "aggregators")

    @aggregators.setter
    def aggregators(self, value: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]]):
        pulumi.set(self, "aggregators", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        When false, this rule will not generate aggregated MTSs
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def matchers(self) -> pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]]:
        """
        Matcher object
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the aggregation rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class MetricRulesetAggregationRuleAggregatorArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 drop_dimensions: pulumi.Input[bool],
                 output_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dimensions: List of dimensions to either be kept or dropped in the new aggregated MTSs
        :param pulumi.Input[bool] drop_dimensions: when true, the specified dimensions will be dropped from the aggregated MTSs
        :param pulumi.Input[str] output_name: name of the new aggregated metric
        :param pulumi.Input[str] type: Type of aggregator. Must always be "rollup"
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "drop_dimensions", drop_dimensions)
        pulumi.set(__self__, "output_name", output_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of dimensions to either be kept or dropped in the new aggregated MTSs
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="dropDimensions")
    def drop_dimensions(self) -> pulumi.Input[bool]:
        """
        when true, the specified dimensions will be dropped from the aggregated MTSs
        """
        return pulumi.get(self, "drop_dimensions")

    @drop_dimensions.setter
    def drop_dimensions(self, value: pulumi.Input[bool]):
        pulumi.set(self, "drop_dimensions", value)

    @property
    @pulumi.getter(name="outputName")
    def output_name(self) -> pulumi.Input[str]:
        """
        name of the new aggregated metric
        """
        return pulumi.get(self, "output_name")

    @output_name.setter
    def output_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of aggregator. Must always be "rollup"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MetricRulesetAggregationRuleMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Type of matcher. Must always be "dimension"
        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]] filters: List of filters to filter the set of input MTSs
        """
        pulumi.set(__self__, "type", type)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of matcher. Must always be "dimension"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]]:
        """
        List of filters to filter the set of input MTSs
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class MetricRulesetAggregationRuleMatcherFilterArgs:
    def __init__(__self__, *,
                 not_: pulumi.Input[bool],
                 property: pulumi.Input[str],
                 property_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[bool] not_: When true, this filter will match all values not matching the property_values
        :param pulumi.Input[str] property: Name of the dimension
        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_values: Value of the dimension
        """
        pulumi.set(__self__, "not_", not_)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "property_values", property_values)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> pulumi.Input[bool]:
        """
        When true, this filter will match all values not matching the property_values
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: pulumi.Input[bool]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Value of the dimension
        """
        return pulumi.get(self, "property_values")

    @property_values.setter
    def property_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "property_values", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        Name of the dimension
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class MetricRulesetRoutingRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: end destination of the input metric. Must be `RealTime` or `Drop`
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        end destination of the input metric. Must be `RealTime` or `Drop`
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class OrgTokenDpmLimitsArgs:
    def __init__(__self__, *,
                 dpm_limit: pulumi.Input[int],
                 dpm_notification_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] dpm_limit: The datapoints per minute (dpm) limit for this token. If you exceed this limit, Splunk Observability Cloud sends out an alert.
        :param pulumi.Input[int] dpm_notification_threshold: DPM level at which Splunk Observability Cloud sends the notification for this token. If you don't specify a notification, Splunk Observability Cloud sends the generic notification.
        """
        pulumi.set(__self__, "dpm_limit", dpm_limit)
        if dpm_notification_threshold is not None:
            pulumi.set(__self__, "dpm_notification_threshold", dpm_notification_threshold)

    @property
    @pulumi.getter(name="dpmLimit")
    def dpm_limit(self) -> pulumi.Input[int]:
        """
        The datapoints per minute (dpm) limit for this token. If you exceed this limit, Splunk Observability Cloud sends out an alert.
        """
        return pulumi.get(self, "dpm_limit")

    @dpm_limit.setter
    def dpm_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "dpm_limit", value)

    @property
    @pulumi.getter(name="dpmNotificationThreshold")
    def dpm_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        DPM level at which Splunk Observability Cloud sends the notification for this token. If you don't specify a notification, Splunk Observability Cloud sends the generic notification.
        """
        return pulumi.get(self, "dpm_notification_threshold")

    @dpm_notification_threshold.setter
    def dpm_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dpm_notification_threshold", value)


@pulumi.input_type
class OrgTokenHostOrUsageLimitsArgs:
    def __init__(__self__, *,
                 container_limit: Optional[pulumi.Input[int]] = None,
                 container_notification_threshold: Optional[pulumi.Input[int]] = None,
                 custom_metrics_limit: Optional[pulumi.Input[int]] = None,
                 custom_metrics_notification_threshold: Optional[pulumi.Input[int]] = None,
                 high_res_metrics_limit: Optional[pulumi.Input[int]] = None,
                 high_res_metrics_notification_threshold: Optional[pulumi.Input[int]] = None,
                 host_limit: Optional[pulumi.Input[int]] = None,
                 host_notification_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] container_limit: Max number of Docker containers that can use this token
        :param pulumi.Input[int] container_notification_threshold: Notification threshold for Docker containers
        :param pulumi.Input[int] custom_metrics_limit: Max number of custom metrics that can be sent with this token
        :param pulumi.Input[int] custom_metrics_notification_threshold: Notification threshold for custom metrics
        :param pulumi.Input[int] high_res_metrics_limit: Max number of hi-res metrics that can be sent with this toke
        :param pulumi.Input[int] high_res_metrics_notification_threshold: Notification threshold for hi-res metrics
        :param pulumi.Input[int] host_limit: Max number of hosts that can use this token
        :param pulumi.Input[int] host_notification_threshold: Notification threshold for hosts
        """
        if container_limit is not None:
            pulumi.set(__self__, "container_limit", container_limit)
        if container_notification_threshold is not None:
            pulumi.set(__self__, "container_notification_threshold", container_notification_threshold)
        if custom_metrics_limit is not None:
            pulumi.set(__self__, "custom_metrics_limit", custom_metrics_limit)
        if custom_metrics_notification_threshold is not None:
            pulumi.set(__self__, "custom_metrics_notification_threshold", custom_metrics_notification_threshold)
        if high_res_metrics_limit is not None:
            pulumi.set(__self__, "high_res_metrics_limit", high_res_metrics_limit)
        if high_res_metrics_notification_threshold is not None:
            pulumi.set(__self__, "high_res_metrics_notification_threshold", high_res_metrics_notification_threshold)
        if host_limit is not None:
            pulumi.set(__self__, "host_limit", host_limit)
        if host_notification_threshold is not None:
            pulumi.set(__self__, "host_notification_threshold", host_notification_threshold)

    @property
    @pulumi.getter(name="containerLimit")
    def container_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of Docker containers that can use this token
        """
        return pulumi.get(self, "container_limit")

    @container_limit.setter
    def container_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_limit", value)

    @property
    @pulumi.getter(name="containerNotificationThreshold")
    def container_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for Docker containers
        """
        return pulumi.get(self, "container_notification_threshold")

    @container_notification_threshold.setter
    def container_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_notification_threshold", value)

    @property
    @pulumi.getter(name="customMetricsLimit")
    def custom_metrics_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of custom metrics that can be sent with this token
        """
        return pulumi.get(self, "custom_metrics_limit")

    @custom_metrics_limit.setter
    def custom_metrics_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_metrics_limit", value)

    @property
    @pulumi.getter(name="customMetricsNotificationThreshold")
    def custom_metrics_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for custom metrics
        """
        return pulumi.get(self, "custom_metrics_notification_threshold")

    @custom_metrics_notification_threshold.setter
    def custom_metrics_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_metrics_notification_threshold", value)

    @property
    @pulumi.getter(name="highResMetricsLimit")
    def high_res_metrics_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of hi-res metrics that can be sent with this toke
        """
        return pulumi.get(self, "high_res_metrics_limit")

    @high_res_metrics_limit.setter
    def high_res_metrics_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "high_res_metrics_limit", value)

    @property
    @pulumi.getter(name="highResMetricsNotificationThreshold")
    def high_res_metrics_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for hi-res metrics
        """
        return pulumi.get(self, "high_res_metrics_notification_threshold")

    @high_res_metrics_notification_threshold.setter
    def high_res_metrics_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "high_res_metrics_notification_threshold", value)

    @property
    @pulumi.getter(name="hostLimit")
    def host_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of hosts that can use this token
        """
        return pulumi.get(self, "host_limit")

    @host_limit.setter
    def host_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "host_limit", value)

    @property
    @pulumi.getter(name="hostNotificationThreshold")
    def host_notification_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Notification threshold for hosts
        """
        return pulumi.get(self, "host_notification_threshold")

    @host_notification_threshold.setter
    def host_notification_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "host_notification_threshold", value)


@pulumi.input_type
class SingleValueChartColorScaleArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 gt: Optional[pulumi.Input[float]] = None,
                 gte: Optional[pulumi.Input[float]] = None,
                 lt: Optional[pulumi.Input[float]] = None,
                 lte: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range.
        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range.
        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range.
        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range.
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def gt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold non-inclusive value for this range.
        """
        return pulumi.get(self, "gt")

    @gt.setter
    def gt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gt", value)

    @property
    @pulumi.getter
    def gte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lower threshold inclusive value for this range.
        """
        return pulumi.get(self, "gte")

    @gte.setter
    def gte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gte", value)

    @property
    @pulumi.getter
    def lt(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold non-inculsive value for this range.
        """
        return pulumi.get(self, "lt")

    @lt.setter
    def lt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt", value)

    @property
    @pulumi.getter
    def lte(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the upper threshold inclusive value for this range.
        """
        return pulumi.get(self, "lte")

    @lte.setter
    def lte(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lte", value)


@pulumi.input_type
class SingleValueChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class SloInputArgs:
    def __init__(__self__, *,
                 program_text: pulumi.Input[str],
                 good_events_label: Optional[pulumi.Input[str]] = None,
                 total_events_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] program_text: SignalFlow program and arguments text strings that define the streams used as successful event count and total event count
        :param pulumi.Input[str] good_events_label: Label used in `"program_text"` that refers to the data block which contains the stream of successful events
        :param pulumi.Input[str] total_events_label: Label used in `"program_text"` that refers to the data block which contains the stream of total events
        """
        pulumi.set(__self__, "program_text", program_text)
        if good_events_label is not None:
            pulumi.set(__self__, "good_events_label", good_events_label)
        if total_events_label is not None:
            pulumi.set(__self__, "total_events_label", total_events_label)

    @property
    @pulumi.getter(name="programText")
    def program_text(self) -> pulumi.Input[str]:
        """
        SignalFlow program and arguments text strings that define the streams used as successful event count and total event count
        """
        return pulumi.get(self, "program_text")

    @program_text.setter
    def program_text(self, value: pulumi.Input[str]):
        pulumi.set(self, "program_text", value)

    @property
    @pulumi.getter(name="goodEventsLabel")
    def good_events_label(self) -> Optional[pulumi.Input[str]]:
        """
        Label used in `"program_text"` that refers to the data block which contains the stream of successful events
        """
        return pulumi.get(self, "good_events_label")

    @good_events_label.setter
    def good_events_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "good_events_label", value)

    @property
    @pulumi.getter(name="totalEventsLabel")
    def total_events_label(self) -> Optional[pulumi.Input[str]]:
        """
        Label used in `"program_text"` that refers to the data block which contains the stream of total events
        """
        return pulumi.get(self, "total_events_label")

    @total_events_label.setter
    def total_events_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "total_events_label", value)


@pulumi.input_type
class SloTargetArgs:
    def __init__(__self__, *,
                 alert_rules: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]],
                 slo: pulumi.Input[float],
                 type: pulumi.Input[str],
                 compliance_period: Optional[pulumi.Input[str]] = None,
                 cycle_start: Optional[pulumi.Input[str]] = None,
                 cycle_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]] alert_rules: List of alert rules you want to set for this SLO target. An SLO alert rule of type BREACH is always required.
        :param pulumi.Input[float] slo: Target value in the form of a percentage
        :param pulumi.Input[str] type: SLO target type can be the following type: `"RollingWindow"`, `"CalendarWindow"`
        :param pulumi.Input[str] compliance_period: Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
        :param pulumi.Input[str] cycle_start: It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
        :param pulumi.Input[str] cycle_type: The cycle type of the calendar window, e.g. week, month.
        """
        pulumi.set(__self__, "alert_rules", alert_rules)
        pulumi.set(__self__, "slo", slo)
        pulumi.set(__self__, "type", type)
        if compliance_period is not None:
            pulumi.set(__self__, "compliance_period", compliance_period)
        if cycle_start is not None:
            pulumi.set(__self__, "cycle_start", cycle_start)
        if cycle_type is not None:
            pulumi.set(__self__, "cycle_type", cycle_type)

    @property
    @pulumi.getter(name="alertRules")
    def alert_rules(self) -> pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]]:
        """
        List of alert rules you want to set for this SLO target. An SLO alert rule of type BREACH is always required.
        """
        return pulumi.get(self, "alert_rules")

    @alert_rules.setter
    def alert_rules(self, value: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]]):
        pulumi.set(self, "alert_rules", value)

    @property
    @pulumi.getter
    def slo(self) -> pulumi.Input[float]:
        """
        Target value in the form of a percentage
        """
        return pulumi.get(self, "slo")

    @slo.setter
    def slo(self, value: pulumi.Input[float]):
        pulumi.set(self, "slo", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        SLO target type can be the following type: `"RollingWindow"`, `"CalendarWindow"`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="compliancePeriod")
    def compliance_period(self) -> Optional[pulumi.Input[str]]:
        """
        Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
        """
        return pulumi.get(self, "compliance_period")

    @compliance_period.setter
    def compliance_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compliance_period", value)

    @property
    @pulumi.getter(name="cycleStart")
    def cycle_start(self) -> Optional[pulumi.Input[str]]:
        """
        It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
        """
        return pulumi.get(self, "cycle_start")

    @cycle_start.setter
    def cycle_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cycle_start", value)

    @property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> Optional[pulumi.Input[str]]:
        """
        The cycle type of the calendar window, e.g. week, month.
        """
        return pulumi.get(self, "cycle_type")

    @cycle_type.setter
    def cycle_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cycle_type", value)


@pulumi.input_type
class SloTargetAlertRuleArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]] rules: Set of rules used for alerting.
        :param pulumi.Input[str] type: SLO alert rule can be one of the following types: BREACH, ERROR_BUDGET_LEFT, BURN_RATE. Within an SLO object, you can only specify one SLO alert_rule per type. For example, you can't specify two alert_rule of type BREACH. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        """
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]]:
        """
        Set of rules used for alerting.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        SLO alert rule can be one of the following types: BREACH, ERROR_BUDGET_LEFT, BURN_RATE. Within an SLO object, you can only specify one SLO alert_rule per type. For example, you can't specify two alert_rule of type BREACH. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SloTargetAlertRuleRuleArgs:
    def __init__(__self__, *,
                 severity: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parameterized_body: Optional[pulumi.Input[str]] = None,
                 parameterized_subject: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input['SloTargetAlertRuleRuleParametersArgs']] = None,
                 runbook_url: Optional[pulumi.Input[str]] = None,
                 tip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] severity: The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
        :param pulumi.Input[str] description: Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
        :param pulumi.Input[bool] disabled: When true, notifications and events will not be generated for the detect label. `false` by default.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See [Create SLO](https://dev.splunk.com/observability/reference/api/slo/latest#endpoint-create-new-slo) for more info.
        :param pulumi.Input[str] parameterized_body: Custom notification message body when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
        :param pulumi.Input[str] parameterized_subject: Custom notification message subject when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
        :param pulumi.Input['SloTargetAlertRuleRuleParametersArgs'] parameters: Parameters for the SLO alert rule. Each SLO alert rule type accepts different parameters. If not specified, default parameters are used.
        :param pulumi.Input[str] runbook_url: URL of page to consult when an alert is triggered. This can be used with custom notification messages.
        :param pulumi.Input[str] tip: Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
        """
        pulumi.set(__self__, "severity", severity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if parameterized_body is not None:
            pulumi.set(__self__, "parameterized_body", parameterized_body)
        if parameterized_subject is not None:
            pulumi.set(__self__, "parameterized_subject", parameterized_subject)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if runbook_url is not None:
            pulumi.set(__self__, "runbook_url", runbook_url)
        if tip is not None:
            pulumi.set(__self__, "tip", tip)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[str]:
        """
        The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[str]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, notifications and events will not be generated for the detect label. `false` by default.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings specifying where notifications will be sent when an incident occurs. See [Create SLO](https://dev.splunk.com/observability/reference/api/slo/latest#endpoint-create-new-slo) for more info.
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notifications", value)

    @property
    @pulumi.getter(name="parameterizedBody")
    def parameterized_body(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message body when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
        """
        return pulumi.get(self, "parameterized_body")

    @parameterized_body.setter
    def parameterized_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_body", value)

    @property
    @pulumi.getter(name="parameterizedSubject")
    def parameterized_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Custom notification message subject when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
        """
        return pulumi.get(self, "parameterized_subject")

    @parameterized_subject.setter
    def parameterized_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameterized_subject", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['SloTargetAlertRuleRuleParametersArgs']]:
        """
        Parameters for the SLO alert rule. Each SLO alert rule type accepts different parameters. If not specified, default parameters are used.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['SloTargetAlertRuleRuleParametersArgs']]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="runbookUrl")
    def runbook_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of page to consult when an alert is triggered. This can be used with custom notification messages.
        """
        return pulumi.get(self, "runbook_url")

    @runbook_url.setter
    def runbook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runbook_url", value)

    @property
    @pulumi.getter
    def tip(self) -> Optional[pulumi.Input[str]]:
        """
        Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
        """
        return pulumi.get(self, "tip")

    @tip.setter
    def tip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tip", value)


@pulumi.input_type
class SloTargetAlertRuleRuleParametersArgs:
    def __init__(__self__, *,
                 burn_rate_threshold1: Optional[pulumi.Input[float]] = None,
                 burn_rate_threshold2: Optional[pulumi.Input[float]] = None,
                 fire_lasting: Optional[pulumi.Input[str]] = None,
                 long_window1: Optional[pulumi.Input[str]] = None,
                 long_window2: Optional[pulumi.Input[str]] = None,
                 percent_error_budget_left: Optional[pulumi.Input[float]] = None,
                 percent_of_lasting: Optional[pulumi.Input[float]] = None,
                 short_window1: Optional[pulumi.Input[str]] = None,
                 short_window2: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] burn_rate_threshold1: Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        :param pulumi.Input[float] burn_rate_threshold2: Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        :param pulumi.Input[str] fire_lasting: Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the fireLasting parameter. Default: `"5m"`
        :param pulumi.Input[str] long_window1: Long window 1 used in burn rate alert calculation. This value must be longer than `"short_window_1"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        :param pulumi.Input[str] long_window2: Long window 2 used in burn rate alert calculation. This value must be longer than `"short_window_2"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        :param pulumi.Input[float] percent_error_budget_left: Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_error_budget_left"` parameter. Default: `100`
        :param pulumi.Input[float] percent_of_lasting: Percentage of the `"fire_lasting"` duration that the alert condition is met before the alert is triggered. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_of_lasting"` parameter. Default: `100`
        :param pulumi.Input[str] short_window1: Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_1"`. Note: `"BURN_RATE"` alert rules use the `"short_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        :param pulumi.Input[str] short_window2: Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_2"`. Note: `"BURN_RATE"` alert rules use the `"short_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        """
        if burn_rate_threshold1 is not None:
            pulumi.set(__self__, "burn_rate_threshold1", burn_rate_threshold1)
        if burn_rate_threshold2 is not None:
            pulumi.set(__self__, "burn_rate_threshold2", burn_rate_threshold2)
        if fire_lasting is not None:
            pulumi.set(__self__, "fire_lasting", fire_lasting)
        if long_window1 is not None:
            pulumi.set(__self__, "long_window1", long_window1)
        if long_window2 is not None:
            pulumi.set(__self__, "long_window2", long_window2)
        if percent_error_budget_left is not None:
            pulumi.set(__self__, "percent_error_budget_left", percent_error_budget_left)
        if percent_of_lasting is not None:
            pulumi.set(__self__, "percent_of_lasting", percent_of_lasting)
        if short_window1 is not None:
            pulumi.set(__self__, "short_window1", short_window1)
        if short_window2 is not None:
            pulumi.set(__self__, "short_window2", short_window2)

    @property
    @pulumi.getter(name="burnRateThreshold1")
    def burn_rate_threshold1(self) -> Optional[pulumi.Input[float]]:
        """
        Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        """
        return pulumi.get(self, "burn_rate_threshold1")

    @burn_rate_threshold1.setter
    def burn_rate_threshold1(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "burn_rate_threshold1", value)

    @property
    @pulumi.getter(name="burnRateThreshold2")
    def burn_rate_threshold2(self) -> Optional[pulumi.Input[float]]:
        """
        Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        """
        return pulumi.get(self, "burn_rate_threshold2")

    @burn_rate_threshold2.setter
    def burn_rate_threshold2(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "burn_rate_threshold2", value)

    @property
    @pulumi.getter(name="fireLasting")
    def fire_lasting(self) -> Optional[pulumi.Input[str]]:
        """
        Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the fireLasting parameter. Default: `"5m"`
        """
        return pulumi.get(self, "fire_lasting")

    @fire_lasting.setter
    def fire_lasting(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fire_lasting", value)

    @property
    @pulumi.getter(name="longWindow1")
    def long_window1(self) -> Optional[pulumi.Input[str]]:
        """
        Long window 1 used in burn rate alert calculation. This value must be longer than `"short_window_1"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        """
        return pulumi.get(self, "long_window1")

    @long_window1.setter
    def long_window1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "long_window1", value)

    @property
    @pulumi.getter(name="longWindow2")
    def long_window2(self) -> Optional[pulumi.Input[str]]:
        """
        Long window 2 used in burn rate alert calculation. This value must be longer than `"short_window_2"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        """
        return pulumi.get(self, "long_window2")

    @long_window2.setter
    def long_window2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "long_window2", value)

    @property
    @pulumi.getter(name="percentErrorBudgetLeft")
    def percent_error_budget_left(self) -> Optional[pulumi.Input[float]]:
        """
        Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_error_budget_left"` parameter. Default: `100`
        """
        return pulumi.get(self, "percent_error_budget_left")

    @percent_error_budget_left.setter
    def percent_error_budget_left(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent_error_budget_left", value)

    @property
    @pulumi.getter(name="percentOfLasting")
    def percent_of_lasting(self) -> Optional[pulumi.Input[float]]:
        """
        Percentage of the `"fire_lasting"` duration that the alert condition is met before the alert is triggered. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_of_lasting"` parameter. Default: `100`
        """
        return pulumi.get(self, "percent_of_lasting")

    @percent_of_lasting.setter
    def percent_of_lasting(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent_of_lasting", value)

    @property
    @pulumi.getter(name="shortWindow1")
    def short_window1(self) -> Optional[pulumi.Input[str]]:
        """
        Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_1"`. Note: `"BURN_RATE"` alert rules use the `"short_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        """
        return pulumi.get(self, "short_window1")

    @short_window1.setter
    def short_window1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_window1", value)

    @property
    @pulumi.getter(name="shortWindow2")
    def short_window2(self) -> Optional[pulumi.Input[str]]:
        """
        Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_2"`. Note: `"BURN_RATE"` alert rules use the `"short_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
        """
        return pulumi.get(self, "short_window2")

    @short_window2.setter
    def short_window2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_window2", value)


@pulumi.input_type
class TableChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
        :param pulumi.Input[str] color: Color to use
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label used in the publish statement that displays the plot (metric time series data) you want to customize
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary prefix to display with the value of this plot
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class TimeChartAxisLeftArgs:
    def __init__(__self__, *,
                 high_watermark: Optional[pulumi.Input[float]] = None,
                 high_watermark_label: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 low_watermark: Optional[pulumi.Input[float]] = None,
                 low_watermark_label: Optional[pulumi.Input[str]] = None,
                 max_value: Optional[pulumi.Input[float]] = None,
                 min_value: Optional[pulumi.Input[float]] = None,
                 watermarks: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]] = None):
        """
        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark.
        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line.
        :param pulumi.Input[str] label: Label of the left axis.
        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark.
        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line.
        :param pulumi.Input[float] max_value: The maximum value for the left axis.
        :param pulumi.Input[float] min_value: The minimum value for the left axis.
        """
        if high_watermark is not None:
            pulumi.set(__self__, "high_watermark", high_watermark)
        if high_watermark_label is not None:
            pulumi.set(__self__, "high_watermark_label", high_watermark_label)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if low_watermark is not None:
            pulumi.set(__self__, "low_watermark", low_watermark)
        if low_watermark_label is not None:
            pulumi.set(__self__, "low_watermark_label", low_watermark_label)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if watermarks is not None:
            pulumi.set(__self__, "watermarks", watermarks)

    @property
    @pulumi.getter(name="highWatermark")
    def high_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a high watermark.
        """
        return pulumi.get(self, "high_watermark")

    @high_watermark.setter
    def high_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "high_watermark", value)

    @property
    @pulumi.getter(name="highWatermarkLabel")
    def high_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the high watermark line.
        """
        return pulumi.get(self, "high_watermark_label")

    @high_watermark_label.setter
    def high_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high_watermark_label", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label of the left axis.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="lowWatermark")
    def low_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a low watermark.
        """
        return pulumi.get(self, "low_watermark")

    @low_watermark.setter
    def low_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "low_watermark", value)

    @property
    @pulumi.getter(name="lowWatermarkLabel")
    def low_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the low watermark line.
        """
        return pulumi.get(self, "low_watermark_label")

    @low_watermark_label.setter
    def low_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "low_watermark_label", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum value for the left axis.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum value for the left axis.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter
    def watermarks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]]:
        return pulumi.get(self, "watermarks")

    @watermarks.setter
    def watermarks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]]):
        pulumi.set(self, "watermarks", value)


@pulumi.input_type
class TimeChartAxisLeftWatermarkArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float],
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] value: Axis value where the watermark line will be displayed
        :param pulumi.Input[str] label: Label to display associated with the watermark line
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Axis value where the watermark line will be displayed
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label to display associated with the watermark line
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class TimeChartAxisRightArgs:
    def __init__(__self__, *,
                 high_watermark: Optional[pulumi.Input[float]] = None,
                 high_watermark_label: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 low_watermark: Optional[pulumi.Input[float]] = None,
                 low_watermark_label: Optional[pulumi.Input[str]] = None,
                 max_value: Optional[pulumi.Input[float]] = None,
                 min_value: Optional[pulumi.Input[float]] = None,
                 watermarks: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]] = None):
        """
        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark.
        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line.
        :param pulumi.Input[str] label: Label of the right axis.
        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark.
        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line.
        :param pulumi.Input[float] max_value: The maximum value for the right axis.
        :param pulumi.Input[float] min_value: The minimum value for the right axis.
        """
        if high_watermark is not None:
            pulumi.set(__self__, "high_watermark", high_watermark)
        if high_watermark_label is not None:
            pulumi.set(__self__, "high_watermark_label", high_watermark_label)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if low_watermark is not None:
            pulumi.set(__self__, "low_watermark", low_watermark)
        if low_watermark_label is not None:
            pulumi.set(__self__, "low_watermark_label", low_watermark_label)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if watermarks is not None:
            pulumi.set(__self__, "watermarks", watermarks)

    @property
    @pulumi.getter(name="highWatermark")
    def high_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a high watermark.
        """
        return pulumi.get(self, "high_watermark")

    @high_watermark.setter
    def high_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "high_watermark", value)

    @property
    @pulumi.getter(name="highWatermarkLabel")
    def high_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the high watermark line.
        """
        return pulumi.get(self, "high_watermark_label")

    @high_watermark_label.setter
    def high_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high_watermark_label", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label of the right axis.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="lowWatermark")
    def low_watermark(self) -> Optional[pulumi.Input[float]]:
        """
        A line to draw as a low watermark.
        """
        return pulumi.get(self, "low_watermark")

    @low_watermark.setter
    def low_watermark(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "low_watermark", value)

    @property
    @pulumi.getter(name="lowWatermarkLabel")
    def low_watermark_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label to attach to the low watermark line.
        """
        return pulumi.get(self, "low_watermark_label")

    @low_watermark_label.setter
    def low_watermark_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "low_watermark_label", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum value for the right axis.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum value for the right axis.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter
    def watermarks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]]:
        return pulumi.get(self, "watermarks")

    @watermarks.setter
    def watermarks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]]):
        pulumi.set(self, "watermarks", value)


@pulumi.input_type
class TimeChartAxisRightWatermarkArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float],
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] value: Axis value where the watermark line will be displayed
        :param pulumi.Input[str] label: Label to display associated with the watermark line
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Axis value where the watermark line will be displayed
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label to display associated with the watermark line
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class TimeChartEventOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: Label used in the publish statement that displays the event query you want to customize.
        :param pulumi.Input[str] color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Label used in the publish statement that displays the event query you want to customize.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class TimeChartHistogramOptionArgs:
    def __init__(__self__, *,
                 color_theme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] color_theme: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
        """
        if color_theme is not None:
            pulumi.set(__self__, "color_theme", color_theme)

    @property
    @pulumi.getter(name="colorTheme")
    def color_theme(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
        """
        return pulumi.get(self, "color_theme")

    @color_theme.setter
    def color_theme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_theme", value)


@pulumi.input_type
class TimeChartLegendOptionsFieldArgs:
    def __init__(__self__, *,
                 property: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] property: The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
        :param pulumi.Input[bool] enabled: True or False depending on if you want the property to be shown or hidden.
        """
        pulumi.set(__self__, "property", property)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True or False depending on if you want the property to be shown or hidden.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class TimeChartVizOptionArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 axis: Optional[pulumi.Input[str]] = None,
                 color: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 plot_type: Optional[pulumi.Input[str]] = None,
                 value_prefix: Optional[pulumi.Input[str]] = None,
                 value_suffix: Optional[pulumi.Input[str]] = None,
                 value_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        :param pulumi.Input[str] axis: Y-axis associated with values for this plot. Must be either `right` or `left`.
        :param pulumi.Input[str] color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param pulumi.Input[str] plot_type: The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
        :param pulumi.Input[str] value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        pulumi.set(__self__, "label", label)
        if axis is not None:
            pulumi.set(__self__, "axis", axis)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if plot_type is not None:
            pulumi.set(__self__, "plot_type", plot_type)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def axis(self) -> Optional[pulumi.Input[str]]:
        """
        Y-axis associated with values for this plot. Must be either `right` or `left`.
        """
        return pulumi.get(self, "axis")

    @axis.setter
    def axis(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "axis", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="plotType")
    def plot_type(self) -> Optional[pulumi.Input[str]]:
        """
        The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
        """
        return pulumi.get(self, "plot_type")

    @plot_type.setter
    def plot_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plot_type", value)

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        """
        return pulumi.get(self, "value_prefix")

    @value_prefix.setter
    def value_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_prefix", value)

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        An arbitrary suffix to display with the value of this plot
        """
        return pulumi.get(self, "value_suffix")

    @value_suffix.setter
    def value_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_suffix", value)

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[pulumi.Input[str]]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        return pulumi.get(self, "value_unit")

    @value_unit.setter
    def value_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_unit", value)


@pulumi.input_type
class WebhookIntegrationHeaderArgs:
    def __init__(__self__, *,
                 header_key: pulumi.Input[str],
                 header_value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] header_key: The key of the header to send
        :param pulumi.Input[str] header_value: The value of the header to send
        """
        pulumi.set(__self__, "header_key", header_key)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerKey")
    def header_key(self) -> pulumi.Input[str]:
        """
        The key of the header to send
        """
        return pulumi.get(self, "header_key")

    @header_key.setter
    def header_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_key", value)

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> pulumi.Input[str]:
        """
        The value of the header to send
        """
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_value", value)


