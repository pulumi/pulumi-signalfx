# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AlertMutingRuleFilter',
    'DashboardChart',
    'DashboardColumn',
    'DashboardEventOverlay',
    'DashboardEventOverlaySource',
    'DashboardFilter',
    'DashboardGrid',
    'DashboardGroupDashboard',
    'DashboardGroupDashboardFilterOverride',
    'DashboardGroupDashboardVariableOverride',
    'DashboardGroupImportQualifier',
    'DashboardGroupImportQualifierFilter',
    'DashboardGroupPermission',
    'DashboardPermissions',
    'DashboardPermissionsAcl',
    'DashboardSelectedEventOverlay',
    'DashboardSelectedEventOverlaySource',
    'DashboardVariable',
    'DataLinkTargetExternalUrl',
    'DataLinkTargetSignalfxDashboard',
    'DataLinkTargetSplunk',
    'DetectorRule',
    'DetectorVizOption',
    'HeatmapChartColorRange',
    'HeatmapChartColorScale',
    'ListChartColorScale',
    'ListChartLegendOptionsField',
    'ListChartVizOption',
    'MetricRulesetAggregationRule',
    'MetricRulesetAggregationRuleAggregator',
    'MetricRulesetAggregationRuleMatcher',
    'MetricRulesetAggregationRuleMatcherFilter',
    'MetricRulesetRoutingRule',
    'OrgTokenDpmLimits',
    'OrgTokenHostOrUsageLimits',
    'SingleValueChartColorScale',
    'SingleValueChartVizOption',
    'TableChartVizOption',
    'TimeChartAxisLeft',
    'TimeChartAxisLeftWatermark',
    'TimeChartAxisRight',
    'TimeChartAxisRightWatermark',
    'TimeChartEventOption',
    'TimeChartHistogramOption',
    'TimeChartLegendOptionsField',
    'TimeChartVizOption',
    'WebhookIntegrationHeader',
]

@pulumi.output_type
class AlertMutingRuleFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyValue":
            suggest = "property_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertMutingRuleFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertMutingRuleFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertMutingRuleFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property: str,
                 property_value: str,
                 negated: Optional[bool] = None):
        """
        :param str property: The property to filter.
        :param str property_value: The property value to filter.
        :param bool negated: Determines if this is a "not" filter. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "property_value", property_value)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> str:
        """
        The property value to filter.
        """
        return pulumi.get(self, "property_value")

    @property
    @pulumi.getter
    def negated(self) -> Optional[bool]:
        """
        Determines if this is a "not" filter. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        The property to filter.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class DashboardChart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chartId":
            suggest = "chart_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardChart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardChart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardChart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chart_id: str,
                 column: Optional[int] = None,
                 height: Optional[int] = None,
                 row: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param str chart_id: ID of the chart to display.
        :param int column: Column number for the layout.
        :param int height: How many rows every chart should take up (greater than or equal to 1). 1 by default.
        :param int row: The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
        :param int width: How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
        """
        pulumi.set(__self__, "chart_id", chart_id)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if row is not None:
            pulumi.set(__self__, "row", row)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartId")
    def chart_id(self) -> str:
        """
        ID of the chart to display.
        """
        return pulumi.get(self, "chart_id")

    @property
    @pulumi.getter
    def column(self) -> Optional[int]:
        """
        Column number for the layout.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        How many rows every chart should take up (greater than or equal to 1). 1 by default.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def row(self) -> Optional[int]:
        """
        The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
        """
        return pulumi.get(self, "row")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class DashboardColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chartIds":
            suggest = "chart_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chart_ids: Sequence[str],
                 column: Optional[int] = None,
                 height: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param Sequence[str] chart_ids: List of IDs of the charts to display.
        :param int column: Column number for the layout.
        :param int height: How many rows every chart should take up (greater than or equal to 1). 1 by default.
        :param int width: How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
        """
        pulumi.set(__self__, "chart_ids", chart_ids)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartIds")
    def chart_ids(self) -> Sequence[str]:
        """
        List of IDs of the charts to display.
        """
        return pulumi.get(self, "chart_ids")

    @property
    @pulumi.getter
    def column(self) -> Optional[int]:
        """
        Column number for the layout.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        How many rows every chart should take up (greater than or equal to 1). 1 by default.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class DashboardEventOverlay(dict):
    def __init__(__self__, *,
                 signal: str,
                 color: Optional[str] = None,
                 label: Optional[str] = None,
                 line: Optional[bool] = None,
                 sources: Optional[Sequence['outputs.DashboardEventOverlaySource']] = None,
                 type: Optional[str] = None):
        """
        :param str signal: Search term used to choose the events shown in the overlay.
        :param str color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        :param str label: Text shown in the dropdown when selecting this overlay from the menu.
        :param bool line: Show a vertical line for the event. `false` by default.
        :param Sequence['DashboardEventOverlaySourceArgs'] sources: Each element specifies a filter to use against the signal specified in the `signal`.
        :param str type: Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
        """
        pulumi.set(__self__, "signal", signal)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if line is not None:
            pulumi.set(__self__, "line", line)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def signal(self) -> str:
        """
        Search term used to choose the events shown in the overlay.
        """
        return pulumi.get(self, "signal")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Text shown in the dropdown when selecting this overlay from the menu.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def line(self) -> Optional[bool]:
        """
        Show a vertical line for the event. `false` by default.
        """
        return pulumi.get(self, "line")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.DashboardEventOverlaySource']]:
        """
        Each element specifies a filter to use against the signal specified in the `signal`.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardEventOverlaySource(dict):
    def __init__(__self__, *,
                 property: str,
                 values: Sequence[str],
                 negated: Optional[bool] = None):
        """
        :param str property: The name of a dimension to filter against.
        :param Sequence[str] values: A list of values to be used with the `property`, they will be combined via `OR`.
        :param bool negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to be used with the `property`, they will be combined via `OR`.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def negated(self) -> Optional[bool]:
        """
        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        The name of a dimension to filter against.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class DashboardFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyIfExist":
            suggest = "apply_if_exist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property: str,
                 values: Sequence[str],
                 apply_if_exist: Optional[bool] = None,
                 negated: Optional[bool] = None):
        """
        :param str property: The name of a dimension to filter against.
        :param Sequence[str] values: A list of values to be used with the `property`, they will be combined via `OR`.
        :param bool apply_if_exist: If true, this variable will also match data that doesn't have this property at all.
        :param bool negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if apply_if_exist is not None:
            pulumi.set(__self__, "apply_if_exist", apply_if_exist)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to be used with the `property`, they will be combined via `OR`.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="applyIfExist")
    def apply_if_exist(self) -> Optional[bool]:
        """
        If true, this variable will also match data that doesn't have this property at all.
        """
        return pulumi.get(self, "apply_if_exist")

    @property
    @pulumi.getter
    def negated(self) -> Optional[bool]:
        """
        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        The name of a dimension to filter against.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class DashboardGrid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chartIds":
            suggest = "chart_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGrid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGrid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGrid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chart_ids: Sequence[str],
                 height: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param Sequence[str] chart_ids: List of IDs of the charts to display.
        :param int height: How many rows every chart should take up (greater than or equal to 1). 1 by default.
        :param int width: How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
        """
        pulumi.set(__self__, "chart_ids", chart_ids)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="chartIds")
    def chart_ids(self) -> Sequence[str]:
        """
        List of IDs of the charts to display.
        """
        return pulumi.get(self, "chart_ids")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        How many rows every chart should take up (greater than or equal to 1). 1 by default.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class DashboardGroupDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardId":
            suggest = "dashboard_id"
        elif key == "configId":
            suggest = "config_id"
        elif key == "descriptionOverride":
            suggest = "description_override"
        elif key == "filterOverrides":
            suggest = "filter_overrides"
        elif key == "nameOverride":
            suggest = "name_override"
        elif key == "variableOverrides":
            suggest = "variable_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGroupDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGroupDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGroupDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_id: str,
                 config_id: Optional[str] = None,
                 description_override: Optional[str] = None,
                 filter_overrides: Optional[Sequence['outputs.DashboardGroupDashboardFilterOverride']] = None,
                 name_override: Optional[str] = None,
                 variable_overrides: Optional[Sequence['outputs.DashboardGroupDashboardVariableOverride']] = None):
        """
        :param str dashboard_id: The dashboard id to mirror
        :param str description_override: The description that will override the original dashboards's description.
        :param Sequence['DashboardGroupDashboardFilterOverrideArgs'] filter_overrides: The description that will override the original dashboards's description.
        :param str name_override: The name that will override the original dashboards's name.
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if config_id is not None:
            pulumi.set(__self__, "config_id", config_id)
        if description_override is not None:
            pulumi.set(__self__, "description_override", description_override)
        if filter_overrides is not None:
            pulumi.set(__self__, "filter_overrides", filter_overrides)
        if name_override is not None:
            pulumi.set(__self__, "name_override", name_override)
        if variable_overrides is not None:
            pulumi.set(__self__, "variable_overrides", variable_overrides)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> str:
        """
        The dashboard id to mirror
        """
        return pulumi.get(self, "dashboard_id")

    @property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[str]:
        return pulumi.get(self, "config_id")

    @property
    @pulumi.getter(name="descriptionOverride")
    def description_override(self) -> Optional[str]:
        """
        The description that will override the original dashboards's description.
        """
        return pulumi.get(self, "description_override")

    @property
    @pulumi.getter(name="filterOverrides")
    def filter_overrides(self) -> Optional[Sequence['outputs.DashboardGroupDashboardFilterOverride']]:
        """
        The description that will override the original dashboards's description.
        """
        return pulumi.get(self, "filter_overrides")

    @property
    @pulumi.getter(name="nameOverride")
    def name_override(self) -> Optional[str]:
        """
        The name that will override the original dashboards's name.
        """
        return pulumi.get(self, "name_override")

    @property
    @pulumi.getter(name="variableOverrides")
    def variable_overrides(self) -> Optional[Sequence['outputs.DashboardGroupDashboardVariableOverride']]:
        return pulumi.get(self, "variable_overrides")


@pulumi.output_type
class DashboardGroupDashboardFilterOverride(dict):
    def __init__(__self__, *,
                 property: str,
                 values: Sequence[str],
                 negated: Optional[bool] = None):
        """
        :param str property: A metric time series dimension or property name.
        :param Sequence[str] values: (Optional) List of of strings (which will be treated as an OR filter on the property).
        :param bool negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        (Optional) List of of strings (which will be treated as an OR filter on the property).
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def negated(self) -> Optional[bool]:
        """
        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        A metric time series dimension or property name.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class DashboardGroupDashboardVariableOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valuesSuggesteds":
            suggest = "values_suggesteds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGroupDashboardVariableOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGroupDashboardVariableOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGroupDashboardVariableOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property: str,
                 values: Optional[Sequence[str]] = None,
                 values_suggesteds: Optional[Sequence[str]] = None):
        """
        :param str property: A metric time series dimension or property name.
        :param Sequence[str] values: (Optional) List of of strings (which will be treated as an OR filter on the property).
        :param Sequence[str] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
        """
        pulumi.set(__self__, "property", property)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if values_suggesteds is not None:
            pulumi.set(__self__, "values_suggesteds", values_suggesteds)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        (Optional) List of of strings (which will be treated as an OR filter on the property).
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="valuesSuggesteds")
    def values_suggesteds(self) -> Optional[Sequence[str]]:
        """
        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
        """
        return pulumi.get(self, "values_suggesteds")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        A metric time series dimension or property name.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class DashboardGroupImportQualifier(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.DashboardGroupImportQualifierFilter']] = None,
                 metric: Optional[str] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.DashboardGroupImportQualifierFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardGroupImportQualifierFilter(dict):
    def __init__(__self__, *,
                 property: str,
                 values: Sequence[str],
                 negated: Optional[bool] = None):
        """
        :param str property: A metric time series dimension or property name.
        :param Sequence[str] values: (Optional) List of of strings (which will be treated as an OR filter on the property).
        :param bool negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        (Optional) List of of strings (which will be treated as an OR filter on the property).
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def negated(self) -> Optional[bool]:
        """
        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        A metric time series dimension or property name.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class DashboardGroupPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "principalType":
            suggest = "principal_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGroupPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGroupPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGroupPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 principal_type: str,
                 actions: Optional[Sequence[str]] = None):
        """
        :param str principal_id: ID of the user, team, or organization for which you're granting permissions.
        :param str principal_type: Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
        :param Sequence[str] actions: Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "principal_type", principal_type)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        ID of the user, team, or organization for which you're granting permissions.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> str:
        """
        Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
        """
        return pulumi.get(self, "principal_type")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DashboardPermissions(dict):
    def __init__(__self__, *,
                 acls: Optional[Sequence['outputs.DashboardPermissionsAcl']] = None,
                 parent: Optional[str] = None):
        """
        :param Sequence['DashboardPermissionsAclArgs'] acls: List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
        :param str parent: ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
        """
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if parent is not None:
            pulumi.set(__self__, "parent", parent)

    @property
    @pulumi.getter
    def acls(self) -> Optional[Sequence['outputs.DashboardPermissionsAcl']]:
        """
        List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
        """
        return pulumi.get(self, "acls")

    @property
    @pulumi.getter
    def parent(self) -> Optional[str]:
        """
        ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
        """
        return pulumi.get(self, "parent")


@pulumi.output_type
class DashboardPermissionsAcl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "principalType":
            suggest = "principal_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPermissionsAcl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPermissionsAcl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPermissionsAcl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 principal_type: str,
                 actions: Optional[Sequence[str]] = None):
        """
        :param str principal_id: ID of the user, team, or organization for which you're granting permissions.
        :param str principal_type: Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
        :param Sequence[str] actions: Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "principal_type", principal_type)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        ID of the user, team, or organization for which you're granting permissions.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> str:
        """
        Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
        """
        return pulumi.get(self, "principal_type")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DashboardSelectedEventOverlay(dict):
    def __init__(__self__, *,
                 signal: str,
                 sources: Optional[Sequence['outputs.DashboardSelectedEventOverlaySource']] = None,
                 type: Optional[str] = None):
        """
        :param str signal: Search term used to choose the events shown in the overlay.
        :param Sequence['DashboardSelectedEventOverlaySourceArgs'] sources: Each element specifies a filter to use against the signal specified in the `signal`.
        :param str type: Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
        """
        pulumi.set(__self__, "signal", signal)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def signal(self) -> str:
        """
        Search term used to choose the events shown in the overlay.
        """
        return pulumi.get(self, "signal")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.DashboardSelectedEventOverlaySource']]:
        """
        Each element specifies a filter to use against the signal specified in the `signal`.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardSelectedEventOverlaySource(dict):
    def __init__(__self__, *,
                 property: str,
                 values: Sequence[str],
                 negated: Optional[bool] = None):
        """
        :param str property: The name of a dimension to filter against.
        :param Sequence[str] values: A list of values to be used with the `property`, they will be combined via `OR`.
        :param bool negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to be used with the `property`, they will be combined via `OR`.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def negated(self) -> Optional[bool]:
        """
        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
        """
        return pulumi.get(self, "negated")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        The name of a dimension to filter against.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class DashboardVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyIfExist":
            suggest = "apply_if_exist"
        elif key == "replaceOnly":
            suggest = "replace_only"
        elif key == "restrictedSuggestions":
            suggest = "restricted_suggestions"
        elif key == "valueRequired":
            suggest = "value_required"
        elif key == "valuesSuggesteds":
            suggest = "values_suggesteds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: str,
                 property: str,
                 apply_if_exist: Optional[bool] = None,
                 description: Optional[str] = None,
                 replace_only: Optional[bool] = None,
                 restricted_suggestions: Optional[bool] = None,
                 value_required: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None,
                 values_suggesteds: Optional[Sequence[str]] = None):
        """
        :param str alias: An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
        :param str property: The name of a dimension to filter against.
        :param bool apply_if_exist: If true, this variable will also match data that doesn't have this property at all.
        :param str description: Variable description.
        :param bool replace_only: If `true`, this variable will only apply to charts that have a filter for the property.
        :param bool restricted_suggestions: If `true`, this variable may only be set to the values listed in `values_suggested` and only these values will appear in autosuggestion menus. `false` by default.
        :param bool value_required: Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
        :param Sequence[str] values: A list of values to be used with the `property`, they will be combined via `OR`.
        :param Sequence[str] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "property", property)
        if apply_if_exist is not None:
            pulumi.set(__self__, "apply_if_exist", apply_if_exist)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if replace_only is not None:
            pulumi.set(__self__, "replace_only", replace_only)
        if restricted_suggestions is not None:
            pulumi.set(__self__, "restricted_suggestions", restricted_suggestions)
        if value_required is not None:
            pulumi.set(__self__, "value_required", value_required)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if values_suggesteds is not None:
            pulumi.set(__self__, "values_suggesteds", values_suggesteds)

    @property
    @pulumi.getter
    def alias(self) -> str:
        """
        An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="applyIfExist")
    def apply_if_exist(self) -> Optional[bool]:
        """
        If true, this variable will also match data that doesn't have this property at all.
        """
        return pulumi.get(self, "apply_if_exist")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Variable description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="replaceOnly")
    def replace_only(self) -> Optional[bool]:
        """
        If `true`, this variable will only apply to charts that have a filter for the property.
        """
        return pulumi.get(self, "replace_only")

    @property
    @pulumi.getter(name="restrictedSuggestions")
    def restricted_suggestions(self) -> Optional[bool]:
        """
        If `true`, this variable may only be set to the values listed in `values_suggested` and only these values will appear in autosuggestion menus. `false` by default.
        """
        return pulumi.get(self, "restricted_suggestions")

    @property
    @pulumi.getter(name="valueRequired")
    def value_required(self) -> Optional[bool]:
        """
        Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
        """
        return pulumi.get(self, "value_required")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        A list of values to be used with the `property`, they will be combined via `OR`.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="valuesSuggesteds")
    def values_suggesteds(self) -> Optional[Sequence[str]]:
        """
        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
        """
        return pulumi.get(self, "values_suggesteds")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        The name of a dimension to filter against.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class DataLinkTargetExternalUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumTimeWindow":
            suggest = "minimum_time_window"
        elif key == "propertyKeyMapping":
            suggest = "property_key_mapping"
        elif key == "timeFormat":
            suggest = "time_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLinkTargetExternalUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLinkTargetExternalUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLinkTargetExternalUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 url: str,
                 minimum_time_window: Optional[str] = None,
                 property_key_mapping: Optional[Mapping[str, str]] = None,
                 time_format: Optional[str] = None):
        """
        :param str name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param str url: URL string for a Splunk instance or external system data link target. [See the supported template variables](https://developers.signalfx.com/administration/data_links_overview.html#_external_link_targets).
        :param str minimum_time_window: The [minimum time window](https://developers.signalfx.com/administration/data_links_overview.html#_minimum_time_window) for a search sent to an external site. Defaults to `6000`
        :param Mapping[str, str] property_key_mapping: Describes the relationship between SignalFx metadata keys and external system properties when the key names are different.
        :param str time_format: [Designates the format](https://developers.signalfx.com/administration/data_links_overview.html#_minimum_time_window) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if minimum_time_window is not None:
            pulumi.set(__self__, "minimum_time_window", minimum_time_window)
        if property_key_mapping is not None:
            pulumi.set(__self__, "property_key_mapping", property_key_mapping)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL string for a Splunk instance or external system data link target. [See the supported template variables](https://developers.signalfx.com/administration/data_links_overview.html#_external_link_targets).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="minimumTimeWindow")
    def minimum_time_window(self) -> Optional[str]:
        """
        The [minimum time window](https://developers.signalfx.com/administration/data_links_overview.html#_minimum_time_window) for a search sent to an external site. Defaults to `6000`
        """
        return pulumi.get(self, "minimum_time_window")

    @property
    @pulumi.getter(name="propertyKeyMapping")
    def property_key_mapping(self) -> Optional[Mapping[str, str]]:
        """
        Describes the relationship between SignalFx metadata keys and external system properties when the key names are different.
        """
        return pulumi.get(self, "property_key_mapping")

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[str]:
        """
        [Designates the format](https://developers.signalfx.com/administration/data_links_overview.html#_minimum_time_window) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
        """
        return pulumi.get(self, "time_format")


@pulumi.output_type
class DataLinkTargetSignalfxDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardGroupId":
            suggest = "dashboard_group_id"
        elif key == "dashboardId":
            suggest = "dashboard_id"
        elif key == "isDefault":
            suggest = "is_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLinkTargetSignalfxDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLinkTargetSignalfxDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLinkTargetSignalfxDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_group_id: str,
                 dashboard_id: str,
                 name: str,
                 is_default: Optional[bool] = None):
        """
        :param str dashboard_group_id: SignalFx-assigned ID of the dashboard link target's dashboard group
        :param str dashboard_id: SignalFx-assigned ID of the dashboard link target
        :param str name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param bool is_default: Flag that designates a target as the default for a data link object. `true` by default
        """
        pulumi.set(__self__, "dashboard_group_id", dashboard_group_id)
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        pulumi.set(__self__, "name", name)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)

    @property
    @pulumi.getter(name="dashboardGroupId")
    def dashboard_group_id(self) -> str:
        """
        SignalFx-assigned ID of the dashboard link target's dashboard group
        """
        return pulumi.get(self, "dashboard_group_id")

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> str:
        """
        SignalFx-assigned ID of the dashboard link target
        """
        return pulumi.get(self, "dashboard_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        Flag that designates a target as the default for a data link object. `true` by default
        """
        return pulumi.get(self, "is_default")


@pulumi.output_type
class DataLinkTargetSplunk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyKeyMapping":
            suggest = "property_key_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLinkTargetSplunk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLinkTargetSplunk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLinkTargetSplunk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 property_key_mapping: Optional[Mapping[str, str]] = None):
        """
        :param str name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        :param Mapping[str, str] property_key_mapping: Describes the relationship between SignalFx metadata keys and external system properties when the key names are different.
        """
        pulumi.set(__self__, "name", name)
        if property_key_mapping is not None:
            pulumi.set(__self__, "property_key_mapping", property_key_mapping)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User-assigned target name. Use this value to differentiate between the link targets for a data link object.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="propertyKeyMapping")
    def property_key_mapping(self) -> Optional[Mapping[str, str]]:
        """
        Describes the relationship between SignalFx metadata keys and external system properties when the key names are different.
        """
        return pulumi.get(self, "property_key_mapping")


@pulumi.output_type
class DetectorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectLabel":
            suggest = "detect_label"
        elif key == "parameterizedBody":
            suggest = "parameterized_body"
        elif key == "parameterizedSubject":
            suggest = "parameterized_subject"
        elif key == "runbookUrl":
            suggest = "runbook_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detect_label: str,
                 severity: str,
                 description: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 notifications: Optional[Sequence[str]] = None,
                 parameterized_body: Optional[str] = None,
                 parameterized_subject: Optional[str] = None,
                 runbook_url: Optional[str] = None,
                 tip: Optional[str] = None):
        """
        :param str detect_label: A detect label which matches a detect label within `program_text`.
        :param str severity: The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
        :param str description: Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
        :param bool disabled: When true, notifications and events will not be generated for the detect label. `false` by default.
        :param Sequence[str] notifications: List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://developers.signalfx.com/detectors_reference.html#operation/Create%20Single%20Detector) for more info.
        :param str parameterized_body: Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.signalfx.com/en/latest/detect-alert/set-up-detectors.html#about-detectors#alert-settings) for more info.
        :param str parameterized_subject: Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.signalfx.com/en/latest/detect-alert/set-up-detectors.html#about-detectors#alert-settings) for more info.
        :param str runbook_url: URL of page to consult when an alert is triggered. This can be used with custom notification messages.
        :param str tip: Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
        """
        pulumi.set(__self__, "detect_label", detect_label)
        pulumi.set(__self__, "severity", severity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if parameterized_body is not None:
            pulumi.set(__self__, "parameterized_body", parameterized_body)
        if parameterized_subject is not None:
            pulumi.set(__self__, "parameterized_subject", parameterized_subject)
        if runbook_url is not None:
            pulumi.set(__self__, "runbook_url", runbook_url)
        if tip is not None:
            pulumi.set(__self__, "tip", tip)

    @property
    @pulumi.getter(name="detectLabel")
    def detect_label(self) -> str:
        """
        A detect label which matches a detect label within `program_text`.
        """
        return pulumi.get(self, "detect_label")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        When true, notifications and events will not be generated for the detect label. `false` by default.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[Sequence[str]]:
        """
        List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://developers.signalfx.com/detectors_reference.html#operation/Create%20Single%20Detector) for more info.
        """
        return pulumi.get(self, "notifications")

    @property
    @pulumi.getter(name="parameterizedBody")
    def parameterized_body(self) -> Optional[str]:
        """
        Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.signalfx.com/en/latest/detect-alert/set-up-detectors.html#about-detectors#alert-settings) for more info.
        """
        return pulumi.get(self, "parameterized_body")

    @property
    @pulumi.getter(name="parameterizedSubject")
    def parameterized_subject(self) -> Optional[str]:
        """
        Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.signalfx.com/en/latest/detect-alert/set-up-detectors.html#about-detectors#alert-settings) for more info.
        """
        return pulumi.get(self, "parameterized_subject")

    @property
    @pulumi.getter(name="runbookUrl")
    def runbook_url(self) -> Optional[str]:
        """
        URL of page to consult when an alert is triggered. This can be used with custom notification messages.
        """
        return pulumi.get(self, "runbook_url")

    @property
    @pulumi.getter
    def tip(self) -> Optional[str]:
        """
        Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
        """
        return pulumi.get(self, "tip")


@pulumi.output_type
class DetectorVizOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "valuePrefix":
            suggest = "value_prefix"
        elif key == "valueSuffix":
            suggest = "value_suffix"
        elif key == "valueUnit":
            suggest = "value_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorVizOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorVizOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorVizOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 color: Optional[str] = None,
                 display_name: Optional[str] = None,
                 value_prefix: Optional[str] = None,
                 value_suffix: Optional[str] = None,
                 value_unit: Optional[str] = None):
        """
        :param str label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        :param str color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param str value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
               
               **Notes**
               
               It is highly recommended that you use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives/negatives.
               
               `max_delay` allows SignalFx to continue with computation if there is a lag in receiving data points.
               
               `extrapolation` allows you to specify how to handle missing data. An extrapolation policy can be added to individual signals by updating the data block in your `program_text`.
               
               See [Delayed Datapoints](https://signalfx-product-docs.readthedocs-hosted.com/en/latest/charts/chart-builder.html#delayed-datapoints) for more info.
        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[str]:
        """
        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.

        **Notes**

        It is highly recommended that you use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives/negatives.

        `max_delay` allows SignalFx to continue with computation if there is a lag in receiving data points.

        `extrapolation` allows you to specify how to handle missing data. An extrapolation policy can be added to individual signals by updating the data block in your `program_text`.

        See [Delayed Datapoints](https://signalfx-product-docs.readthedocs-hosted.com/en/latest/charts/chart-builder.html#delayed-datapoints) for more info.
        """
        return pulumi.get(self, "value_prefix")

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[str]:
        return pulumi.get(self, "value_suffix")

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[str]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        return pulumi.get(self, "value_unit")


@pulumi.output_type
class HeatmapChartColorRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeatmapChartColorRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeatmapChartColorRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeatmapChartColorRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: str,
                 max_value: Optional[float] = None,
                 min_value: Optional[float] = None):
        """
        :param str color: The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param float max_value: The maximum value within the coloring range.
        :param float min_value: The minimum value within the coloring range.
        """
        pulumi.set(__self__, "color", color)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)

    @property
    @pulumi.getter
    def color(self) -> str:
        """
        The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[float]:
        """
        The maximum value within the coloring range.
        """
        return pulumi.get(self, "max_value")

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[float]:
        """
        The minimum value within the coloring range.
        """
        return pulumi.get(self, "min_value")


@pulumi.output_type
class HeatmapChartColorScale(dict):
    def __init__(__self__, *,
                 color: str,
                 gt: Optional[float] = None,
                 gte: Optional[float] = None,
                 lt: Optional[float] = None,
                 lte: Optional[float] = None):
        """
        :param str color: The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param float gt: Indicates the lower threshold non-inclusive value for this range.
        :param float gte: Indicates the lower threshold inclusive value for this range.
        :param float lt: Indicates the upper threshold non-inclusive value for this range.
        :param float lte: Indicates the upper threshold inclusive value for this range.
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> str:
        """
        The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def gt(self) -> Optional[float]:
        """
        Indicates the lower threshold non-inclusive value for this range.
        """
        return pulumi.get(self, "gt")

    @property
    @pulumi.getter
    def gte(self) -> Optional[float]:
        """
        Indicates the lower threshold inclusive value for this range.
        """
        return pulumi.get(self, "gte")

    @property
    @pulumi.getter
    def lt(self) -> Optional[float]:
        """
        Indicates the upper threshold non-inclusive value for this range.
        """
        return pulumi.get(self, "lt")

    @property
    @pulumi.getter
    def lte(self) -> Optional[float]:
        """
        Indicates the upper threshold inclusive value for this range.
        """
        return pulumi.get(self, "lte")


@pulumi.output_type
class ListChartColorScale(dict):
    def __init__(__self__, *,
                 color: str,
                 gt: Optional[float] = None,
                 gte: Optional[float] = None,
                 lt: Optional[float] = None,
                 lte: Optional[float] = None):
        """
        :param str color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param float gt: Indicates the lower threshold non-inclusive value for this range.
        :param float gte: Indicates the lower threshold inclusive value for this range.
        :param float lt: Indicates the upper threshold non-inculsive value for this range.
        :param float lte: Indicates the upper threshold inclusive value for this range.
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> str:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def gt(self) -> Optional[float]:
        """
        Indicates the lower threshold non-inclusive value for this range.
        """
        return pulumi.get(self, "gt")

    @property
    @pulumi.getter
    def gte(self) -> Optional[float]:
        """
        Indicates the lower threshold inclusive value for this range.
        """
        return pulumi.get(self, "gte")

    @property
    @pulumi.getter
    def lt(self) -> Optional[float]:
        """
        Indicates the upper threshold non-inculsive value for this range.
        """
        return pulumi.get(self, "lt")

    @property
    @pulumi.getter
    def lte(self) -> Optional[float]:
        """
        Indicates the upper threshold inclusive value for this range.
        """
        return pulumi.get(self, "lte")


@pulumi.output_type
class ListChartLegendOptionsField(dict):
    def __init__(__self__, *,
                 property: str,
                 enabled: Optional[bool] = None):
        """
        :param str property: The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://developers.signalfx.com/signalflow_analytics/functions/data_function.html#table-1-parameter-definitions) for the time series being displayed.
        :param bool enabled: True or False depending on if you want the property to be shown or hidden.
        """
        pulumi.set(__self__, "property", property)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True or False depending on if you want the property to be shown or hidden.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://developers.signalfx.com/signalflow_analytics/functions/data_function.html#table-1-parameter-definitions) for the time series being displayed.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class ListChartVizOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "valuePrefix":
            suggest = "value_prefix"
        elif key == "valueSuffix":
            suggest = "value_suffix"
        elif key == "valueUnit":
            suggest = "value_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListChartVizOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListChartVizOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListChartVizOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 color: Optional[str] = None,
                 display_name: Optional[str] = None,
                 value_prefix: Optional[str] = None,
                 value_suffix: Optional[str] = None,
                 value_unit: Optional[str] = None):
        """
        :param str label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        :param str color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param str value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[str]:
        """
        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        """
        return pulumi.get(self, "value_prefix")

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[str]:
        return pulumi.get(self, "value_suffix")

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[str]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        return pulumi.get(self, "value_unit")


@pulumi.output_type
class MetricRulesetAggregationRule(dict):
    def __init__(__self__, *,
                 aggregators: Sequence['outputs.MetricRulesetAggregationRuleAggregator'],
                 enabled: bool,
                 matchers: Sequence['outputs.MetricRulesetAggregationRuleMatcher'],
                 name: Optional[str] = None):
        """
        :param Sequence['MetricRulesetAggregationRuleAggregatorArgs'] aggregators: Aggregator object
        :param bool enabled: When false, this rule will not generate aggregated MTSs
        :param Sequence['MetricRulesetAggregationRuleMatcherArgs'] matchers: Matcher object
        :param str name: name of the aggregation rule
        """
        pulumi.set(__self__, "aggregators", aggregators)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "matchers", matchers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def aggregators(self) -> Sequence['outputs.MetricRulesetAggregationRuleAggregator']:
        """
        Aggregator object
        """
        return pulumi.get(self, "aggregators")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        When false, this rule will not generate aggregated MTSs
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.MetricRulesetAggregationRuleMatcher']:
        """
        Matcher object
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        name of the aggregation rule
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MetricRulesetAggregationRuleAggregator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dropDimensions":
            suggest = "drop_dimensions"
        elif key == "outputName":
            suggest = "output_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRulesetAggregationRuleAggregator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRulesetAggregationRuleAggregator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRulesetAggregationRuleAggregator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Sequence[str],
                 drop_dimensions: bool,
                 output_name: str,
                 type: str):
        """
        :param Sequence[str] dimensions: List of dimensions to either be kept or dropped in the new aggregated MTSs
        :param bool drop_dimensions: when true, the specified dimensions will be dropped from the aggregated MTSs
        :param str output_name: name of the new aggregated metric
        :param str type: Type of aggregator. Must always be "rollup"
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "drop_dimensions", drop_dimensions)
        pulumi.set(__self__, "output_name", output_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence[str]:
        """
        List of dimensions to either be kept or dropped in the new aggregated MTSs
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="dropDimensions")
    def drop_dimensions(self) -> bool:
        """
        when true, the specified dimensions will be dropped from the aggregated MTSs
        """
        return pulumi.get(self, "drop_dimensions")

    @property
    @pulumi.getter(name="outputName")
    def output_name(self) -> str:
        """
        name of the new aggregated metric
        """
        return pulumi.get(self, "output_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of aggregator. Must always be "rollup"
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MetricRulesetAggregationRuleMatcher(dict):
    def __init__(__self__, *,
                 type: str,
                 filters: Optional[Sequence['outputs.MetricRulesetAggregationRuleMatcherFilter']] = None):
        """
        :param str type: Type of aggregator. Must always be "rollup"
        :param Sequence['MetricRulesetAggregationRuleMatcherFilterArgs'] filters: List of filters to filter the set of input MTSs
        """
        pulumi.set(__self__, "type", type)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of aggregator. Must always be "rollup"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.MetricRulesetAggregationRuleMatcherFilter']]:
        """
        List of filters to filter the set of input MTSs
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class MetricRulesetAggregationRuleMatcherFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "not":
            suggest = "not_"
        elif key == "propertyValues":
            suggest = "property_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRulesetAggregationRuleMatcherFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRulesetAggregationRuleMatcherFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRulesetAggregationRuleMatcherFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 not_: bool,
                 property: str,
                 property_values: Sequence[str]):
        """
        :param bool not_: When true, this filter will match all values not matching the property_values
        :param str property: Name of the dimension
        :param Sequence[str] property_values: Value of the dimension
        """
        pulumi.set(__self__, "not_", not_)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "property_values", property_values)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> bool:
        """
        When true, this filter will match all values not matching the property_values
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Sequence[str]:
        """
        Value of the dimension
        """
        return pulumi.get(self, "property_values")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        Name of the dimension
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class MetricRulesetRoutingRule(dict):
    def __init__(__self__, *,
                 destination: str):
        """
        :param str destination: end destination of the input metric. Must be `RealTime` or `Drop`
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        end destination of the input metric. Must be `RealTime` or `Drop`
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class OrgTokenDpmLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dpmLimit":
            suggest = "dpm_limit"
        elif key == "dpmNotificationThreshold":
            suggest = "dpm_notification_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTokenDpmLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTokenDpmLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTokenDpmLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dpm_limit: int,
                 dpm_notification_threshold: Optional[int] = None):
        """
        :param int dpm_limit: The datapoints per minute (dpm) limit for this token. If you exceed this limit, SignalFx sends out an alert.
        :param int dpm_notification_threshold: DPM level at which SignalFx sends the notification for this token. If you don't specify a notification, SignalFx sends the generic notification.
        """
        pulumi.set(__self__, "dpm_limit", dpm_limit)
        if dpm_notification_threshold is not None:
            pulumi.set(__self__, "dpm_notification_threshold", dpm_notification_threshold)

    @property
    @pulumi.getter(name="dpmLimit")
    def dpm_limit(self) -> int:
        """
        The datapoints per minute (dpm) limit for this token. If you exceed this limit, SignalFx sends out an alert.
        """
        return pulumi.get(self, "dpm_limit")

    @property
    @pulumi.getter(name="dpmNotificationThreshold")
    def dpm_notification_threshold(self) -> Optional[int]:
        """
        DPM level at which SignalFx sends the notification for this token. If you don't specify a notification, SignalFx sends the generic notification.
        """
        return pulumi.get(self, "dpm_notification_threshold")


@pulumi.output_type
class OrgTokenHostOrUsageLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerLimit":
            suggest = "container_limit"
        elif key == "containerNotificationThreshold":
            suggest = "container_notification_threshold"
        elif key == "customMetricsLimit":
            suggest = "custom_metrics_limit"
        elif key == "customMetricsNotificationThreshold":
            suggest = "custom_metrics_notification_threshold"
        elif key == "highResMetricsLimit":
            suggest = "high_res_metrics_limit"
        elif key == "highResMetricsNotificationThreshold":
            suggest = "high_res_metrics_notification_threshold"
        elif key == "hostLimit":
            suggest = "host_limit"
        elif key == "hostNotificationThreshold":
            suggest = "host_notification_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTokenHostOrUsageLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTokenHostOrUsageLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTokenHostOrUsageLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_limit: Optional[int] = None,
                 container_notification_threshold: Optional[int] = None,
                 custom_metrics_limit: Optional[int] = None,
                 custom_metrics_notification_threshold: Optional[int] = None,
                 high_res_metrics_limit: Optional[int] = None,
                 high_res_metrics_notification_threshold: Optional[int] = None,
                 host_limit: Optional[int] = None,
                 host_notification_threshold: Optional[int] = None):
        """
        :param int container_limit: Max number of Docker containers that can use this token
        :param int container_notification_threshold: Notification threshold for Docker containers
        :param int custom_metrics_limit: Max number of custom metrics that can be sent with this token
        :param int custom_metrics_notification_threshold: Notification threshold for custom metrics
        :param int high_res_metrics_limit: Max number of hi-res metrics that can be sent with this toke
        :param int high_res_metrics_notification_threshold: Notification threshold for hi-res metrics
        :param int host_limit: Max number of hosts that can use this token
        :param int host_notification_threshold: Notification threshold for hosts
        """
        if container_limit is not None:
            pulumi.set(__self__, "container_limit", container_limit)
        if container_notification_threshold is not None:
            pulumi.set(__self__, "container_notification_threshold", container_notification_threshold)
        if custom_metrics_limit is not None:
            pulumi.set(__self__, "custom_metrics_limit", custom_metrics_limit)
        if custom_metrics_notification_threshold is not None:
            pulumi.set(__self__, "custom_metrics_notification_threshold", custom_metrics_notification_threshold)
        if high_res_metrics_limit is not None:
            pulumi.set(__self__, "high_res_metrics_limit", high_res_metrics_limit)
        if high_res_metrics_notification_threshold is not None:
            pulumi.set(__self__, "high_res_metrics_notification_threshold", high_res_metrics_notification_threshold)
        if host_limit is not None:
            pulumi.set(__self__, "host_limit", host_limit)
        if host_notification_threshold is not None:
            pulumi.set(__self__, "host_notification_threshold", host_notification_threshold)

    @property
    @pulumi.getter(name="containerLimit")
    def container_limit(self) -> Optional[int]:
        """
        Max number of Docker containers that can use this token
        """
        return pulumi.get(self, "container_limit")

    @property
    @pulumi.getter(name="containerNotificationThreshold")
    def container_notification_threshold(self) -> Optional[int]:
        """
        Notification threshold for Docker containers
        """
        return pulumi.get(self, "container_notification_threshold")

    @property
    @pulumi.getter(name="customMetricsLimit")
    def custom_metrics_limit(self) -> Optional[int]:
        """
        Max number of custom metrics that can be sent with this token
        """
        return pulumi.get(self, "custom_metrics_limit")

    @property
    @pulumi.getter(name="customMetricsNotificationThreshold")
    def custom_metrics_notification_threshold(self) -> Optional[int]:
        """
        Notification threshold for custom metrics
        """
        return pulumi.get(self, "custom_metrics_notification_threshold")

    @property
    @pulumi.getter(name="highResMetricsLimit")
    def high_res_metrics_limit(self) -> Optional[int]:
        """
        Max number of hi-res metrics that can be sent with this toke
        """
        return pulumi.get(self, "high_res_metrics_limit")

    @property
    @pulumi.getter(name="highResMetricsNotificationThreshold")
    def high_res_metrics_notification_threshold(self) -> Optional[int]:
        """
        Notification threshold for hi-res metrics
        """
        return pulumi.get(self, "high_res_metrics_notification_threshold")

    @property
    @pulumi.getter(name="hostLimit")
    def host_limit(self) -> Optional[int]:
        """
        Max number of hosts that can use this token
        """
        return pulumi.get(self, "host_limit")

    @property
    @pulumi.getter(name="hostNotificationThreshold")
    def host_notification_threshold(self) -> Optional[int]:
        """
        Notification threshold for hosts
        """
        return pulumi.get(self, "host_notification_threshold")


@pulumi.output_type
class SingleValueChartColorScale(dict):
    def __init__(__self__, *,
                 color: str,
                 gt: Optional[float] = None,
                 gte: Optional[float] = None,
                 lt: Optional[float] = None,
                 lte: Optional[float] = None):
        """
        :param str color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param float gt: Indicates the lower threshold non-inclusive value for this range.
        :param float gte: Indicates the lower threshold inclusive value for this range.
        :param float lt: Indicates the upper threshold non-inculsive value for this range.
        :param float lte: Indicates the upper threshold inclusive value for this range.
        """
        pulumi.set(__self__, "color", color)
        if gt is not None:
            pulumi.set(__self__, "gt", gt)
        if gte is not None:
            pulumi.set(__self__, "gte", gte)
        if lt is not None:
            pulumi.set(__self__, "lt", lt)
        if lte is not None:
            pulumi.set(__self__, "lte", lte)

    @property
    @pulumi.getter
    def color(self) -> str:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def gt(self) -> Optional[float]:
        """
        Indicates the lower threshold non-inclusive value for this range.
        """
        return pulumi.get(self, "gt")

    @property
    @pulumi.getter
    def gte(self) -> Optional[float]:
        """
        Indicates the lower threshold inclusive value for this range.
        """
        return pulumi.get(self, "gte")

    @property
    @pulumi.getter
    def lt(self) -> Optional[float]:
        """
        Indicates the upper threshold non-inculsive value for this range.
        """
        return pulumi.get(self, "lt")

    @property
    @pulumi.getter
    def lte(self) -> Optional[float]:
        """
        Indicates the upper threshold inclusive value for this range.
        """
        return pulumi.get(self, "lte")


@pulumi.output_type
class SingleValueChartVizOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "valuePrefix":
            suggest = "value_prefix"
        elif key == "valueSuffix":
            suggest = "value_suffix"
        elif key == "valueUnit":
            suggest = "value_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SingleValueChartVizOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SingleValueChartVizOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SingleValueChartVizOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 color: Optional[str] = None,
                 display_name: Optional[str] = None,
                 value_prefix: Optional[str] = None,
                 value_suffix: Optional[str] = None,
                 value_unit: Optional[str] = None):
        """
        :param str label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        :param str color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param str value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[str]:
        """
        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        """
        return pulumi.get(self, "value_prefix")

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[str]:
        return pulumi.get(self, "value_suffix")

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[str]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        return pulumi.get(self, "value_unit")


@pulumi.output_type
class TableChartVizOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "valuePrefix":
            suggest = "value_prefix"
        elif key == "valueSuffix":
            suggest = "value_suffix"
        elif key == "valueUnit":
            suggest = "value_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableChartVizOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableChartVizOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableChartVizOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 color: Optional[str] = None,
                 display_name: Optional[str] = None,
                 value_prefix: Optional[str] = None,
                 value_suffix: Optional[str] = None,
                 value_unit: Optional[str] = None):
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[str]:
        return pulumi.get(self, "value_prefix")

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[str]:
        return pulumi.get(self, "value_suffix")

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[str]:
        return pulumi.get(self, "value_unit")


@pulumi.output_type
class TimeChartAxisLeft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highWatermark":
            suggest = "high_watermark"
        elif key == "highWatermarkLabel":
            suggest = "high_watermark_label"
        elif key == "lowWatermark":
            suggest = "low_watermark"
        elif key == "lowWatermarkLabel":
            suggest = "low_watermark_label"
        elif key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeChartAxisLeft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeChartAxisLeft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeChartAxisLeft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_watermark: Optional[float] = None,
                 high_watermark_label: Optional[str] = None,
                 label: Optional[str] = None,
                 low_watermark: Optional[float] = None,
                 low_watermark_label: Optional[str] = None,
                 max_value: Optional[float] = None,
                 min_value: Optional[float] = None,
                 watermarks: Optional[Sequence['outputs.TimeChartAxisLeftWatermark']] = None):
        """
        :param float high_watermark: A line to draw as a high watermark.
        :param str high_watermark_label: A label to attach to the high watermark line.
        :param str label: Label used in the publish statement that displays the event query you want to customize.
        :param float low_watermark: A line to draw as a low watermark.
        :param str low_watermark_label: A label to attach to the low watermark line.
        :param float max_value: The maximum value for the right axis.
        :param float min_value: The minimum value for the right axis.
        """
        if high_watermark is not None:
            pulumi.set(__self__, "high_watermark", high_watermark)
        if high_watermark_label is not None:
            pulumi.set(__self__, "high_watermark_label", high_watermark_label)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if low_watermark is not None:
            pulumi.set(__self__, "low_watermark", low_watermark)
        if low_watermark_label is not None:
            pulumi.set(__self__, "low_watermark_label", low_watermark_label)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if watermarks is not None:
            pulumi.set(__self__, "watermarks", watermarks)

    @property
    @pulumi.getter(name="highWatermark")
    def high_watermark(self) -> Optional[float]:
        """
        A line to draw as a high watermark.
        """
        return pulumi.get(self, "high_watermark")

    @property
    @pulumi.getter(name="highWatermarkLabel")
    def high_watermark_label(self) -> Optional[str]:
        """
        A label to attach to the high watermark line.
        """
        return pulumi.get(self, "high_watermark_label")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Label used in the publish statement that displays the event query you want to customize.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="lowWatermark")
    def low_watermark(self) -> Optional[float]:
        """
        A line to draw as a low watermark.
        """
        return pulumi.get(self, "low_watermark")

    @property
    @pulumi.getter(name="lowWatermarkLabel")
    def low_watermark_label(self) -> Optional[str]:
        """
        A label to attach to the low watermark line.
        """
        return pulumi.get(self, "low_watermark_label")

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[float]:
        """
        The maximum value for the right axis.
        """
        return pulumi.get(self, "max_value")

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[float]:
        """
        The minimum value for the right axis.
        """
        return pulumi.get(self, "min_value")

    @property
    @pulumi.getter
    def watermarks(self) -> Optional[Sequence['outputs.TimeChartAxisLeftWatermark']]:
        return pulumi.get(self, "watermarks")


@pulumi.output_type
class TimeChartAxisLeftWatermark(dict):
    def __init__(__self__, *,
                 value: float,
                 label: Optional[str] = None):
        """
        :param str label: Label used in the publish statement that displays the event query you want to customize.
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Label used in the publish statement that displays the event query you want to customize.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class TimeChartAxisRight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highWatermark":
            suggest = "high_watermark"
        elif key == "highWatermarkLabel":
            suggest = "high_watermark_label"
        elif key == "lowWatermark":
            suggest = "low_watermark"
        elif key == "lowWatermarkLabel":
            suggest = "low_watermark_label"
        elif key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeChartAxisRight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeChartAxisRight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeChartAxisRight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_watermark: Optional[float] = None,
                 high_watermark_label: Optional[str] = None,
                 label: Optional[str] = None,
                 low_watermark: Optional[float] = None,
                 low_watermark_label: Optional[str] = None,
                 max_value: Optional[float] = None,
                 min_value: Optional[float] = None,
                 watermarks: Optional[Sequence['outputs.TimeChartAxisRightWatermark']] = None):
        """
        :param float high_watermark: A line to draw as a high watermark.
        :param str high_watermark_label: A label to attach to the high watermark line.
        :param str label: Label used in the publish statement that displays the event query you want to customize.
        :param float low_watermark: A line to draw as a low watermark.
        :param str low_watermark_label: A label to attach to the low watermark line.
        :param float max_value: The maximum value for the right axis.
        :param float min_value: The minimum value for the right axis.
        """
        if high_watermark is not None:
            pulumi.set(__self__, "high_watermark", high_watermark)
        if high_watermark_label is not None:
            pulumi.set(__self__, "high_watermark_label", high_watermark_label)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if low_watermark is not None:
            pulumi.set(__self__, "low_watermark", low_watermark)
        if low_watermark_label is not None:
            pulumi.set(__self__, "low_watermark_label", low_watermark_label)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if watermarks is not None:
            pulumi.set(__self__, "watermarks", watermarks)

    @property
    @pulumi.getter(name="highWatermark")
    def high_watermark(self) -> Optional[float]:
        """
        A line to draw as a high watermark.
        """
        return pulumi.get(self, "high_watermark")

    @property
    @pulumi.getter(name="highWatermarkLabel")
    def high_watermark_label(self) -> Optional[str]:
        """
        A label to attach to the high watermark line.
        """
        return pulumi.get(self, "high_watermark_label")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Label used in the publish statement that displays the event query you want to customize.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="lowWatermark")
    def low_watermark(self) -> Optional[float]:
        """
        A line to draw as a low watermark.
        """
        return pulumi.get(self, "low_watermark")

    @property
    @pulumi.getter(name="lowWatermarkLabel")
    def low_watermark_label(self) -> Optional[str]:
        """
        A label to attach to the low watermark line.
        """
        return pulumi.get(self, "low_watermark_label")

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[float]:
        """
        The maximum value for the right axis.
        """
        return pulumi.get(self, "max_value")

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[float]:
        """
        The minimum value for the right axis.
        """
        return pulumi.get(self, "min_value")

    @property
    @pulumi.getter
    def watermarks(self) -> Optional[Sequence['outputs.TimeChartAxisRightWatermark']]:
        return pulumi.get(self, "watermarks")


@pulumi.output_type
class TimeChartAxisRightWatermark(dict):
    def __init__(__self__, *,
                 value: float,
                 label: Optional[str] = None):
        """
        :param str label: Label used in the publish statement that displays the event query you want to customize.
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Label used in the publish statement that displays the event query you want to customize.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class TimeChartEventOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeChartEventOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeChartEventOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeChartEventOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 color: Optional[str] = None,
                 display_name: Optional[str] = None):
        """
        :param str label: Label used in the publish statement that displays the event query you want to customize.
        :param str color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        pulumi.set(__self__, "label", label)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label used in the publish statement that displays the event query you want to customize.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class TimeChartHistogramOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorTheme":
            suggest = "color_theme"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeChartHistogramOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeChartHistogramOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeChartHistogramOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_theme: Optional[str] = None):
        """
        :param str color_theme: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
        """
        if color_theme is not None:
            pulumi.set(__self__, "color_theme", color_theme)

    @property
    @pulumi.getter(name="colorTheme")
    def color_theme(self) -> Optional[str]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
        """
        return pulumi.get(self, "color_theme")


@pulumi.output_type
class TimeChartLegendOptionsField(dict):
    def __init__(__self__, *,
                 property: str,
                 enabled: Optional[bool] = None):
        """
        :param str property: The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
        :param bool enabled: True or False depending on if you want the property to be shown or hidden.
        """
        pulumi.set(__self__, "property", property)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True or False depending on if you want the property to be shown or hidden.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class TimeChartVizOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "plotType":
            suggest = "plot_type"
        elif key == "valuePrefix":
            suggest = "value_prefix"
        elif key == "valueSuffix":
            suggest = "value_suffix"
        elif key == "valueUnit":
            suggest = "value_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeChartVizOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeChartVizOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeChartVizOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 axis: Optional[str] = None,
                 color: Optional[str] = None,
                 display_name: Optional[str] = None,
                 plot_type: Optional[str] = None,
                 value_prefix: Optional[str] = None,
                 value_suffix: Optional[str] = None,
                 value_unit: Optional[str] = None):
        """
        :param str label: Label used in the publish statement that displays the event query you want to customize.
        :param str axis: Y-axis associated with values for this plot. Must be either `right` or `left`.
        :param str color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        :param str plot_type: The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
        :param str value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        pulumi.set(__self__, "label", label)
        if axis is not None:
            pulumi.set(__self__, "axis", axis)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if plot_type is not None:
            pulumi.set(__self__, "plot_type", plot_type)
        if value_prefix is not None:
            pulumi.set(__self__, "value_prefix", value_prefix)
        if value_suffix is not None:
            pulumi.set(__self__, "value_suffix", value_suffix)
        if value_unit is not None:
            pulumi.set(__self__, "value_unit", value_unit)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label used in the publish statement that displays the event query you want to customize.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def axis(self) -> Optional[str]:
        """
        Y-axis associated with values for this plot. Must be either `right` or `left`.
        """
        return pulumi.get(self, "axis")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="plotType")
    def plot_type(self) -> Optional[str]:
        """
        The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
        """
        return pulumi.get(self, "plot_type")

    @property
    @pulumi.getter(name="valuePrefix")
    def value_prefix(self) -> Optional[str]:
        """
        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
        """
        return pulumi.get(self, "value_prefix")

    @property
    @pulumi.getter(name="valueSuffix")
    def value_suffix(self) -> Optional[str]:
        return pulumi.get(self, "value_suffix")

    @property
    @pulumi.getter(name="valueUnit")
    def value_unit(self) -> Optional[str]:
        """
        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
        """
        return pulumi.get(self, "value_unit")


@pulumi.output_type
class WebhookIntegrationHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerKey":
            suggest = "header_key"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookIntegrationHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookIntegrationHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookIntegrationHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_key: str,
                 header_value: str):
        """
        :param str header_key: The key of the header to send
        :param str header_value: The value of the header to send
        """
        pulumi.set(__self__, "header_key", header_key)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerKey")
    def header_key(self) -> str:
        """
        The key of the header to send
        """
        return pulumi.get(self, "header_key")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to send
        """
        return pulumi.get(self, "header_value")


