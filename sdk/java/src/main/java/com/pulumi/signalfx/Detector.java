// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.signalfx;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.signalfx.DetectorArgs;
import com.pulumi.signalfx.Utilities;
import com.pulumi.signalfx.inputs.DetectorState;
import com.pulumi.signalfx.outputs.DetectorRule;
import com.pulumi.signalfx.outputs.DetectorVizOption;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Provides a Splunk Observability Cloud detector resource. This can be used to create and manage detectors.
 * 
 * If you&#39;re interested in using Splunk Observability Cloud detector features such as Historical Anomaly, Resource Running Out, or others, consider building them in the UI first and then use the &#34;Show SignalFlow&#34; feature to extract the value for `program_text`. You can also see the [documentation for detector functions in signalflow-library](https://github.com/signalfx/signalflow-library/tree/master/library/signalfx/detectors).
 * 
 * &gt; **NOTE** When you want to change or remove write permissions for a user other than yourself regarding detectors, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 * 
 * ## Example
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.signalfx.Detector;
 * import com.pulumi.signalfx.DetectorArgs;
 * import com.pulumi.signalfx.inputs.DetectorRuleArgs;
 * import com.pulumi.codegen.internal.KeyedValue;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         final var config = ctx.config();
 *         final var clusters = config.get("clusters").orElse(List.of(        
 *             "clusterA",
 *             "clusterB"));
 *         for (var i = 0; i < clusters.length(); i++) }{{@code
 *             new Detector("applicationDelay-" + i, DetectorArgs.builder()
 *                 .name(String.format(" max average delay - %s", clusters[range.value()]))
 *                 .description(String.format("your application is slow - %s", clusters[range.value()]))
 *                 .maxDelay(30)
 *                 .tags(                
 *                     "app-backend",
 *                     "staging")
 *                 .authorizedWriterTeams(mycoolteam.id())
 *                 .authorizedWriterUsers("abc123")
 *                 .programText("""
 * signal = data('app.delay', filter('cluster','%s'), extrapolation='last_value', maxExtrapolations=5).max()
 * detect(when(signal > 60, '5m')).publish('Processing old messages 5m')
 * detect(when(signal > 60, '30m')).publish('Processing old messages 30m')
 * ", clusters[range.value()]))
 *                 .rules(                
 *                     DetectorRuleArgs.builder()
 *                         .description("maximum > 60 for 5m")
 *                         .severity("Warning")
 *                         .detectLabel("Processing old messages 5m")
 *                         .notifications("Email,foo-alerts}{@literal @}{@code bar.com")
 *                         .build(),
 *                     DetectorRuleArgs.builder()
 *                         .description("maximum > 60 for 30m")
 *                         .severity("Critical")
 *                         .detectLabel("Processing old messages 30m")
 *                         .notifications("Email,foo-alerts}{@literal @}{@code bar.com")
 *                         .build())
 *                 .build());
 * 
 *         
 * }}{@code
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Notification format
 * 
 * As Splunk Observability Cloud supports different notification mechanisms, use a comma-delimited string to provide inputs. If you want to specify multiple notifications, each must be a member in the list, like so:
 * 
 * See [Splunk Observability Cloud Docs](https://dev.splunk.com/observability/reference/api/detectors/latest) for more information.
 * 
 * Here are some example of how to configure each notification type:
 * 
 * ### Email
 * 
 * ### Jira
 * 
 * Note that the `credentialId` is the Splunk-provided ID shown after setting up your Jira integration. See also `signalfx.jira.Integration`.
 * 
 * ### OpsGenie
 * 
 * Note that the `credentialId` is the Splunk-provided ID shown after setting up your Opsgenie integration. `Team` here is hardcoded as the `responderType` as that is the only acceptable type as per the API docs.
 * 
 * ### PagerDuty
 * 
 * ### Slack
 * 
 * Exclude the `#` on the channel name:
 * 
 * ### Team
 * 
 * Sends [notifications to a team](https://docs.signalfx.com/en/latest/managing/teams/team-notifications.html).
 * 
 * ### TeamEmail
 * 
 * Sends an email to every member of a team.
 * 
 * ### Splunk On-Call (formerly VictorOps)
 * 
 * ### Webhooks
 * 
 * You need to include all the commas even if you only use a credential id.
 * 
 * You can either configure a Webhook to use an existing integration&#39;s credential id:
 * 
 * Or configure one inline:
 * 
 * ## Import
 * 
 * Detectors can be imported using their string ID (recoverable from URL: `/#/detector/v2/abc123/edit`, e.g.
 * 
 * ```sh
 * $ pulumi import signalfx:index/detector:Detector application_delay abc123
 * ```
 * 
 */
@ResourceType(type="signalfx:index/detector:Detector")
public class Detector extends com.pulumi.resources.CustomResource {
    /**
     * Team IDs that have write access to this detector. Remember to use an admin&#39;s token if using this feature and to include that admin&#39;s team id (or user id in `authorized_writer_users`).
     * 
     */
    @Export(name="authorizedWriterTeams", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> authorizedWriterTeams;

    /**
     * @return Team IDs that have write access to this detector. Remember to use an admin&#39;s token if using this feature and to include that admin&#39;s team id (or user id in `authorized_writer_users`).
     * 
     */
    public Output<Optional<List<String>>> authorizedWriterTeams() {
        return Codegen.optional(this.authorizedWriterTeams);
    }
    /**
     * User IDs that have write access to this detector. Remember to use an admin&#39;s token if using this feature and to include that admin&#39;s user id (or team id in `authorized_writer_teams`).
     * 
     */
    @Export(name="authorizedWriterUsers", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> authorizedWriterUsers;

    /**
     * @return User IDs that have write access to this detector. Remember to use an admin&#39;s token if using this feature and to include that admin&#39;s user id (or team id in `authorized_writer_teams`).
     * 
     */
    public Output<Optional<List<String>>> authorizedWriterUsers() {
        return Codegen.optional(this.authorizedWriterUsers);
    }
    /**
     * Description of the detector.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return Description of the detector.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Indicates how a detector was created. The possible values are: Standard and AutoDetectCustomization. The value can only be set when creating the detector and cannot be modified later.
     * 
     */
    @Export(name="detectorOrigin", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> detectorOrigin;

    /**
     * @return Indicates how a detector was created. The possible values are: Standard and AutoDetectCustomization. The value can only be set when creating the detector and cannot be modified later.
     * 
     */
    public Output<Optional<String>> detectorOrigin() {
        return Codegen.optional(this.detectorOrigin);
    }
    /**
     * When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
     * 
     */
    @Export(name="disableSampling", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disableSampling;

    /**
     * @return When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
     * 
     */
    public Output<Optional<Boolean>> disableSampling() {
        return Codegen.optional(this.disableSampling);
    }
    /**
     * Seconds since epoch. Used for visualization. Conflicts with `time_range`.
     * 
     */
    @Export(name="endTime", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> endTime;

    /**
     * @return Seconds since epoch. Used for visualization. Conflicts with `time_range`.
     * 
     */
    public Output<Optional<Integer>> endTime() {
        return Codegen.optional(this.endTime);
    }
    /**
     * The resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert should be triggered.
     * 
     */
    @Export(name="labelResolutions", refs={Map.class,String.class,Integer.class}, tree="[0,1,2]")
    private Output<Map<String,Integer>> labelResolutions;

    /**
     * @return The resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert should be triggered.
     * 
     */
    public Output<Map<String,Integer>> labelResolutions() {
        return this.labelResolutions;
    }
    /**
     * allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
     * 
     */
    @Export(name="maxDelay", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> maxDelay;

    /**
     * @return allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
     * 
     */
    public Output<Optional<Integer>> maxDelay() {
        return Codegen.optional(this.maxDelay);
    }
    /**
     * How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
     * 
     */
    @Export(name="minDelay", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> minDelay;

    /**
     * @return How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
     * 
     */
    public Output<Optional<Integer>> minDelay() {
        return Codegen.optional(this.minDelay);
    }
    /**
     * Name of the detector.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Name of the detector.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * ID of the AutoDetect parent detector from which this detector is customized and created. This property is required for detectors with detectorOrigin of type AutoDetectCustomization. The value can only be set when creating the detector and cannot be modified later.
     * 
     */
    @Export(name="parentDetectorId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> parentDetectorId;

    /**
     * @return ID of the AutoDetect parent detector from which this detector is customized and created. This property is required for detectors with detectorOrigin of type AutoDetectCustomization. The value can only be set when creating the detector and cannot be modified later.
     * 
     */
    public Output<Optional<String>> parentDetectorId() {
        return Codegen.optional(this.parentDetectorId);
    }
    /**
     * Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
     * 
     */
    @Export(name="programText", refs={String.class}, tree="[0]")
    private Output<String> programText;

    /**
     * @return Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
     * 
     */
    public Output<String> programText() {
        return this.programText;
    }
    /**
     * Set of rules used for alerting.
     * 
     */
    @Export(name="rules", refs={List.class,DetectorRule.class}, tree="[0,1]")
    private Output<List<DetectorRule>> rules;

    /**
     * @return Set of rules used for alerting.
     * 
     */
    public Output<List<DetectorRule>> rules() {
        return this.rules;
    }
    /**
     * When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
     * 
     */
    @Export(name="showDataMarkers", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> showDataMarkers;

    /**
     * @return When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
     * 
     */
    public Output<Optional<Boolean>> showDataMarkers() {
        return Codegen.optional(this.showDataMarkers);
    }
    /**
     * When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
     * 
     */
    @Export(name="showEventLines", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> showEventLines;

    /**
     * @return When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
     * 
     */
    public Output<Optional<Boolean>> showEventLines() {
        return Codegen.optional(this.showEventLines);
    }
    /**
     * Seconds since epoch. Used for visualization. Conflicts with `time_range`.
     * 
     */
    @Export(name="startTime", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> startTime;

    /**
     * @return Seconds since epoch. Used for visualization. Conflicts with `time_range`.
     * 
     */
    public Output<Optional<Integer>> startTime() {
        return Codegen.optional(this.startTime);
    }
    /**
     * Tags associated with the detector.
     * 
     */
    @Export(name="tags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return Tags associated with the detector.
     * 
     */
    public Output<Optional<List<String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * Team IDs to associate the detector to.
     * 
     */
    @Export(name="teams", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> teams;

    /**
     * @return Team IDs to associate the detector to.
     * 
     */
    public Output<Optional<List<String>>> teams() {
        return Codegen.optional(this.teams);
    }
    /**
     * Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
     * 
     */
    @Export(name="timeRange", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> timeRange;

    /**
     * @return Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
     * 
     */
    public Output<Optional<Integer>> timeRange() {
        return Codegen.optional(this.timeRange);
    }
    /**
     * The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
     * 
     */
    @Export(name="timezone", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> timezone;

    /**
     * @return The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
     * 
     */
    public Output<Optional<String>> timezone() {
        return Codegen.optional(this.timezone);
    }
    /**
     * The URL of the detector.
     * 
     */
    @Export(name="url", refs={String.class}, tree="[0]")
    private Output<String> url;

    /**
     * @return The URL of the detector.
     * 
     */
    public Output<String> url() {
        return this.url;
    }
    /**
     * Plot-level customization options, associated with a publish statement.
     * 
     */
    @Export(name="vizOptions", refs={List.class,DetectorVizOption.class}, tree="[0,1]")
    private Output</* @Nullable */ List<DetectorVizOption>> vizOptions;

    /**
     * @return Plot-level customization options, associated with a publish statement.
     * 
     */
    public Output<Optional<List<DetectorVizOption>>> vizOptions() {
        return Codegen.optional(this.vizOptions);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Detector(java.lang.String name) {
        this(name, DetectorArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Detector(java.lang.String name, DetectorArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Detector(java.lang.String name, DetectorArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("signalfx:index/detector:Detector", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Detector(java.lang.String name, Output<java.lang.String> id, @Nullable DetectorState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("signalfx:index/detector:Detector", name, state, makeResourceOptions(options, id), false);
    }

    private static DetectorArgs makeArgs(DetectorArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? DetectorArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Detector get(java.lang.String name, Output<java.lang.String> id, @Nullable DetectorState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Detector(name, id, state, options);
    }
}
