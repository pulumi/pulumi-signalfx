// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AlertMutingRuleFilter {
    /**
     * Determines if this is a "not" filter. Defaults to `false`.
     */
    negated?: boolean;
    /**
     * The property to filter.
     */
    property: string;
    /**
     * The property value to filter.
     */
    propertyValue: string;
}

export interface AlertMutingRuleRecurrence {
    /**
     * The unit of the period. Can be days (d) or weeks (w).
     */
    unit: string;
    /**
     * The amount of time, expressed as an integer, applicable to the unit specified.
     */
    value: number;
}

export interface DashboardChart {
    /**
     * ID of the chart to display.
     */
    chartId: string;
    /**
     * The column to show the chart in (zero-based); this value always represents the leftmost column of the chart (between `0` and `11`).
     */
    column?: number;
    /**
     * How many rows the chart should take up (greater than or equal to `1`). `1` by default.
     */
    height?: number;
    /**
     * The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
     */
    row?: number;
    /**
     * How many columns (out of a total of 12) the chart should take up (between `1` and `12`). `12` by default.
     */
    width?: number;
}

export interface DashboardColumn {
    /**
     * List of IDs of the charts to display.
     */
    chartIds: string[];
    /**
     * Column number for the layout.
     */
    column?: number;
    /**
     * How many rows every chart should take up (greater than or equal to 1). 1 by default.
     */
    height?: number;
    /**
     * How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
     */
    width?: number;
}

export interface DashboardEventOverlay {
    /**
     * Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
     */
    color?: string;
    /**
     * Text shown in the dropdown when selecting this overlay from the menu.
     */
    label?: string;
    /**
     * Show a vertical line for the event. `false` by default.
     */
    line?: boolean;
    /**
     * Search term used to choose the events shown in the overlay.
     */
    signal: string;
    /**
     * Each element specifies a filter to use against the signal specified in the `signal`.
     */
    sources?: outputs.DashboardEventOverlaySource[];
    /**
     * Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
     */
    type?: string;
}

export interface DashboardEventOverlaySource {
    /**
     * If true, only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
     */
    negated?: boolean;
    /**
     * The name of a dimension to filter against.
     */
    property: string;
    /**
     * A list of values to be used with the `property`, they will be combined via `OR`.
     */
    values: string[];
}

export interface DashboardFilter {
    /**
     * If true, this filter will also match data that doesn't have this property at all.
     */
    applyIfExist?: boolean;
    /**
     * Whether this filter should be a not filter. `false` by default.
     */
    negated?: boolean;
    /**
     * A metric time series dimension or property name.
     */
    property: string;
    /**
     * List of of strings (which will be treated as an OR filter on the property).
     */
    values: string[];
}

export interface DashboardGrid {
    /**
     * List of IDs of the charts to display.
     */
    chartIds: string[];
    /**
     * How many rows every chart should take up (greater than or equal to `1`). `1` by default.
     */
    height?: number;
    /**
     * How many columns (out of a total of 12) every chart should take up (between `1` and `12`). `12` by default.
     */
    width?: number;
}

export interface DashboardGroupDashboard {
    /**
     * The ID of the association between the dashboard group and the dashboard
     */
    configId: string;
    /**
     * The dashboard id to mirror
     */
    dashboardId: string;
    /**
     * The description that will override the original dashboards's description.
     */
    descriptionOverride?: string;
    /**
     * The description that will override the original dashboards's description.
     */
    filterOverrides?: outputs.DashboardGroupDashboardFilterOverride[];
    /**
     * The name that will override the original dashboards's name.
     */
    nameOverride?: string;
    /**
     * Dashboard variable to apply to each chart in the dashboard
     */
    variableOverrides?: outputs.DashboardGroupDashboardVariableOverride[];
}

export interface DashboardGroupDashboardFilterOverride {
    /**
     * If true, only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
     */
    negated?: boolean;
    /**
     * A metric time series dimension or property name.
     */
    property: string;
    /**
     * (Optional) List of of strings (which will be treated as an OR filter on the property).
     */
    values: string[];
}

export interface DashboardGroupDashboardVariableOverride {
    /**
     * A metric time series dimension or property name
     */
    property: string;
    /**
     * List of strings (which will be treated as an OR filter on the property)
     */
    values?: string[];
    /**
     * A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
     */
    valuesSuggesteds?: string[];
}

export interface DashboardGroupImportQualifier {
    /**
     * Filter to apply to each chart in the dashboard
     */
    filters?: outputs.DashboardGroupImportQualifierFilter[];
    metric?: string;
}

export interface DashboardGroupImportQualifierFilter {
    /**
     * (false by default) Whether this filter should be a "not" filter
     */
    negated?: boolean;
    /**
     * A metric time series dimension or property name
     */
    property: string;
    /**
     * List of strings (which will be treated as an OR filter on the property)
     */
    values: string[];
}

export interface DashboardGroupPermission {
    /**
     * Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
     */
    actions?: string[];
    /**
     * ID of the user, team, or organization for which you're granting permissions.
     */
    principalId: string;
    /**
     * Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
     */
    principalType: string;
}

export interface DashboardPermissions {
    /**
     * List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
     */
    acls?: outputs.DashboardPermissionsAcl[];
    /**
     * ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
     */
    parent?: string;
}

export interface DashboardPermissionsAcl {
    /**
     * Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
     */
    actions?: string[];
    /**
     * ID of the user, team, or organization for which you're granting permissions.
     */
    principalId: string;
    /**
     * Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
     */
    principalType: string;
}

export interface DashboardSelectedEventOverlay {
    /**
     * Search term used to choose the events shown in the overlay.
     */
    signal: string;
    /**
     * Each element specifies a filter to use against the signal specified in the `signal`.
     */
    sources?: outputs.DashboardSelectedEventOverlaySource[];
    /**
     * Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
     */
    type?: string;
}

export interface DashboardSelectedEventOverlaySource {
    /**
     * If true, only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
     */
    negated?: boolean;
    /**
     * The name of a dimension to filter against.
     */
    property: string;
    /**
     * A list of values to be used with the `property`, they will be combined via `OR`.
     */
    values: string[];
}

export interface DashboardVariable {
    /**
     * An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
     */
    alias: string;
    /**
     * If true, this variable will also match data that doesn't have this property at all.
     */
    applyIfExist?: boolean;
    /**
     * Variable description.
     */
    description?: string;
    /**
     * A metric time series dimension or property name.
     */
    property: string;
    /**
     * If `true`, this variable will only apply to charts that have a filter for the property.
     */
    replaceOnly?: boolean;
    /**
     * If `true`, this variable may only be set to the values listed in `valuesSuggested` and only these values will appear in autosuggestion menus. `false` by default.
     */
    restrictedSuggestions?: boolean;
    /**
     * Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
     */
    valueRequired?: boolean;
    /**
     * List of of strings (which will be treated as an OR filter on the property).
     */
    values?: string[];
    /**
     * A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
     */
    valuesSuggesteds?: string[];
}

export interface DataLinkTargetAppdUrl {
    /**
     * User-assigned target name. Use this value to differentiate between the link targets for a data link object.
     */
    name: string;
    /**
     * URL string for an AppDynamics instance.
     */
    url: string;
}

export interface DataLinkTargetExternalUrl {
    /**
     * The [minimum time window](https://dev.splunk.com/observability/docs/administration/datalinks/) for a search sent to an external site. Defaults to `6000`
     */
    minimumTimeWindow?: string;
    /**
     * User-assigned target name. Use this value to differentiate between the link targets for a data link object.
     */
    name: string;
    /**
     * Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
     */
    propertyKeyMapping?: {[key: string]: string};
    /**
     * [Designates the format](https://dev.splunk.com/observability/docs/administration/datalinks/) of `minimumTimeWindow` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
     */
    timeFormat?: string;
    /**
     * URL string for a Splunk instance or external system data link target. [See the supported template variables](https://dev.splunk.com/observability/docs/administration/datalinks/).
     */
    url: string;
}

export interface DataLinkTargetSignalfxDashboard {
    /**
     * SignalFx-assigned ID of the dashboard link target's dashboard group
     */
    dashboardGroupId: string;
    /**
     * SignalFx-assigned ID of the dashboard link target
     */
    dashboardId: string;
    /**
     * Flag that designates a target as the default for a data link object. `true` by default
     */
    isDefault?: boolean;
    /**
     * User-assigned target name. Use this value to differentiate between the link targets for a data link object.
     */
    name: string;
}

export interface DataLinkTargetSplunk {
    /**
     * User-assigned target name. Use this value to differentiate between the link targets for a data link object.
     */
    name: string;
    /**
     * Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
     */
    propertyKeyMapping?: {[key: string]: string};
}

export interface DetectorRule {
    /**
     * Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
     */
    description?: string;
    /**
     * A detect label which matches a detect label within `programText`.
     */
    detectLabel: string;
    /**
     * When true, notifications and events will not be generated for the detect label. `false` by default.
     */
    disabled?: boolean;
    /**
     * List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
     */
    notifications?: string[];
    /**
     * Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
     */
    parameterizedBody?: string;
    /**
     * Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
     */
    parameterizedSubject?: string;
    /**
     * Reminder notification in a detector rule lets you send multiple notifications for active alerts over a defined period of time. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
     */
    reminderNotification?: outputs.DetectorRuleReminderNotification;
    /**
     * URL of page to consult when an alert is triggered. This can be used with custom notification messages.
     */
    runbookUrl?: string;
    /**
     * The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
     */
    severity: string;
    /**
     * Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
     */
    tip?: string;
}

export interface DetectorRuleReminderNotification {
    /**
     * The interval at which you want to receive the notifications, in milliseconds.
     */
    intervalMs: number;
    /**
     * The duration during which repeat notifications are sent, in milliseconds.
     */
    timeoutMs?: number;
    /**
     * Type of reminder notification. Currently, the only supported value is TIMEOUT.
     */
    type: string;
}

export interface DetectorVizOption {
    /**
     * Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the plot (metric time series data) you want to customize.
     */
    label: string;
    /**
     * , `valueSuffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
     *
     * **Notes**
     *
     * Use both `maxDelay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
     */
    valuePrefix?: string;
    /**
     * An arbitrary suffix to display with the value of this plot
     */
    valueSuffix?: string;
    /**
     * A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
     */
    valueUnit?: string;
}

export interface HeatmapChartColorRange {
    /**
     * The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
     */
    color: string;
    /**
     * The maximum value within the coloring range.
     */
    maxValue?: number;
    /**
     * The minimum value within the coloring range.
     */
    minValue?: number;
}

export interface HeatmapChartColorScale {
    /**
     * The color range to use. Hex values are not supported here. Must be one of red, gold, iris, green, jade, gray, blue, azure, navy, brown, orange, yellow, magenta, cerise, pink, violet, purple, lilac, emerald, chartreuse, yellowgreen, aquamarine.
     */
    color: string;
    /**
     * Indicates the lower threshold non-inclusive value for this range.
     */
    gt?: number;
    /**
     * Indicates the lower threshold inclusive value for this range.
     */
    gte?: number;
    /**
     * Indicates the upper threshold non-inclusive value for this range.
     */
    lt?: number;
    /**
     * Indicates the upper threshold inclusive value for this range.
     */
    lte?: number;
}

export interface ListChartColorScale {
    /**
     * The color to use. Must be one of red, gold, iris, green, jade, gray, blue, azure, navy, brown, orange, yellow, magenta, cerise, pink, violet, purple, lilac, emerald, chartreuse, yellowgreen, aquamarine.
     */
    color: string;
    /**
     * Indicates the lower threshold non-inclusive value for this range.
     */
    gt?: number;
    /**
     * Indicates the lower threshold inclusive value for this range.
     */
    gte?: number;
    /**
     * Indicates the upper threshold non-inculsive value for this range.
     */
    lt?: number;
    /**
     * Indicates the upper threshold inclusive value for this range.
     */
    lte?: number;
}

export interface ListChartLegendOptionsField {
    /**
     * True or False depending on if you want the property to be shown or hidden.
     */
    enabled?: boolean;
    /**
     * The name of the property to display. Note the special values of `sfMetric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://dev.splunk.com/observability/docs/signalflow/functions/data_function/) for the time series being displayed.
     */
    property: string;
}

export interface ListChartVizOption {
    /**
     * The color to use. Must be one of red, gold, iris, green, jade, gray, blue, azure, navy, brown, orange, yellow, magenta, cerise, pink, violet, purple, lilac, emerald, chartreuse, yellowgreen, aquamarine.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the plot (metric time series data) you want to customize.
     */
    label: string;
    /**
     * , `valueSuffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
     */
    valuePrefix?: string;
    /**
     * An arbitrary suffix to display with the value of this plot
     */
    valueSuffix?: string;
    /**
     * A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
     */
    valueUnit?: string;
}

export interface MetricRulesetAggregationRule {
    /**
     * Aggregator object
     */
    aggregators: outputs.MetricRulesetAggregationRuleAggregator[];
    /**
     * Information about an aggregation rule
     */
    description?: string;
    /**
     * When false, this rule will not generate aggregated MTSs
     */
    enabled: boolean;
    /**
     * Matcher object
     */
    matchers: outputs.MetricRulesetAggregationRuleMatcher[];
    /**
     * name of the aggregation rule
     */
    name?: string;
}

export interface MetricRulesetAggregationRuleAggregator {
    /**
     * List of dimensions to either be kept or dropped in the new aggregated MTSs
     */
    dimensions: string[];
    /**
     * when true, the specified dimensions will be dropped from the aggregated MTSs
     */
    dropDimensions: boolean;
    /**
     * name of the new aggregated metric
     */
    outputName: string;
    /**
     * Type of aggregator. Must always be "rollup"
     */
    type: string;
}

export interface MetricRulesetAggregationRuleMatcher {
    /**
     * List of filters to filter the set of input MTSs
     */
    filters?: outputs.MetricRulesetAggregationRuleMatcherFilter[];
    /**
     * Type of matcher. Must always be "dimension"
     */
    type: string;
}

export interface MetricRulesetAggregationRuleMatcherFilter {
    /**
     * When true, this filter will match all values not matching the property_values
     */
    not: boolean;
    /**
     * Name of the dimension
     */
    property: string;
    /**
     * Value of the dimension
     */
    propertyValues: string[];
}

export interface MetricRulesetExceptionRule {
    /**
     * Information about an exception rule
     */
    description?: string;
    /**
     * When false, this rule will not route matched data to real-time
     */
    enabled: boolean;
    /**
     * Matcher object
     */
    matchers: outputs.MetricRulesetExceptionRuleMatcher[];
    /**
     * name of the exception rule
     */
    name?: string;
    /**
     * Properties of a restoration job
     */
    restorations?: outputs.MetricRulesetExceptionRuleRestoration[];
}

export interface MetricRulesetExceptionRuleMatcher {
    /**
     * List of filters to filter the set of input MTSs
     */
    filters?: outputs.MetricRulesetExceptionRuleMatcherFilter[];
    /**
     * Type of matcher. Must always be "dimension"
     */
    type: string;
}

export interface MetricRulesetExceptionRuleMatcherFilter {
    /**
     * When true, this filter will match all values not matching the property_values
     */
    not: boolean;
    /**
     * Name of the dimension
     */
    property: string;
    /**
     * Value of the dimension
     */
    propertyValues: string[];
}

export interface MetricRulesetExceptionRuleRestoration {
    /**
     * ID of the restoration job.
     */
    restorationId: string;
    /**
     * Time from which the restoration job will restore archived data, in the form of *nix time in milliseconds
     */
    startTime: string;
    /**
     * Time to which the restoration job will restore archived data, in the form of *nix time in milliseconds
     */
    stopTime?: string;
}

export interface MetricRulesetRoutingRule {
    /**
     * end destination of the input metric. Must be `RealTime`, `Archived`, or `Drop`
     */
    destination: string;
}

export interface OrgTokenDpmLimits {
    /**
     * The datapoints per minute (dpm) limit for this token. If you exceed this limit, Splunk Observability Cloud sends out an alert.
     */
    dpmLimit: number;
    /**
     * DPM level at which Splunk Observability Cloud sends the notification for this token. If you don't specify a notification, Splunk Observability Cloud sends the generic notification.
     */
    dpmNotificationThreshold?: number;
}

export interface OrgTokenHostOrUsageLimits {
    /**
     * Max number of Docker containers that can use this token
     */
    containerLimit?: number;
    /**
     * Notification threshold for Docker containers
     */
    containerNotificationThreshold?: number;
    /**
     * Max number of custom metrics that can be sent with this token
     */
    customMetricsLimit?: number;
    /**
     * Notification threshold for custom metrics
     */
    customMetricsNotificationThreshold?: number;
    /**
     * Max number of hi-res metrics that can be sent with this toke
     */
    highResMetricsLimit?: number;
    /**
     * Notification threshold for hi-res metrics
     */
    highResMetricsNotificationThreshold?: number;
    /**
     * Max number of hosts that can use this token
     */
    hostLimit?: number;
    /**
     * Notification threshold for hosts
     */
    hostNotificationThreshold?: number;
}

export interface SingleValueChartColorScale {
    /**
     * The color to use. Must be one of red, gold, iris, green, jade, gray, blue, azure, navy, brown, orange, yellow, magenta, cerise, pink, violet, purple, lilac, emerald, chartreuse, yellowgreen, aquamarine.
     */
    color: string;
    /**
     * Indicates the lower threshold non-inclusive value for this range.
     */
    gt?: number;
    /**
     * Indicates the lower threshold inclusive value for this range.
     */
    gte?: number;
    /**
     * Indicates the upper threshold non-inculsive value for this range.
     */
    lt?: number;
    /**
     * Indicates the upper threshold inclusive value for this range.
     */
    lte?: number;
}

export interface SingleValueChartVizOption {
    /**
     * The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the plot (metric time series data) you want to customize.
     */
    label: string;
    /**
     * , `valueSuffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
     */
    valuePrefix?: string;
    /**
     * An arbitrary suffix to display with the value of this plot
     */
    valueSuffix?: string;
    /**
     * A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
     */
    valueUnit?: string;
}

export interface SloInput {
    /**
     * Label used in `"programText"` that refers to the data block which contains the stream of successful events
     */
    goodEventsLabel?: string;
    /**
     * SignalFlow program and arguments text strings that define the streams used as successful event count and total event count
     */
    programText: string;
    /**
     * Label used in `"programText"` that refers to the data block which contains the stream of total events
     */
    totalEventsLabel?: string;
}

export interface SloTarget {
    /**
     * List of alert rules you want to set for this SLO target. An SLO alert rule of type BREACH is always required.
     */
    alertRules: outputs.SloTargetAlertRule[];
    /**
     * Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
     */
    compliancePeriod?: string;
    /**
     * It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
     */
    cycleStart: string;
    /**
     * The cycle type of the calendar window, e.g. week, month.
     */
    cycleType?: string;
    /**
     * Target value in the form of a percentage
     */
    slo: number;
    /**
     * SLO target type can be the following type: `"RollingWindow"`, `"CalendarWindow"`
     */
    type: string;
}

export interface SloTargetAlertRule {
    /**
     * Set of rules used for alerting.
     */
    rules: outputs.SloTargetAlertRuleRule[];
    /**
     * SLO alert rule can be one of the following types: BREACH, ERROR_BUDGET_LEFT, BURN_RATE. Within an SLO object, you can only specify one SLO alertRule per type. For example, you can't specify two alertRule of type BREACH. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
     */
    type: string;
}

export interface SloTargetAlertRuleRule {
    /**
     * Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
     */
    description?: string;
    /**
     * When true, notifications and events will not be generated for the detect label. `false` by default.
     */
    disabled?: boolean;
    /**
     * List of strings specifying where notifications will be sent when an incident occurs. See [Create SLO](https://dev.splunk.com/observability/reference/api/slo/latest#endpoint-create-new-slo) for more info.
     */
    notifications?: string[];
    /**
     * Custom notification message body when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
     */
    parameterizedBody?: string;
    /**
     * Custom notification message subject when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
     */
    parameterizedSubject?: string;
    /**
     * Parameters for the SLO alert rule. Each SLO alert rule type accepts different parameters. If not specified, default parameters are used.
     */
    parameters?: outputs.SloTargetAlertRuleRuleParameters;
    /**
     * Reminder notification in a detector rule lets you send multiple notifications for active alerts over a defined period of time.
     */
    reminderNotification?: outputs.SloTargetAlertRuleRuleReminderNotification;
    /**
     * URL of page to consult when an alert is triggered. This can be used with custom notification messages.
     */
    runbookUrl?: string;
    /**
     * The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
     */
    severity: string;
    /**
     * Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
     */
    tip?: string;
}

export interface SloTargetAlertRuleRuleParameters {
    /**
     * Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burnRateThreshold1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
     */
    burnRateThreshold1: number;
    /**
     * Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burnRateThreshold2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
     */
    burnRateThreshold2: number;
    /**
     * Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the fireLasting parameter. Default: `"5m"`
     */
    fireLasting: string;
    /**
     * Long window 1 used in burn rate alert calculation. This value must be longer than `"shortWindow1"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"longWindow1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
     */
    longWindow1: string;
    /**
     * Long window 2 used in burn rate alert calculation. This value must be longer than `"shortWindow2"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"longWindow2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
     */
    longWindow2: string;
    /**
     * Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: `"ERROR_BUDGET_LEFT"` alert rules use the `"percentErrorBudgetLeft"` parameter. Default: `100`
     */
    percentErrorBudgetLeft: number;
    /**
     * Percentage of the `"fireLasting"` duration that the alert condition is met before the alert is triggered. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the `"percentOfLasting"` parameter. Default: `100`
     */
    percentOfLasting: number;
    /**
     * Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of `"longWindow1"`. Note: `"BURN_RATE"` alert rules use the `"shortWindow1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
     */
    shortWindow1: string;
    /**
     * Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of `"longWindow2"`. Note: `"BURN_RATE"` alert rules use the `"shortWindow2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
     */
    shortWindow2: string;
}

export interface SloTargetAlertRuleRuleReminderNotification {
    /**
     * The interval at which you want to receive the notifications, in milliseconds.
     */
    intervalMs: number;
    /**
     * The duration during which repeat notifications are sent, in milliseconds.
     */
    timeoutMs?: number;
    /**
     * Type of the SLO. Currently just: `"RequestBased"` is supported.
     */
    type: string;
}

export interface TableChartVizOption {
    /**
     * Color to use
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * The label used in the publish statement that displays the plot (metric time series data) you want to customize
     */
    label: string;
    /**
     * An arbitrary prefix to display with the value of this plot
     */
    valuePrefix?: string;
    /**
     * An arbitrary suffix to display with the value of this plot
     */
    valueSuffix?: string;
    /**
     * A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
     */
    valueUnit?: string;
}

export interface TimeChartAxisLeft {
    /**
     * A line to draw as a high watermark.
     */
    highWatermark?: number;
    /**
     * A label to attach to the high watermark line.
     */
    highWatermarkLabel?: string;
    /**
     * Label of the left axis.
     */
    label?: string;
    /**
     * A line to draw as a low watermark.
     */
    lowWatermark?: number;
    /**
     * A label to attach to the low watermark line.
     */
    lowWatermarkLabel?: string;
    /**
     * The maximum value for the left axis.
     */
    maxValue?: number;
    /**
     * The minimum value for the left axis.
     */
    minValue?: number;
    watermarks?: outputs.TimeChartAxisLeftWatermark[];
}

export interface TimeChartAxisLeftWatermark {
    /**
     * Label to display associated with the watermark line
     */
    label?: string;
    /**
     * Axis value where the watermark line will be displayed
     */
    value: number;
}

export interface TimeChartAxisRight {
    /**
     * A line to draw as a high watermark.
     */
    highWatermark?: number;
    /**
     * A label to attach to the high watermark line.
     */
    highWatermarkLabel?: string;
    /**
     * Label of the right axis.
     */
    label?: string;
    /**
     * A line to draw as a low watermark.
     */
    lowWatermark?: number;
    /**
     * A label to attach to the low watermark line.
     */
    lowWatermarkLabel?: string;
    /**
     * The maximum value for the right axis.
     */
    maxValue?: number;
    /**
     * The minimum value for the right axis.
     */
    minValue?: number;
    watermarks?: outputs.TimeChartAxisRightWatermark[];
}

export interface TimeChartAxisRightWatermark {
    /**
     * Label to display associated with the watermark line
     */
    label?: string;
    /**
     * Axis value where the watermark line will be displayed
     */
    value: number;
}

export interface TimeChartEventOption {
    /**
     * Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the event query you want to customize.
     */
    label: string;
}

export interface TimeChartHistogramOption {
    /**
     * Color to use. Must be one of red, gold, iris, green, jade, gray, blue, azure, navy, brown, orange, yellow, magenta, cerise, pink, violet, purple, lilac, emerald, chartreuse, yellowgreen, aquamarine.
     */
    colorTheme?: string;
}

export interface TimeChartLegendOptionsField {
    /**
     * True or False depending on if you want the property to be shown or hidden.
     */
    enabled?: boolean;
    /**
     * The name of the property to display. Note the special values of `plotLabel` (corresponding with the API's `sfMetric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
     */
    property: string;
}

export interface TimeChartVizOption {
    /**
     * Y-axis associated with values for this plot. Must be either `right` or `left`.
     */
    axis?: string;
    /**
     * Color to use. Must be one of red, gold, iris, green, jade, gray, blue, azure, navy, brown, orange, yellow, magenta, cerise, pink, violet, purple, lilac, emerald, chartreuse, yellowgreen, aquamarine.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the plot (metric time series data) you want to customize.
     */
    label: string;
    /**
     * The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plotType` by default.
     */
    plotType?: string;
    /**
     * , `valueSuffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
     */
    valuePrefix?: string;
    /**
     * An arbitrary suffix to display with the value of this plot
     */
    valueSuffix?: string;
    /**
     * A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
     */
    valueUnit?: string;
}

export interface WebhookIntegrationHeader {
    /**
     * The key of the header to send
     */
    headerKey: string;
    /**
     * The value of the header to send
     */
    headerValue: string;
}

export namespace automatedarchival {
    export interface ExemptMetricExemptMetric {
        /**
         * Timestamp of when the automated archival setting was created
         */
        created: number;
        /**
         * ID of the creator of the automated archival setting
         */
        creator: string;
        /**
         * Timestamp of when the automated archival setting was last updated
         */
        lastUpdated: number;
        /**
         * ID of user who last updated the automated archival setting
         */
        lastUpdatedBy: string;
        /**
         * Name of the metric to be exempted from automated archival
         */
        name: string;
    }

}

export namespace aws {
    export interface IntegrationCustomNamespaceSyncRule {
        /**
         * Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filterAction` and `filterSource` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
         */
        defaultAction?: string;
        /**
         * Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
         */
        filterAction?: string;
        /**
         * Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         */
        filterSource?: string;
        /**
         * An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See the AWS documentation on publishing metrics for more information.
         */
        namespace: string;
    }

    export interface IntegrationMetricStatsToSync {
        /**
         * AWS metric that you want to pick statistics for
         */
        metric: string;
        /**
         * An AWS namespace having AWS metric that you want to pick statistics for
         */
        namespace: string;
        /**
         * AWS statistics you want to collect
         */
        stats: string[];
    }

    export interface IntegrationNamespaceSyncRule {
        /**
         * Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filterAction` and `filterSource` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
         */
        defaultAction?: string;
        /**
         * Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
         */
        filterAction?: string;
        /**
         * Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         */
        filterSource?: string;
        /**
         * An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See `services` field description below for additional information.
         */
        namespace: string;
    }

}

export namespace azure {
    export interface IntegrationCustomNamespacesPerService {
        /**
         * The additional namespaces.
         */
        namespaces: string[];
        /**
         * The name of the service.
         */
        service: string;
    }

    export interface IntegrationResourceFilterRule {
        /**
         * Expression that selects the data that Splunk Observability Cloud should sync for the resource associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function. The source of each filter rule must be in the form filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are limited to tags and must start with the azure_tag_ prefix.
         */
        filterSource: string;
    }

}

export namespace gcp {
    export interface IntegrationProjectServiceKey {
        projectId: string;
        projectKey: string;
    }

    export interface IntegrationProjectWifConfig {
        projectId: string;
        wifConfig: string;
    }

}

export namespace log {
    export interface ViewColumn {
        /**
         * Name of the log view.
         */
        name: string;
    }

    export interface ViewSortOption {
        /**
         * Name of the column
         */
        descending: boolean;
        /**
         * Name of the column
         */
        field: string;
    }

}
