// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AlertMutingRuleFilter {
    /**
     * Determines if this is a "not" filter. Defaults to `false`.
     */
    negated?: boolean;
    /**
     * The property to filter.
     */
    property: string;
    /**
     * The property value to filter.
     */
    propertyValue: string;
}

export interface DashboardChart {
    /**
     * ID of the chart to display.
     */
    chartId: string;
    /**
     * The column to show the chart in (zero-based); this value always represents the leftmost column of the chart (between `0` and `11`).
     */
    column?: number;
    /**
     * How many rows the chart should take up (greater than or equal to `1`). `1` by default.
     */
    height?: number;
    /**
     * The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
     */
    row?: number;
    /**
     * How many columns (out of a total of 12) the chart should take up (between `1` and `12`). `12` by default.
     */
    width?: number;
}

export interface DashboardColumn {
    /**
     * List of IDs of the charts to display.
     */
    chartIds: string[];
    /**
     * Column number for the layout.
     */
    column?: number;
    /**
     * How many rows every chart should take up (greater than or equal to 1). 1 by default.
     */
    height?: number;
    /**
     * How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
     */
    width?: number;
}

export interface DashboardEventOverlay {
    /**
     * Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
     */
    color?: string;
    /**
     * Text shown in the dropdown when selecting this overlay from the menu.
     */
    label?: string;
    /**
     * Show a vertical line for the event. `false` by default.
     */
    line?: boolean;
    /**
     * Search term used to choose the events shown in the overlay.
     */
    signal: string;
    /**
     * Each element specifies a filter to use against the signal specified in the `signal`.
     */
    sources?: outputs.DashboardEventOverlaySource[];
    /**
     * Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
     */
    type?: string;
}

export interface DashboardEventOverlaySource {
    /**
     * If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
     */
    negated?: boolean;
    /**
     * The name of a dimension to filter against.
     */
    property: string;
    /**
     * A list of values to be used with the `property`, they will be combined via `OR`.
     */
    values: string[];
}

export interface DashboardFilter {
    /**
     * If true, this filter will also match data that doesn't have this property at all.
     */
    applyIfExist?: boolean;
    /**
     * Whether this filter should be a not filter. `false` by default.
     */
    negated?: boolean;
    /**
     * A metric time series dimension or property name.
     */
    property: string;
    /**
     * List of of strings (which will be treated as an OR filter on the property).
     */
    values: string[];
}

export interface DashboardGrid {
    /**
     * List of IDs of the charts to display.
     */
    chartIds: string[];
    /**
     * How many rows every chart should take up (greater than or equal to `1`). `1` by default.
     */
    height?: number;
    /**
     * How many columns (out of a total of 12) every chart should take up (between `1` and `12`). `12` by default.
     */
    width?: number;
}

export interface DashboardGroupDashboard {
    configId: string;
    /**
     * The dashboard id to mirror
     */
    dashboardId: string;
    /**
     * The description that will override the original dashboards's description.
     */
    descriptionOverride?: string;
    /**
     * The description that will override the original dashboards's description.
     */
    filterOverrides?: outputs.DashboardGroupDashboardFilterOverride[];
    /**
     * The name that will override the original dashboards's name.
     */
    nameOverride?: string;
    variableOverrides?: outputs.DashboardGroupDashboardVariableOverride[];
}

export interface DashboardGroupDashboardFilterOverride {
    /**
     * If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
     */
    negated?: boolean;
    /**
     * A metric time series dimension or property name.
     */
    property: string;
    /**
     * List of of strings (which will be treated as an OR filter on the property).
     */
    values: string[];
}

export interface DashboardGroupDashboardVariableOverride {
    /**
     * The name of a dimension to filter against.
     */
    property: string;
    /**
     * A list of values to be used with the `property`, they will be combined via `OR`.
     */
    values?: string[];
    /**
     * A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
     */
    valuesSuggesteds?: string[];
}

export interface DashboardGroupImportQualifier {
    filters?: outputs.DashboardGroupImportQualifierFilter[];
    metric?: string;
}

export interface DashboardGroupImportQualifierFilter {
    /**
     * If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
     */
    negated?: boolean;
    /**
     * The name of a dimension to filter against.
     */
    property: string;
    /**
     * A list of values to be used with the `property`, they will be combined via `OR`.
     */
    values: string[];
}

export interface DashboardGroupPermission {
    /**
     * Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
     */
    actions?: string[];
    /**
     * ID of the user, team, or organization for which you're granting permissions.
     */
    principalId: string;
    /**
     * Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
     */
    principalType: string;
}

export interface DashboardPermissions {
    /**
     * List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
     */
    acls?: outputs.DashboardPermissionsAcl[];
    /**
     * ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
     */
    parent?: string;
}

export interface DashboardPermissionsAcl {
    /**
     * Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
     */
    actions?: string[];
    /**
     * ID of the user, team, or organization for which you're granting permissions.
     */
    principalId: string;
    /**
     * Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
     */
    principalType: string;
}

export interface DashboardSelectedEventOverlay {
    /**
     * Search term used to choose the events shown in the overlay.
     */
    signal: string;
    /**
     * Each element specifies a filter to use against the signal specified in the `signal`.
     */
    sources?: outputs.DashboardSelectedEventOverlaySource[];
    /**
     * Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
     */
    type?: string;
}

export interface DashboardSelectedEventOverlaySource {
    /**
     * If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
     */
    negated?: boolean;
    /**
     * The name of a dimension to filter against.
     */
    property: string;
    /**
     * A list of values to be used with the `property`, they will be combined via `OR`.
     */
    values: string[];
}

export interface DashboardVariable {
    /**
     * An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
     */
    alias: string;
    /**
     * If true, this variable will also match data that doesn't have this property at all.
     */
    applyIfExist?: boolean;
    /**
     * Variable description.
     */
    description?: string;
    /**
     * A metric time series dimension or property name.
     */
    property: string;
    /**
     * If `true`, this variable will only apply to charts that have a filter for the property.
     */
    replaceOnly?: boolean;
    /**
     * If `true`, this variable may only be set to the values listed in `valuesSuggested` and only these values will appear in autosuggestion menus. `false` by default.
     */
    restrictedSuggestions?: boolean;
    /**
     * Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
     */
    valueRequired?: boolean;
    /**
     * List of of strings (which will be treated as an OR filter on the property).
     */
    values?: string[];
    /**
     * A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
     */
    valuesSuggesteds?: string[];
}

export interface DataLinkTargetExternalUrl {
    /**
     * The [minimum time window](https://developers.signalfx.com/administration/data_links_overview.html#_minimum_time_window) for a search sent to an external site. Defaults to `6000`
     */
    minimumTimeWindow?: string;
    /**
     * User-assigned target name. Use this value to differentiate between the link targets for a data link object.
     */
    name: string;
    /**
     * Describes the relationship between SignalFx metadata keys and external system properties when the key names are different.
     */
    propertyKeyMapping?: {[key: string]: string};
    /**
     * [Designates the format](https://developers.signalfx.com/administration/data_links_overview.html#_minimum_time_window) of `minimumTimeWindow` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
     */
    timeFormat?: string;
    /**
     * URL string for a Splunk instance or external system data link target. [See the supported template variables](https://developers.signalfx.com/administration/data_links_overview.html#_external_link_targets).
     */
    url: string;
}

export interface DataLinkTargetSignalfxDashboard {
    /**
     * SignalFx-assigned ID of the dashboard link target's dashboard group
     */
    dashboardGroupId: string;
    /**
     * SignalFx-assigned ID of the dashboard link target
     */
    dashboardId: string;
    /**
     * Flag that designates a target as the default for a data link object. `true` by default
     */
    isDefault?: boolean;
    /**
     * User-assigned target name. Use this value to differentiate between the link targets for a data link object.
     */
    name: string;
}

export interface DataLinkTargetSplunk {
    /**
     * User-assigned target name. Use this value to differentiate between the link targets for a data link object.
     */
    name: string;
    /**
     * Describes the relationship between SignalFx metadata keys and external system properties when the key names are different.
     */
    propertyKeyMapping?: {[key: string]: string};
}

export interface DetectorRule {
    /**
     * Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
     */
    description?: string;
    /**
     * A detect label which matches a detect label within `programText`.
     */
    detectLabel: string;
    /**
     * When true, notifications and events will not be generated for the detect label. `false` by default.
     */
    disabled?: boolean;
    /**
     * List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://developers.signalfx.com/detectors_reference.html#operation/Create%20Single%20Detector) for more info.
     */
    notifications?: string[];
    /**
     * Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.signalfx.com/en/latest/detect-alert/set-up-detectors.html#about-detectors#alert-settings) for more info.
     */
    parameterizedBody?: string;
    /**
     * Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.signalfx.com/en/latest/detect-alert/set-up-detectors.html#about-detectors#alert-settings) for more info.
     */
    parameterizedSubject?: string;
    /**
     * URL of page to consult when an alert is triggered. This can be used with custom notification messages.
     */
    runbookUrl?: string;
    /**
     * The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
     */
    severity: string;
    /**
     * Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
     */
    tip?: string;
}

export interface DetectorVizOption {
    /**
     * Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the plot (metric time series data) you want to customize.
     */
    label: string;
    /**
     * , `valueSuffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
     *
     * **Notes**
     *
     * It is highly recommended that you use both `maxDelay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives/negatives.
     *
     * `maxDelay` allows SignalFx to continue with computation if there is a lag in receiving data points.
     *
     * `extrapolation` allows you to specify how to handle missing data. An extrapolation policy can be added to individual signals by updating the data block in your `programText`.
     *
     * See [Delayed Datapoints](https://signalfx-product-docs.readthedocs-hosted.com/en/latest/charts/chart-builder.html#delayed-datapoints) for more info.
     */
    valuePrefix?: string;
    valueSuffix?: string;
    /**
     * A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
     */
    valueUnit?: string;
}

export interface HeatmapChartColorRange {
    /**
     * The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
     */
    color: string;
    /**
     * The maximum value within the coloring range.
     */
    maxValue?: number;
    /**
     * The minimum value within the coloring range.
     */
    minValue?: number;
}

export interface HeatmapChartColorScale {
    /**
     * The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
     */
    color: string;
    /**
     * Indicates the lower threshold non-inclusive value for this range.
     */
    gt?: number;
    /**
     * Indicates the lower threshold inclusive value for this range.
     */
    gte?: number;
    /**
     * Indicates the upper threshold non-inclusive value for this range.
     */
    lt?: number;
    /**
     * Indicates the upper threshold inclusive value for this range.
     */
    lte?: number;
}

export interface ListChartColorScale {
    /**
     * The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
     */
    color: string;
    /**
     * Indicates the lower threshold non-inclusive value for this range.
     */
    gt?: number;
    /**
     * Indicates the lower threshold inclusive value for this range.
     */
    gte?: number;
    /**
     * Indicates the upper threshold non-inculsive value for this range.
     */
    lt?: number;
    /**
     * Indicates the upper threshold inclusive value for this range.
     */
    lte?: number;
}

export interface ListChartLegendOptionsField {
    /**
     * True or False depending on if you want the property to be shown or hidden.
     */
    enabled?: boolean;
    /**
     * The name of the property to display. Note the special values of `sfMetric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://developers.signalfx.com/signalflow_analytics/functions/data_function.html#table-1-parameter-definitions) for the time series being displayed.
     */
    property: string;
}

export interface ListChartVizOption {
    /**
     * The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the plot (metric time series data) you want to customize.
     */
    label: string;
    /**
     * , `valueSuffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
     */
    valuePrefix?: string;
    valueSuffix?: string;
    /**
     * A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
     */
    valueUnit?: string;
}

export interface MetricRulesetAggregationRule {
    /**
     * Aggregator object
     */
    aggregators: outputs.MetricRulesetAggregationRuleAggregator[];
    /**
     * When false, this rule will not generate aggregated MTSs
     */
    enabled: boolean;
    /**
     * Matcher object
     */
    matchers: outputs.MetricRulesetAggregationRuleMatcher[];
    /**
     * name of the aggregation rule
     */
    name?: string;
}

export interface MetricRulesetAggregationRuleAggregator {
    /**
     * List of dimensions to either be kept or dropped in the new aggregated MTSs
     */
    dimensions: string[];
    /**
     * when true, the specified dimensions will be dropped from the aggregated MTSs
     */
    dropDimensions: boolean;
    /**
     * name of the new aggregated metric
     */
    outputName: string;
    /**
     * Type of aggregator. Must always be "rollup"
     */
    type: string;
}

export interface MetricRulesetAggregationRuleMatcher {
    /**
     * List of filters to filter the set of input MTSs
     */
    filters?: outputs.MetricRulesetAggregationRuleMatcherFilter[];
    /**
     * Type of matcher. Must always be "dimension"
     */
    type: string;
}

export interface MetricRulesetAggregationRuleMatcherFilter {
    /**
     * When true, this filter will match all values not matching the property_values
     */
    not: boolean;
    /**
     * Name of the dimension
     */
    property: string;
    /**
     * Value of the dimension
     */
    propertyValues: string[];
}

export interface MetricRulesetRoutingRule {
    /**
     * end destination of the input metric. Must be `RealTime` or `Drop`
     */
    destination: string;
}

export interface OrgTokenDpmLimits {
    /**
     * The datapoints per minute (dpm) limit for this token. If you exceed this limit, SignalFx sends out an alert.
     */
    dpmLimit: number;
    /**
     * DPM level at which SignalFx sends the notification for this token. If you don't specify a notification, SignalFx sends the generic notification.
     */
    dpmNotificationThreshold?: number;
}

export interface OrgTokenHostOrUsageLimits {
    /**
     * Max number of Docker containers that can use this token
     */
    containerLimit?: number;
    /**
     * Notification threshold for Docker containers
     */
    containerNotificationThreshold?: number;
    /**
     * Max number of custom metrics that can be sent with this token
     */
    customMetricsLimit?: number;
    /**
     * Notification threshold for custom metrics
     */
    customMetricsNotificationThreshold?: number;
    /**
     * Max number of hi-res metrics that can be sent with this toke
     */
    highResMetricsLimit?: number;
    /**
     * Notification threshold for hi-res metrics
     */
    highResMetricsNotificationThreshold?: number;
    /**
     * Max number of hosts that can use this token
     */
    hostLimit?: number;
    /**
     * Notification threshold for hosts
     */
    hostNotificationThreshold?: number;
}

export interface SingleValueChartColorScale {
    /**
     * The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
     */
    color: string;
    /**
     * Indicates the lower threshold non-inclusive value for this range.
     */
    gt?: number;
    /**
     * Indicates the lower threshold inclusive value for this range.
     */
    gte?: number;
    /**
     * Indicates the upper threshold non-inculsive value for this range.
     */
    lt?: number;
    /**
     * Indicates the upper threshold inclusive value for this range.
     */
    lte?: number;
}

export interface SingleValueChartVizOption {
    /**
     * The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the plot (metric time series data) you want to customize.
     */
    label: string;
    /**
     * , `valueSuffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
     */
    valuePrefix?: string;
    valueSuffix?: string;
    /**
     * A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
     */
    valueUnit?: string;
}

export interface TableChartVizOption {
    color?: string;
    displayName?: string;
    label: string;
    valuePrefix?: string;
    valueSuffix?: string;
    valueUnit?: string;
}

export interface TimeChartAxisLeft {
    /**
     * A line to draw as a high watermark.
     */
    highWatermark?: number;
    /**
     * A label to attach to the high watermark line.
     */
    highWatermarkLabel?: string;
    /**
     * Label of the left axis.
     */
    label?: string;
    /**
     * A line to draw as a low watermark.
     */
    lowWatermark?: number;
    /**
     * A label to attach to the low watermark line.
     */
    lowWatermarkLabel?: string;
    /**
     * The maximum value for the left axis.
     */
    maxValue?: number;
    /**
     * The minimum value for the left axis.
     */
    minValue?: number;
    watermarks?: outputs.TimeChartAxisLeftWatermark[];
}

export interface TimeChartAxisLeftWatermark {
    /**
     * Label of the left axis.
     */
    label?: string;
    value: number;
}

export interface TimeChartAxisRight {
    /**
     * A line to draw as a high watermark.
     */
    highWatermark?: number;
    /**
     * A label to attach to the high watermark line.
     */
    highWatermarkLabel?: string;
    /**
     * Label of the right axis.
     */
    label?: string;
    /**
     * A line to draw as a low watermark.
     */
    lowWatermark?: number;
    /**
     * A label to attach to the low watermark line.
     */
    lowWatermarkLabel?: string;
    /**
     * The maximum value for the right axis.
     */
    maxValue?: number;
    /**
     * The minimum value for the right axis.
     */
    minValue?: number;
    watermarks?: outputs.TimeChartAxisRightWatermark[];
}

export interface TimeChartAxisRightWatermark {
    /**
     * Label of the left axis.
     */
    label?: string;
    value: number;
}

export interface TimeChartEventOption {
    /**
     * Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the event query you want to customize.
     */
    label: string;
}

export interface TimeChartHistogramOption {
    /**
     * Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
     */
    colorTheme?: string;
}

export interface TimeChartLegendOptionsField {
    /**
     * True or False depending on if you want the property to be shown or hidden.
     */
    enabled?: boolean;
    /**
     * The name of the property to display. Note the special values of `plotLabel` (corresponding with the API's `sfMetric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
     */
    property: string;
}

export interface TimeChartVizOption {
    /**
     * Y-axis associated with values for this plot. Must be either `right` or `left`.
     */
    axis?: string;
    /**
     * Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
     */
    color?: string;
    /**
     * Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
     */
    displayName?: string;
    /**
     * Label used in the publish statement that displays the plot (metric time series data) you want to customize.
     */
    label: string;
    /**
     * The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plotType` by default.
     */
    plotType?: string;
    /**
     * , `valueSuffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
     */
    valuePrefix?: string;
    valueSuffix?: string;
    /**
     * A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
     */
    valueUnit?: string;
}

export interface WebhookIntegrationHeader {
    /**
     * The key of the header to send
     */
    headerKey: string;
    /**
     * The value of the header to send
     */
    headerValue: string;
}

export namespace aws {
    export interface IntegrationCustomNamespaceSyncRule {
        /**
         * Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filterAction` and `filterSource` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
         */
        defaultAction?: string;
        /**
         * Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
         */
        filterAction?: string;
        /**
         * Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         */
        filterSource?: string;
        /**
         * An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability. See the AWS documentation on publishing metrics for more information.
         */
        namespace: string;
    }

    export interface IntegrationMetricStatsToSync {
        /**
         * AWS metric that you want to pick statistics for
         */
        metric: string;
        /**
         * An AWS namespace having AWS metric that you want to pick statistics for
         */
        namespace: string;
        /**
         * AWS statistics you want to collect
         */
        stats: string[];
    }

    export interface IntegrationNamespaceSyncRule {
        /**
         * Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filterAction` and `filterSource` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
         */
        defaultAction?: string;
        /**
         * Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
         */
        filterAction?: string;
        /**
         * Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         */
        filterSource?: string;
        /**
         * An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability. See `services` field description below for additional information.
         */
        namespace: string;
    }

}

export namespace azure {
    export interface IntegrationCustomNamespacesPerService {
        /**
         * The additional namespaces.
         */
        namespaces: string[];
        /**
         * The name of the service.
         */
        service: string;
    }

    export interface IntegrationResourceFilterRule {
        /**
         * Expression that selects the data that SignalFx should sync for the resource associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function. The source of each filter rule must be in the form filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are limited to tags and must start with the azure_tag_ prefix.
         */
        filterSource: string;
    }

}

export namespace gcp {
    export interface IntegrationProjectServiceKey {
        projectId: string;
        projectKey: string;
    }

}

export namespace log {
    export interface ViewColumn {
        /**
         * Name of the log view.
         */
        name: string;
    }

    export interface ViewSortOption {
        descending: boolean;
        field: string;
    }

}
