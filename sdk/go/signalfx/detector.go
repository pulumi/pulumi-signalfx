// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package signalfx

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-signalfx/sdk/v7/go/signalfx/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Splunk Observability Cloud detector resource. This can be used to create and manage detectors.
//
// If you're interested in using Splunk Observability Cloud detector features such as Historical Anomaly, Resource Running Out, or others, consider building them in the UI first and then use the "Show SignalFlow" feature to extract the value for `programText`. You can also see the [documentation for detector functions in signalflow-library](https://github.com/signalfx/signalflow-library/tree/master/library/signalfx/detectors).
//
// > **NOTE** When you want to change or remove write permissions for a user other than yourself regarding detectors, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
//
// ## Example
//
// ## Notification format
//
// As Splunk Observability Cloud supports different notification mechanisms, use a comma-delimited string to provide inputs. If you want to specify multiple notifications, each must be a member in the list, like so:
//
// See [Splunk Observability Cloud Docs](https://dev.splunk.com/observability/reference/api/detectors/latest) for more information.
//
// Here are some example of how to configure each notification type:
//
// ### Email
//
// ### Jira
//
// Note that the `credentialId` is the Splunk-provided ID shown after setting up your Jira integration. See also `jira.Integration`.
//
// ### OpsGenie
//
// Note that the `credentialId` is the Splunk-provided ID shown after setting up your Opsgenie integration. `Team` here is hardcoded as the `responderType` as that is the only acceptable type as per the API docs.
//
// ### PagerDuty
//
// ### Slack
//
// Exclude the `#` on the channel name:
//
// ### Team
//
// Sends [notifications to a team](https://docs.signalfx.com/en/latest/managing/teams/team-notifications.html).
//
// ### TeamEmail
//
// Sends an email to every member of a team.
//
// ### Splunk On-Call (formerly VictorOps)
//
// ### Webhooks
//
// You need to include all the commas even if you only use a credential id.
//
// You can either configure a Webhook to use an existing integration's credential id:
//
// Or configure one inline:
//
// ## Arguments
//
// * `name` - (Required) Name of the detector.
// * `programText` - (Required) Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
// * `description` - (Optional) Description of the detector.
// * `authorizedWriterTeams` - (Optional) Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorizedWriterUsers`).
// * `authorizedWriterUsers` - (Optional) User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorizedWriterTeams`).
// * `maxDelay` - (Optional) How long (in seconds) to wait for late datapoints. See [Delayed Datapoints](https://docs.splunk.com/observability/en/data-visualization/charts/chart-builder.html#delayed-datapoints) for more info. Max value is `900` seconds (15 minutes). `Auto` (as little as possible) by default.
// * `minDelay` - (Optional) How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
// * `showDataMarkers` - (Optional) When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
// * `showEventLines` - (Optional) When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
// * `disableSampling` - (Optional) When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
// * `timeRange` - (Optional) Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
// * `startTime` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `timeRange`.
// * `endTime` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `timeRange`.
// * `tags` - (Optional) Tags associated with the detector.
// * `teams` - (Optional) Team IDs to associate the detector to.
// * `rule` - (Required) Set of rules used for alerting.
//   - `detectLabel` - (Required) A detect label which matches a detect label within `programText`.
//   - `severity` - (Required) The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
//   - `description` - (Optional) Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
//   - `disabled` - (Optional) When true, notifications and events will not be generated for the detect label. `false` by default.
//   - `notifications` - (Optional) List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
//   - `parameterizedBody` - (Optional) Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
//   - `parameterizedSubject` - (Optional) Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
//   - `runbookUrl` - (Optional) URL of page to consult when an alert is triggered. This can be used with custom notification messages.
//   - `tip` - (Optional) Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
//
// * `vizOptions` - (Optional) Plot-level customization options, associated with a publish statement.
//   - `label` - (Required) Label used in the publish statement that displays the plot (metric time series data) you want to customize.
//   - `displayName` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
//   - `color` - (Optional) Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
//   - `valueUnit` - (Optional) A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
//   - `valuePrefix`, `valueSuffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
//
// **Notes**
//
// Use both `maxDelay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
//
// - `maxDelay` allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
// - `extrapolation` allows you to specify how to handle missing data. An extrapolation policy can be added to individual signals by updating the data block in your `programText`.
//
// See [Delayed Datapoints](https://docs.splunk.com/observability/en/data-visualization/charts/chart-builder.html#delayed-datapoints) for more info.
//
// ## Attributes
//
// In a addition to all arguments above, the following attributes are exported:
//
// * `id` - The ID of the detector.
// * `labelResolutions` - The resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert should be triggered.
// * `url` - The URL of the detector.
//
// ## Import
//
// Detectors can be imported using their string ID (recoverable from URL: `/#/detector/v2/abc123/edit`, e.g.
//
// ```sh
// $ pulumi import signalfx:index/detector:Detector application_delay abc123
// ```
type Detector struct {
	pulumi.CustomResourceState

	// Team IDs that have write access to this dashboard
	AuthorizedWriterTeams pulumi.StringArrayOutput `pulumi:"authorizedWriterTeams"`
	// User IDs that have write access to this dashboard
	AuthorizedWriterUsers pulumi.StringArrayOutput `pulumi:"authorizedWriterUsers"`
	// Description of the detector
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// (false by default) When false, samples a subset of the output MTS in the visualization.
	DisableSampling pulumi.BoolPtrOutput `pulumi:"disableSampling"`
	// Seconds since epoch. Used for visualization
	EndTime pulumi.IntPtrOutput `pulumi:"endTime"`
	// Resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert
	// should be triggered
	LabelResolutions pulumi.IntMapOutput `pulumi:"labelResolutions"`
	// Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
	MaxDelay pulumi.IntPtrOutput `pulumi:"maxDelay"`
	// Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
	// is 900 (15m)
	MinDelay pulumi.IntPtrOutput `pulumi:"minDelay"`
	// Name of the detector
	Name pulumi.StringOutput `pulumi:"name"`
	// Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
	ProgramText pulumi.StringOutput `pulumi:"programText"`
	// Set of rules used for alerting
	Rules DetectorRuleArrayOutput `pulumi:"rules"`
	// (true by default) When true, markers will be drawn for each datapoint within the visualization.
	ShowDataMarkers pulumi.BoolPtrOutput `pulumi:"showDataMarkers"`
	// (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
	ShowEventLines pulumi.BoolPtrOutput `pulumi:"showEventLines"`
	// Seconds since epoch. Used for visualization
	StartTime pulumi.IntPtrOutput `pulumi:"startTime"`
	// Tags associated with the detector
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// Team IDs to associate the detector to
	Teams pulumi.StringArrayOutput `pulumi:"teams"`
	// Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
	// to 3600
	TimeRange pulumi.IntPtrOutput `pulumi:"timeRange"`
	// The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
	Timezone pulumi.StringPtrOutput `pulumi:"timezone"`
	// URL of the detector
	Url pulumi.StringOutput `pulumi:"url"`
	// Plot-level customization options, associated with a publish statement
	VizOptions DetectorVizOptionArrayOutput `pulumi:"vizOptions"`
}

// NewDetector registers a new resource with the given unique name, arguments, and options.
func NewDetector(ctx *pulumi.Context,
	name string, args *DetectorArgs, opts ...pulumi.ResourceOption) (*Detector, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ProgramText == nil {
		return nil, errors.New("invalid value for required argument 'ProgramText'")
	}
	if args.Rules == nil {
		return nil, errors.New("invalid value for required argument 'Rules'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Detector
	err := ctx.RegisterResource("signalfx:index/detector:Detector", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDetector gets an existing Detector resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDetector(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DetectorState, opts ...pulumi.ResourceOption) (*Detector, error) {
	var resource Detector
	err := ctx.ReadResource("signalfx:index/detector:Detector", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Detector resources.
type detectorState struct {
	// Team IDs that have write access to this dashboard
	AuthorizedWriterTeams []string `pulumi:"authorizedWriterTeams"`
	// User IDs that have write access to this dashboard
	AuthorizedWriterUsers []string `pulumi:"authorizedWriterUsers"`
	// Description of the detector
	Description *string `pulumi:"description"`
	// (false by default) When false, samples a subset of the output MTS in the visualization.
	DisableSampling *bool `pulumi:"disableSampling"`
	// Seconds since epoch. Used for visualization
	EndTime *int `pulumi:"endTime"`
	// Resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert
	// should be triggered
	LabelResolutions map[string]int `pulumi:"labelResolutions"`
	// Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
	MaxDelay *int `pulumi:"maxDelay"`
	// Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
	// is 900 (15m)
	MinDelay *int `pulumi:"minDelay"`
	// Name of the detector
	Name *string `pulumi:"name"`
	// Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
	ProgramText *string `pulumi:"programText"`
	// Set of rules used for alerting
	Rules []DetectorRule `pulumi:"rules"`
	// (true by default) When true, markers will be drawn for each datapoint within the visualization.
	ShowDataMarkers *bool `pulumi:"showDataMarkers"`
	// (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
	ShowEventLines *bool `pulumi:"showEventLines"`
	// Seconds since epoch. Used for visualization
	StartTime *int `pulumi:"startTime"`
	// Tags associated with the detector
	Tags []string `pulumi:"tags"`
	// Team IDs to associate the detector to
	Teams []string `pulumi:"teams"`
	// Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
	// to 3600
	TimeRange *int `pulumi:"timeRange"`
	// The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
	Timezone *string `pulumi:"timezone"`
	// URL of the detector
	Url *string `pulumi:"url"`
	// Plot-level customization options, associated with a publish statement
	VizOptions []DetectorVizOption `pulumi:"vizOptions"`
}

type DetectorState struct {
	// Team IDs that have write access to this dashboard
	AuthorizedWriterTeams pulumi.StringArrayInput
	// User IDs that have write access to this dashboard
	AuthorizedWriterUsers pulumi.StringArrayInput
	// Description of the detector
	Description pulumi.StringPtrInput
	// (false by default) When false, samples a subset of the output MTS in the visualization.
	DisableSampling pulumi.BoolPtrInput
	// Seconds since epoch. Used for visualization
	EndTime pulumi.IntPtrInput
	// Resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert
	// should be triggered
	LabelResolutions pulumi.IntMapInput
	// Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
	MaxDelay pulumi.IntPtrInput
	// Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
	// is 900 (15m)
	MinDelay pulumi.IntPtrInput
	// Name of the detector
	Name pulumi.StringPtrInput
	// Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
	ProgramText pulumi.StringPtrInput
	// Set of rules used for alerting
	Rules DetectorRuleArrayInput
	// (true by default) When true, markers will be drawn for each datapoint within the visualization.
	ShowDataMarkers pulumi.BoolPtrInput
	// (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
	ShowEventLines pulumi.BoolPtrInput
	// Seconds since epoch. Used for visualization
	StartTime pulumi.IntPtrInput
	// Tags associated with the detector
	Tags pulumi.StringArrayInput
	// Team IDs to associate the detector to
	Teams pulumi.StringArrayInput
	// Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
	// to 3600
	TimeRange pulumi.IntPtrInput
	// The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
	Timezone pulumi.StringPtrInput
	// URL of the detector
	Url pulumi.StringPtrInput
	// Plot-level customization options, associated with a publish statement
	VizOptions DetectorVizOptionArrayInput
}

func (DetectorState) ElementType() reflect.Type {
	return reflect.TypeOf((*detectorState)(nil)).Elem()
}

type detectorArgs struct {
	// Team IDs that have write access to this dashboard
	AuthorizedWriterTeams []string `pulumi:"authorizedWriterTeams"`
	// User IDs that have write access to this dashboard
	AuthorizedWriterUsers []string `pulumi:"authorizedWriterUsers"`
	// Description of the detector
	Description *string `pulumi:"description"`
	// (false by default) When false, samples a subset of the output MTS in the visualization.
	DisableSampling *bool `pulumi:"disableSampling"`
	// Seconds since epoch. Used for visualization
	EndTime *int `pulumi:"endTime"`
	// Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
	MaxDelay *int `pulumi:"maxDelay"`
	// Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
	// is 900 (15m)
	MinDelay *int `pulumi:"minDelay"`
	// Name of the detector
	Name *string `pulumi:"name"`
	// Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
	ProgramText string `pulumi:"programText"`
	// Set of rules used for alerting
	Rules []DetectorRule `pulumi:"rules"`
	// (true by default) When true, markers will be drawn for each datapoint within the visualization.
	ShowDataMarkers *bool `pulumi:"showDataMarkers"`
	// (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
	ShowEventLines *bool `pulumi:"showEventLines"`
	// Seconds since epoch. Used for visualization
	StartTime *int `pulumi:"startTime"`
	// Tags associated with the detector
	Tags []string `pulumi:"tags"`
	// Team IDs to associate the detector to
	Teams []string `pulumi:"teams"`
	// Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
	// to 3600
	TimeRange *int `pulumi:"timeRange"`
	// The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
	Timezone *string `pulumi:"timezone"`
	// Plot-level customization options, associated with a publish statement
	VizOptions []DetectorVizOption `pulumi:"vizOptions"`
}

// The set of arguments for constructing a Detector resource.
type DetectorArgs struct {
	// Team IDs that have write access to this dashboard
	AuthorizedWriterTeams pulumi.StringArrayInput
	// User IDs that have write access to this dashboard
	AuthorizedWriterUsers pulumi.StringArrayInput
	// Description of the detector
	Description pulumi.StringPtrInput
	// (false by default) When false, samples a subset of the output MTS in the visualization.
	DisableSampling pulumi.BoolPtrInput
	// Seconds since epoch. Used for visualization
	EndTime pulumi.IntPtrInput
	// Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
	MaxDelay pulumi.IntPtrInput
	// Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
	// is 900 (15m)
	MinDelay pulumi.IntPtrInput
	// Name of the detector
	Name pulumi.StringPtrInput
	// Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
	ProgramText pulumi.StringInput
	// Set of rules used for alerting
	Rules DetectorRuleArrayInput
	// (true by default) When true, markers will be drawn for each datapoint within the visualization.
	ShowDataMarkers pulumi.BoolPtrInput
	// (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
	ShowEventLines pulumi.BoolPtrInput
	// Seconds since epoch. Used for visualization
	StartTime pulumi.IntPtrInput
	// Tags associated with the detector
	Tags pulumi.StringArrayInput
	// Team IDs to associate the detector to
	Teams pulumi.StringArrayInput
	// Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
	// to 3600
	TimeRange pulumi.IntPtrInput
	// The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
	Timezone pulumi.StringPtrInput
	// Plot-level customization options, associated with a publish statement
	VizOptions DetectorVizOptionArrayInput
}

func (DetectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*detectorArgs)(nil)).Elem()
}

type DetectorInput interface {
	pulumi.Input

	ToDetectorOutput() DetectorOutput
	ToDetectorOutputWithContext(ctx context.Context) DetectorOutput
}

func (*Detector) ElementType() reflect.Type {
	return reflect.TypeOf((**Detector)(nil)).Elem()
}

func (i *Detector) ToDetectorOutput() DetectorOutput {
	return i.ToDetectorOutputWithContext(context.Background())
}

func (i *Detector) ToDetectorOutputWithContext(ctx context.Context) DetectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetectorOutput)
}

// DetectorArrayInput is an input type that accepts DetectorArray and DetectorArrayOutput values.
// You can construct a concrete instance of `DetectorArrayInput` via:
//
//	DetectorArray{ DetectorArgs{...} }
type DetectorArrayInput interface {
	pulumi.Input

	ToDetectorArrayOutput() DetectorArrayOutput
	ToDetectorArrayOutputWithContext(context.Context) DetectorArrayOutput
}

type DetectorArray []DetectorInput

func (DetectorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Detector)(nil)).Elem()
}

func (i DetectorArray) ToDetectorArrayOutput() DetectorArrayOutput {
	return i.ToDetectorArrayOutputWithContext(context.Background())
}

func (i DetectorArray) ToDetectorArrayOutputWithContext(ctx context.Context) DetectorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetectorArrayOutput)
}

// DetectorMapInput is an input type that accepts DetectorMap and DetectorMapOutput values.
// You can construct a concrete instance of `DetectorMapInput` via:
//
//	DetectorMap{ "key": DetectorArgs{...} }
type DetectorMapInput interface {
	pulumi.Input

	ToDetectorMapOutput() DetectorMapOutput
	ToDetectorMapOutputWithContext(context.Context) DetectorMapOutput
}

type DetectorMap map[string]DetectorInput

func (DetectorMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Detector)(nil)).Elem()
}

func (i DetectorMap) ToDetectorMapOutput() DetectorMapOutput {
	return i.ToDetectorMapOutputWithContext(context.Background())
}

func (i DetectorMap) ToDetectorMapOutputWithContext(ctx context.Context) DetectorMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetectorMapOutput)
}

type DetectorOutput struct{ *pulumi.OutputState }

func (DetectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Detector)(nil)).Elem()
}

func (o DetectorOutput) ToDetectorOutput() DetectorOutput {
	return o
}

func (o DetectorOutput) ToDetectorOutputWithContext(ctx context.Context) DetectorOutput {
	return o
}

// Team IDs that have write access to this dashboard
func (o DetectorOutput) AuthorizedWriterTeams() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Detector) pulumi.StringArrayOutput { return v.AuthorizedWriterTeams }).(pulumi.StringArrayOutput)
}

// User IDs that have write access to this dashboard
func (o DetectorOutput) AuthorizedWriterUsers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Detector) pulumi.StringArrayOutput { return v.AuthorizedWriterUsers }).(pulumi.StringArrayOutput)
}

// Description of the detector
func (o DetectorOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// (false by default) When false, samples a subset of the output MTS in the visualization.
func (o DetectorOutput) DisableSampling() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.BoolPtrOutput { return v.DisableSampling }).(pulumi.BoolPtrOutput)
}

// Seconds since epoch. Used for visualization
func (o DetectorOutput) EndTime() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.IntPtrOutput { return v.EndTime }).(pulumi.IntPtrOutput)
}

// Resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert
// should be triggered
func (o DetectorOutput) LabelResolutions() pulumi.IntMapOutput {
	return o.ApplyT(func(v *Detector) pulumi.IntMapOutput { return v.LabelResolutions }).(pulumi.IntMapOutput)
}

// Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
func (o DetectorOutput) MaxDelay() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.IntPtrOutput { return v.MaxDelay }).(pulumi.IntPtrOutput)
}

// Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
// is 900 (15m)
func (o DetectorOutput) MinDelay() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.IntPtrOutput { return v.MinDelay }).(pulumi.IntPtrOutput)
}

// Name of the detector
func (o DetectorOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Detector) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
func (o DetectorOutput) ProgramText() pulumi.StringOutput {
	return o.ApplyT(func(v *Detector) pulumi.StringOutput { return v.ProgramText }).(pulumi.StringOutput)
}

// Set of rules used for alerting
func (o DetectorOutput) Rules() DetectorRuleArrayOutput {
	return o.ApplyT(func(v *Detector) DetectorRuleArrayOutput { return v.Rules }).(DetectorRuleArrayOutput)
}

// (true by default) When true, markers will be drawn for each datapoint within the visualization.
func (o DetectorOutput) ShowDataMarkers() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.BoolPtrOutput { return v.ShowDataMarkers }).(pulumi.BoolPtrOutput)
}

// (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
func (o DetectorOutput) ShowEventLines() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.BoolPtrOutput { return v.ShowEventLines }).(pulumi.BoolPtrOutput)
}

// Seconds since epoch. Used for visualization
func (o DetectorOutput) StartTime() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.IntPtrOutput { return v.StartTime }).(pulumi.IntPtrOutput)
}

// Tags associated with the detector
func (o DetectorOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Detector) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// Team IDs to associate the detector to
func (o DetectorOutput) Teams() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Detector) pulumi.StringArrayOutput { return v.Teams }).(pulumi.StringArrayOutput)
}

// Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
// to 3600
func (o DetectorOutput) TimeRange() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.IntPtrOutput { return v.TimeRange }).(pulumi.IntPtrOutput)
}

// The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
func (o DetectorOutput) Timezone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Detector) pulumi.StringPtrOutput { return v.Timezone }).(pulumi.StringPtrOutput)
}

// URL of the detector
func (o DetectorOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v *Detector) pulumi.StringOutput { return v.Url }).(pulumi.StringOutput)
}

// Plot-level customization options, associated with a publish statement
func (o DetectorOutput) VizOptions() DetectorVizOptionArrayOutput {
	return o.ApplyT(func(v *Detector) DetectorVizOptionArrayOutput { return v.VizOptions }).(DetectorVizOptionArrayOutput)
}

type DetectorArrayOutput struct{ *pulumi.OutputState }

func (DetectorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Detector)(nil)).Elem()
}

func (o DetectorArrayOutput) ToDetectorArrayOutput() DetectorArrayOutput {
	return o
}

func (o DetectorArrayOutput) ToDetectorArrayOutputWithContext(ctx context.Context) DetectorArrayOutput {
	return o
}

func (o DetectorArrayOutput) Index(i pulumi.IntInput) DetectorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Detector {
		return vs[0].([]*Detector)[vs[1].(int)]
	}).(DetectorOutput)
}

type DetectorMapOutput struct{ *pulumi.OutputState }

func (DetectorMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Detector)(nil)).Elem()
}

func (o DetectorMapOutput) ToDetectorMapOutput() DetectorMapOutput {
	return o
}

func (o DetectorMapOutput) ToDetectorMapOutputWithContext(ctx context.Context) DetectorMapOutput {
	return o
}

func (o DetectorMapOutput) MapIndex(k pulumi.StringInput) DetectorOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Detector {
		return vs[0].(map[string]*Detector)[vs[1].(string)]
	}).(DetectorOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DetectorInput)(nil)).Elem(), &Detector{})
	pulumi.RegisterInputType(reflect.TypeOf((*DetectorArrayInput)(nil)).Elem(), DetectorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DetectorMapInput)(nil)).Elem(), DetectorMap{})
	pulumi.RegisterOutputType(DetectorOutput{})
	pulumi.RegisterOutputType(DetectorArrayOutput{})
	pulumi.RegisterOutputType(DetectorMapOutput{})
}
