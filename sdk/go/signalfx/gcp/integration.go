// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gcp

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// SignalFx GCP Integration
//
// > **NOTE** When managing integrations use a session token for an administrator to authenticate the SignalFx provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"os"
//
//	"github.com/pulumi/pulumi-signalfx/sdk/v5/go/signalfx/gcp"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func readFileOrPanic(path string) pulumi.StringPtrInput {
//		data, err := os.ReadFile(path)
//		if err != nil {
//			panic(err.Error())
//		}
//		return pulumi.String(string(data))
//	}
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := gcp.NewIntegration(ctx, "gcpMyteam", &gcp.IntegrationArgs{
//				Enabled:  pulumi.Bool(true),
//				PollRate: pulumi.Int(300),
//				ProjectServiceKeys: gcp.IntegrationProjectServiceKeyArray{
//					&gcp.IntegrationProjectServiceKeyArgs{
//						ProjectId:  pulumi.String("gcp_project_id_1"),
//						ProjectKey: readFileOrPanic("/path/to/gcp_credentials_1.json"),
//					},
//					&gcp.IntegrationProjectServiceKeyArgs{
//						ProjectId:  pulumi.String("gcp_project_id_2"),
//						ProjectKey: readFileOrPanic("/path/to/gcp_credentials_2.json"),
//					},
//				},
//				Services: pulumi.StringArray{
//					pulumi.String("compute"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Integration struct {
	pulumi.CustomResourceState

	// List of additional GCP service domain names that you want to monitor
	CustomMetricTypeDomains pulumi.StringArrayOutput `pulumi:"customMetricTypeDomains"`
	// Whether the integration is enabled.
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// If enabled, SignalFx will sync also Google Cloud Metrics data. If disabled, SignalFx will import only metadata. Defaults
	// to true.
	ImportGcpMetrics pulumi.BoolPtrOutput `pulumi:"importGcpMetrics"`
	// [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
	IncludeLists pulumi.StringArrayOutput `pulumi:"includeLists"`
	// Name of the integration.
	Name pulumi.StringOutput `pulumi:"name"`
	// Name of the org token to be used for data ingestion. If not specified then default access token is used.
	NamedToken pulumi.StringPtrOutput `pulumi:"namedToken"`
	// GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
	PollRate pulumi.IntPtrOutput `pulumi:"pollRate"`
	// GCP projects to add.
	ProjectServiceKeys IntegrationProjectServiceKeyArrayOutput `pulumi:"projectServiceKeys"`
	// GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See the documentation for [Creating Integrations](https://dev.splunk.com/observability/reference/api/integrations/latest#endpoint-create-integration) for valid values.
	Services pulumi.StringArrayOutput `pulumi:"services"`
	// When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
	UseMetricSourceProjectForQuota pulumi.BoolPtrOutput `pulumi:"useMetricSourceProjectForQuota"`
}

// NewIntegration registers a new resource with the given unique name, arguments, and options.
func NewIntegration(ctx *pulumi.Context,
	name string, args *IntegrationArgs, opts ...pulumi.ResourceOption) (*Integration, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.ProjectServiceKeys != nil {
		args.ProjectServiceKeys = pulumi.ToSecret(args.ProjectServiceKeys).(IntegrationProjectServiceKeyArrayInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"projectServiceKeys",
	})
	opts = append(opts, secrets)
	var resource Integration
	err := ctx.RegisterResource("signalfx:gcp/integration:Integration", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIntegration gets an existing Integration resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIntegration(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IntegrationState, opts ...pulumi.ResourceOption) (*Integration, error) {
	var resource Integration
	err := ctx.ReadResource("signalfx:gcp/integration:Integration", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Integration resources.
type integrationState struct {
	// List of additional GCP service domain names that you want to monitor
	CustomMetricTypeDomains []string `pulumi:"customMetricTypeDomains"`
	// Whether the integration is enabled.
	Enabled *bool `pulumi:"enabled"`
	// If enabled, SignalFx will sync also Google Cloud Metrics data. If disabled, SignalFx will import only metadata. Defaults
	// to true.
	ImportGcpMetrics *bool `pulumi:"importGcpMetrics"`
	// [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
	IncludeLists []string `pulumi:"includeLists"`
	// Name of the integration.
	Name *string `pulumi:"name"`
	// Name of the org token to be used for data ingestion. If not specified then default access token is used.
	NamedToken *string `pulumi:"namedToken"`
	// GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
	PollRate *int `pulumi:"pollRate"`
	// GCP projects to add.
	ProjectServiceKeys []IntegrationProjectServiceKey `pulumi:"projectServiceKeys"`
	// GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See the documentation for [Creating Integrations](https://dev.splunk.com/observability/reference/api/integrations/latest#endpoint-create-integration) for valid values.
	Services []string `pulumi:"services"`
	// When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
	UseMetricSourceProjectForQuota *bool `pulumi:"useMetricSourceProjectForQuota"`
}

type IntegrationState struct {
	// List of additional GCP service domain names that you want to monitor
	CustomMetricTypeDomains pulumi.StringArrayInput
	// Whether the integration is enabled.
	Enabled pulumi.BoolPtrInput
	// If enabled, SignalFx will sync also Google Cloud Metrics data. If disabled, SignalFx will import only metadata. Defaults
	// to true.
	ImportGcpMetrics pulumi.BoolPtrInput
	// [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
	IncludeLists pulumi.StringArrayInput
	// Name of the integration.
	Name pulumi.StringPtrInput
	// Name of the org token to be used for data ingestion. If not specified then default access token is used.
	NamedToken pulumi.StringPtrInput
	// GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
	PollRate pulumi.IntPtrInput
	// GCP projects to add.
	ProjectServiceKeys IntegrationProjectServiceKeyArrayInput
	// GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See the documentation for [Creating Integrations](https://dev.splunk.com/observability/reference/api/integrations/latest#endpoint-create-integration) for valid values.
	Services pulumi.StringArrayInput
	// When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
	UseMetricSourceProjectForQuota pulumi.BoolPtrInput
}

func (IntegrationState) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationState)(nil)).Elem()
}

type integrationArgs struct {
	// List of additional GCP service domain names that you want to monitor
	CustomMetricTypeDomains []string `pulumi:"customMetricTypeDomains"`
	// Whether the integration is enabled.
	Enabled bool `pulumi:"enabled"`
	// If enabled, SignalFx will sync also Google Cloud Metrics data. If disabled, SignalFx will import only metadata. Defaults
	// to true.
	ImportGcpMetrics *bool `pulumi:"importGcpMetrics"`
	// [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
	IncludeLists []string `pulumi:"includeLists"`
	// Name of the integration.
	Name *string `pulumi:"name"`
	// Name of the org token to be used for data ingestion. If not specified then default access token is used.
	NamedToken *string `pulumi:"namedToken"`
	// GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
	PollRate *int `pulumi:"pollRate"`
	// GCP projects to add.
	ProjectServiceKeys []IntegrationProjectServiceKey `pulumi:"projectServiceKeys"`
	// GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See the documentation for [Creating Integrations](https://dev.splunk.com/observability/reference/api/integrations/latest#endpoint-create-integration) for valid values.
	Services []string `pulumi:"services"`
	// When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
	UseMetricSourceProjectForQuota *bool `pulumi:"useMetricSourceProjectForQuota"`
}

// The set of arguments for constructing a Integration resource.
type IntegrationArgs struct {
	// List of additional GCP service domain names that you want to monitor
	CustomMetricTypeDomains pulumi.StringArrayInput
	// Whether the integration is enabled.
	Enabled pulumi.BoolInput
	// If enabled, SignalFx will sync also Google Cloud Metrics data. If disabled, SignalFx will import only metadata. Defaults
	// to true.
	ImportGcpMetrics pulumi.BoolPtrInput
	// [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
	IncludeLists pulumi.StringArrayInput
	// Name of the integration.
	Name pulumi.StringPtrInput
	// Name of the org token to be used for data ingestion. If not specified then default access token is used.
	NamedToken pulumi.StringPtrInput
	// GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
	PollRate pulumi.IntPtrInput
	// GCP projects to add.
	ProjectServiceKeys IntegrationProjectServiceKeyArrayInput
	// GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See the documentation for [Creating Integrations](https://dev.splunk.com/observability/reference/api/integrations/latest#endpoint-create-integration) for valid values.
	Services pulumi.StringArrayInput
	// When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
	UseMetricSourceProjectForQuota pulumi.BoolPtrInput
}

func (IntegrationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationArgs)(nil)).Elem()
}

type IntegrationInput interface {
	pulumi.Input

	ToIntegrationOutput() IntegrationOutput
	ToIntegrationOutputWithContext(ctx context.Context) IntegrationOutput
}

func (*Integration) ElementType() reflect.Type {
	return reflect.TypeOf((**Integration)(nil)).Elem()
}

func (i *Integration) ToIntegrationOutput() IntegrationOutput {
	return i.ToIntegrationOutputWithContext(context.Background())
}

func (i *Integration) ToIntegrationOutputWithContext(ctx context.Context) IntegrationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationOutput)
}

// IntegrationArrayInput is an input type that accepts IntegrationArray and IntegrationArrayOutput values.
// You can construct a concrete instance of `IntegrationArrayInput` via:
//
//	IntegrationArray{ IntegrationArgs{...} }
type IntegrationArrayInput interface {
	pulumi.Input

	ToIntegrationArrayOutput() IntegrationArrayOutput
	ToIntegrationArrayOutputWithContext(context.Context) IntegrationArrayOutput
}

type IntegrationArray []IntegrationInput

func (IntegrationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Integration)(nil)).Elem()
}

func (i IntegrationArray) ToIntegrationArrayOutput() IntegrationArrayOutput {
	return i.ToIntegrationArrayOutputWithContext(context.Background())
}

func (i IntegrationArray) ToIntegrationArrayOutputWithContext(ctx context.Context) IntegrationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationArrayOutput)
}

// IntegrationMapInput is an input type that accepts IntegrationMap and IntegrationMapOutput values.
// You can construct a concrete instance of `IntegrationMapInput` via:
//
//	IntegrationMap{ "key": IntegrationArgs{...} }
type IntegrationMapInput interface {
	pulumi.Input

	ToIntegrationMapOutput() IntegrationMapOutput
	ToIntegrationMapOutputWithContext(context.Context) IntegrationMapOutput
}

type IntegrationMap map[string]IntegrationInput

func (IntegrationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Integration)(nil)).Elem()
}

func (i IntegrationMap) ToIntegrationMapOutput() IntegrationMapOutput {
	return i.ToIntegrationMapOutputWithContext(context.Background())
}

func (i IntegrationMap) ToIntegrationMapOutputWithContext(ctx context.Context) IntegrationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationMapOutput)
}

type IntegrationOutput struct{ *pulumi.OutputState }

func (IntegrationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Integration)(nil)).Elem()
}

func (o IntegrationOutput) ToIntegrationOutput() IntegrationOutput {
	return o
}

func (o IntegrationOutput) ToIntegrationOutputWithContext(ctx context.Context) IntegrationOutput {
	return o
}

// List of additional GCP service domain names that you want to monitor
func (o IntegrationOutput) CustomMetricTypeDomains() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Integration) pulumi.StringArrayOutput { return v.CustomMetricTypeDomains }).(pulumi.StringArrayOutput)
}

// Whether the integration is enabled.
func (o IntegrationOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Integration) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// If enabled, SignalFx will sync also Google Cloud Metrics data. If disabled, SignalFx will import only metadata. Defaults
// to true.
func (o IntegrationOutput) ImportGcpMetrics() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Integration) pulumi.BoolPtrOutput { return v.ImportGcpMetrics }).(pulumi.BoolPtrOutput)
}

// [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
func (o IntegrationOutput) IncludeLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Integration) pulumi.StringArrayOutput { return v.IncludeLists }).(pulumi.StringArrayOutput)
}

// Name of the integration.
func (o IntegrationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Integration) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Name of the org token to be used for data ingestion. If not specified then default access token is used.
func (o IntegrationOutput) NamedToken() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Integration) pulumi.StringPtrOutput { return v.NamedToken }).(pulumi.StringPtrOutput)
}

// GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
func (o IntegrationOutput) PollRate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Integration) pulumi.IntPtrOutput { return v.PollRate }).(pulumi.IntPtrOutput)
}

// GCP projects to add.
func (o IntegrationOutput) ProjectServiceKeys() IntegrationProjectServiceKeyArrayOutput {
	return o.ApplyT(func(v *Integration) IntegrationProjectServiceKeyArrayOutput { return v.ProjectServiceKeys }).(IntegrationProjectServiceKeyArrayOutput)
}

// GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See the documentation for [Creating Integrations](https://dev.splunk.com/observability/reference/api/integrations/latest#endpoint-create-integration) for valid values.
func (o IntegrationOutput) Services() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Integration) pulumi.StringArrayOutput { return v.Services }).(pulumi.StringArrayOutput)
}

// When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
func (o IntegrationOutput) UseMetricSourceProjectForQuota() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Integration) pulumi.BoolPtrOutput { return v.UseMetricSourceProjectForQuota }).(pulumi.BoolPtrOutput)
}

type IntegrationArrayOutput struct{ *pulumi.OutputState }

func (IntegrationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Integration)(nil)).Elem()
}

func (o IntegrationArrayOutput) ToIntegrationArrayOutput() IntegrationArrayOutput {
	return o
}

func (o IntegrationArrayOutput) ToIntegrationArrayOutputWithContext(ctx context.Context) IntegrationArrayOutput {
	return o
}

func (o IntegrationArrayOutput) Index(i pulumi.IntInput) IntegrationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Integration {
		return vs[0].([]*Integration)[vs[1].(int)]
	}).(IntegrationOutput)
}

type IntegrationMapOutput struct{ *pulumi.OutputState }

func (IntegrationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Integration)(nil)).Elem()
}

func (o IntegrationMapOutput) ToIntegrationMapOutput() IntegrationMapOutput {
	return o
}

func (o IntegrationMapOutput) ToIntegrationMapOutputWithContext(ctx context.Context) IntegrationMapOutput {
	return o
}

func (o IntegrationMapOutput) MapIndex(k pulumi.StringInput) IntegrationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Integration {
		return vs[0].(map[string]*Integration)[vs[1].(string)]
	}).(IntegrationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationInput)(nil)).Elem(), &Integration{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationArrayInput)(nil)).Elem(), IntegrationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationMapInput)(nil)).Elem(), IntegrationMap{})
	pulumi.RegisterOutputType(IntegrationOutput{})
	pulumi.RegisterOutputType(IntegrationArrayOutput{})
	pulumi.RegisterOutputType(IntegrationMapOutput{})
}
