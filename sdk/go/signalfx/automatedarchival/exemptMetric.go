// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package automatedarchival

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-signalfx/sdk/v7/go/signalfx/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ExemptMetric struct {
	pulumi.CustomResourceState

	// List of metrics to be exempted from automated archival
	ExemptMetrics ExemptMetricExemptMetricArrayOutput `pulumi:"exemptMetrics"`
}

// NewExemptMetric registers a new resource with the given unique name, arguments, and options.
func NewExemptMetric(ctx *pulumi.Context,
	name string, args *ExemptMetricArgs, opts ...pulumi.ResourceOption) (*ExemptMetric, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ExemptMetrics == nil {
		return nil, errors.New("invalid value for required argument 'ExemptMetrics'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ExemptMetric
	err := ctx.RegisterResource("signalfx:automatedarchival/exemptMetric:ExemptMetric", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetExemptMetric gets an existing ExemptMetric resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetExemptMetric(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ExemptMetricState, opts ...pulumi.ResourceOption) (*ExemptMetric, error) {
	var resource ExemptMetric
	err := ctx.ReadResource("signalfx:automatedarchival/exemptMetric:ExemptMetric", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ExemptMetric resources.
type exemptMetricState struct {
	// List of metrics to be exempted from automated archival
	ExemptMetrics []ExemptMetricExemptMetric `pulumi:"exemptMetrics"`
}

type ExemptMetricState struct {
	// List of metrics to be exempted from automated archival
	ExemptMetrics ExemptMetricExemptMetricArrayInput
}

func (ExemptMetricState) ElementType() reflect.Type {
	return reflect.TypeOf((*exemptMetricState)(nil)).Elem()
}

type exemptMetricArgs struct {
	// List of metrics to be exempted from automated archival
	ExemptMetrics []ExemptMetricExemptMetric `pulumi:"exemptMetrics"`
}

// The set of arguments for constructing a ExemptMetric resource.
type ExemptMetricArgs struct {
	// List of metrics to be exempted from automated archival
	ExemptMetrics ExemptMetricExemptMetricArrayInput
}

func (ExemptMetricArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*exemptMetricArgs)(nil)).Elem()
}

type ExemptMetricInput interface {
	pulumi.Input

	ToExemptMetricOutput() ExemptMetricOutput
	ToExemptMetricOutputWithContext(ctx context.Context) ExemptMetricOutput
}

func (*ExemptMetric) ElementType() reflect.Type {
	return reflect.TypeOf((**ExemptMetric)(nil)).Elem()
}

func (i *ExemptMetric) ToExemptMetricOutput() ExemptMetricOutput {
	return i.ToExemptMetricOutputWithContext(context.Background())
}

func (i *ExemptMetric) ToExemptMetricOutputWithContext(ctx context.Context) ExemptMetricOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemptMetricOutput)
}

// ExemptMetricArrayInput is an input type that accepts ExemptMetricArray and ExemptMetricArrayOutput values.
// You can construct a concrete instance of `ExemptMetricArrayInput` via:
//
//	ExemptMetricArray{ ExemptMetricArgs{...} }
type ExemptMetricArrayInput interface {
	pulumi.Input

	ToExemptMetricArrayOutput() ExemptMetricArrayOutput
	ToExemptMetricArrayOutputWithContext(context.Context) ExemptMetricArrayOutput
}

type ExemptMetricArray []ExemptMetricInput

func (ExemptMetricArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ExemptMetric)(nil)).Elem()
}

func (i ExemptMetricArray) ToExemptMetricArrayOutput() ExemptMetricArrayOutput {
	return i.ToExemptMetricArrayOutputWithContext(context.Background())
}

func (i ExemptMetricArray) ToExemptMetricArrayOutputWithContext(ctx context.Context) ExemptMetricArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemptMetricArrayOutput)
}

// ExemptMetricMapInput is an input type that accepts ExemptMetricMap and ExemptMetricMapOutput values.
// You can construct a concrete instance of `ExemptMetricMapInput` via:
//
//	ExemptMetricMap{ "key": ExemptMetricArgs{...} }
type ExemptMetricMapInput interface {
	pulumi.Input

	ToExemptMetricMapOutput() ExemptMetricMapOutput
	ToExemptMetricMapOutputWithContext(context.Context) ExemptMetricMapOutput
}

type ExemptMetricMap map[string]ExemptMetricInput

func (ExemptMetricMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ExemptMetric)(nil)).Elem()
}

func (i ExemptMetricMap) ToExemptMetricMapOutput() ExemptMetricMapOutput {
	return i.ToExemptMetricMapOutputWithContext(context.Background())
}

func (i ExemptMetricMap) ToExemptMetricMapOutputWithContext(ctx context.Context) ExemptMetricMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemptMetricMapOutput)
}

type ExemptMetricOutput struct{ *pulumi.OutputState }

func (ExemptMetricOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ExemptMetric)(nil)).Elem()
}

func (o ExemptMetricOutput) ToExemptMetricOutput() ExemptMetricOutput {
	return o
}

func (o ExemptMetricOutput) ToExemptMetricOutputWithContext(ctx context.Context) ExemptMetricOutput {
	return o
}

// List of metrics to be exempted from automated archival
func (o ExemptMetricOutput) ExemptMetrics() ExemptMetricExemptMetricArrayOutput {
	return o.ApplyT(func(v *ExemptMetric) ExemptMetricExemptMetricArrayOutput { return v.ExemptMetrics }).(ExemptMetricExemptMetricArrayOutput)
}

type ExemptMetricArrayOutput struct{ *pulumi.OutputState }

func (ExemptMetricArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ExemptMetric)(nil)).Elem()
}

func (o ExemptMetricArrayOutput) ToExemptMetricArrayOutput() ExemptMetricArrayOutput {
	return o
}

func (o ExemptMetricArrayOutput) ToExemptMetricArrayOutputWithContext(ctx context.Context) ExemptMetricArrayOutput {
	return o
}

func (o ExemptMetricArrayOutput) Index(i pulumi.IntInput) ExemptMetricOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ExemptMetric {
		return vs[0].([]*ExemptMetric)[vs[1].(int)]
	}).(ExemptMetricOutput)
}

type ExemptMetricMapOutput struct{ *pulumi.OutputState }

func (ExemptMetricMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ExemptMetric)(nil)).Elem()
}

func (o ExemptMetricMapOutput) ToExemptMetricMapOutput() ExemptMetricMapOutput {
	return o
}

func (o ExemptMetricMapOutput) ToExemptMetricMapOutputWithContext(ctx context.Context) ExemptMetricMapOutput {
	return o
}

func (o ExemptMetricMapOutput) MapIndex(k pulumi.StringInput) ExemptMetricOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ExemptMetric {
		return vs[0].(map[string]*ExemptMetric)[vs[1].(string)]
	}).(ExemptMetricOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ExemptMetricInput)(nil)).Elem(), &ExemptMetric{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExemptMetricArrayInput)(nil)).Elem(), ExemptMetricArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExemptMetricMapInput)(nil)).Elem(), ExemptMetricMap{})
	pulumi.RegisterOutputType(ExemptMetricOutput{})
	pulumi.RegisterOutputType(ExemptMetricArrayOutput{})
	pulumi.RegisterOutputType(ExemptMetricMapOutput{})
}
